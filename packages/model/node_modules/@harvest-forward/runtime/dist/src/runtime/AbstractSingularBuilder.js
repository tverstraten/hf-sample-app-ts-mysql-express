"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSingularBuilder = void 0;
const System_1 = require("../system/System");
const ValueType_1 = require("../system/ValueType");
const LogAsyncMethod_1 = require("../util/LogAsyncMethod");
const AbstractBuilder_1 = require("./AbstractBuilder");
class AbstractSingularBuilder extends AbstractBuilder_1.AbstractBuilder {
    constructor(nameToUse, descriptionToUse, configsToUse, configurationValues) {
        super(nameToUse, descriptionToUse);
        if (configsToUse)
            this.configs = configsToUse;
        if (configurationValues) {
            Object.keys(configurationValues).forEach((key) => {
                const value = configurationValues[key];
                this.setConfiguredValue(key, value);
            });
        }
    }
    getInitialConfiguration() {
        return {};
    }
    getConfiguration() {
        if (!this.configs)
            this.configs = this.getInitialConfiguration();
        return this.configs;
    }
    getConfigurationNames() {
        const configs = this.getConfiguration();
        const keys = Object.keys(configs);
        return keys;
    }
    getConfiguredValue(name) {
        const configs = this.getConfiguration();
        if (!configs[name])
            return undefined;
        return configs[name].value !== undefined ? configs[name].value : configs[name].defaultValue;
    }
    isCorrectValueType(expectedType, value) {
        switch (expectedType) {
            case ValueType_1.ValueType.STRING:
                if (typeof value !== 'string')
                    throw new TypeError(`Expected string but received ${typeof value}`);
                break;
            case ValueType_1.ValueType.BOOLEAN:
                if (typeof value !== 'boolean')
                    throw new TypeError(`Expected boolean but received ${typeof value}`);
                break;
            case ValueType_1.ValueType.INT:
                if (typeof value !== 'number')
                    throw new TypeError(`Expected number but received ${typeof value}`);
                break;
            case ValueType_1.ValueType.FLOAT:
                if (typeof value !== 'number')
                    throw new TypeError(`Expected number but received ${typeof value}`);
                break;
            default:
                throw new RangeError(`Invalid value type specification provided ${expectedType}`);
        }
    }
    setConfiguredValue(name, value) {
        const configs = this.getConfiguration();
        if (!configs[name])
            throw new RangeError(`Configuration parameter ${name} does not exist`);
        const config = configs[name];
        if (value)
            this.isCorrectValueType(config.valueType, value);
        configs[name].value = value;
    }
    async doesConfigurationWork() {
        let result;
        if (!this.isConfigured())
            result = false;
        else
            result = await this._doesConfigurationWork();
        return result;
    }
    async _doesConfigurationWork() {
        return true;
    }
    async testConfiguration() {
        const missingSettings = this.getMissingConfigurationValues();
        if (missingSettings.length > 0)
            throw new ReferenceError(`Configuration is incomplete, missing ${JSON.stringify(missingSettings)}`);
        const configWorks = await this.doesConfigurationWork();
        if (!configWorks)
            throw new ReferenceError('Configuration is complete but does not function');
    }
    async build(system) {
        await this.testConfiguration();
        const repeatForString = this.getConfiguredValue('repeatFor');
        const matchedComponents = system.findComponentsByString(repeatForString);
        const promises = [];
        matchedComponents.map((component) => {
            promises.push(this.buildInternal(system, component));
        });
        const results = await this.settleArtifactResults(promises);
        return results;
    }
}
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AbstractSingularBuilder.prototype, "doesConfigurationWork", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [System_1.System]),
    __metadata("design:returntype", Promise)
], AbstractSingularBuilder.prototype, "build", null);
exports.AbstractSingularBuilder = AbstractSingularBuilder;

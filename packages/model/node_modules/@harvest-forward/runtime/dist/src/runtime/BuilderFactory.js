"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuilderFactory = void 0;
const LogMethod_1 = require("../util/LogMethod");
const ConcurrentAggregateBuilder_1 = require("./ConcurrentAggregateBuilder");
const Logging_1 = require("./Logging");
const SequentialAggregateBuilder_1 = require("./SequentialAggregateBuilder");
class BuilderFactory {
    static registerBuilder(builderName, factoryMethod) {
        if (BuilderFactory.factories[builderName])
            throw new RangeError(`Builder ${builderName} has already been registered, there is a duplicate`);
        BuilderFactory.factories[builderName] = factoryMethod;
    }
    static async createAggregatedBuilders(settings) {
        const builders = [];
        const configurations = settings;
        const promises = [];
        if (configurations && Array.isArray(configurations)) {
            configurations.forEach((configuration) => {
                if (configuration)
                    promises.push(BuilderFactory.create(configuration));
            });
        }
        const promiseResults = await Promise.allSettled(promises);
        promiseResults.forEach((promiseResult) => {
            if (promiseResult.status === 'fulfilled') {
                builders.push(promiseResult.value);
            }
            else {
                if (typeof promiseResult.reason === 'string')
                    throw new RangeError(promiseResult.reason);
                throw promiseResult.reason;
            }
        });
        return builders;
    }
    static async createBuilderByName(builderName, settings) {
        switch (builderName) {
            case 'ConcurrentAggregateBuilder':
                const concurrentBuilders = await this.createAggregatedBuilders(settings);
                return new ConcurrentAggregateBuilder_1.ConcurrentAggregateBuilder('', concurrentBuilders);
            case 'SequentialAggregateBuilder':
                const sequentialBuilders = await this.createAggregatedBuilders(settings);
                return new SequentialAggregateBuilder_1.SequentialAggregateBuilder('', sequentialBuilders);
            default:
                const factoryMethod = BuilderFactory.factories[builderName];
                if (factoryMethod) {
                    const newBuilder = factoryMethod(settings);
                    if (!newBuilder)
                        throw new TypeError(`Factory ${builderName} did not return a builder`);
                    return newBuilder;
                }
        }
        throw new TypeError(`Configuration does not describe a known builder type ${builderName}`);
    }
    static async create(configuration) {
        try {
            const settings = configuration.settings == '' ? {} : JSON.parse(configuration.settings);
            if (typeof configuration.builder === 'string') {
                const newBuilder = await this.createBuilderByName(configuration.builder, settings);
                return newBuilder;
            }
            if (!configuration.builder)
                throw new RangeError(`Builder configuration is incomplete, missing setting for "builder"`);
            return configuration.builder;
        }
        catch (problem) {
            this.logger.error(`build failed for ${JSON.stringify(configuration)} ${problem}`);
            throw problem;
        }
    }
}
BuilderFactory.logger = Logging_1.Logging.newLogger('BuilderFactory');
BuilderFactory.factories = {};
__decorate([
    (0, LogMethod_1.LogMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Function]),
    __metadata("design:returntype", void 0)
], BuilderFactory, "registerBuilder", null);
exports.BuilderFactory = BuilderFactory;

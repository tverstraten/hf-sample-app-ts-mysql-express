"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractBuilder = void 0;
const Logging_1 = require("./Logging");
class AbstractBuilder {
    constructor(nameToUse, descriptionToUse) {
        this.id = 0;
        this.name = nameToUse;
        this.description = descriptionToUse;
        this.logger = Logging_1.Logging.newLogger(nameToUse);
    }
    isConfigured() {
        const configs = this.getConfiguration();
        const keys = Object.keys(configs);
        for (let index = 0; index < keys.length; index++) {
            const key = keys[index];
            const config = configs[key];
            if (config.required && this.getConfiguredValue(key) == null)
                return false;
        }
        return true;
    }
    getMissingConfigurationValues() {
        const result = [];
        const configs = this.getConfiguration();
        const keys = Object.keys(configs);
        for (let index = 0; index < keys.length; index++) {
            const key = keys[index];
            const config = configs[key];
            if (config.required && this.getConfiguredValue(key) == null)
                result.push(key);
        }
        return result;
    }
    hasConfigurableValue(name) {
        const names = this.getConfigurationNames();
        return names.includes(name);
    }
    regexFromConfigurationString(configurationString) {
        let pattern = configurationString;
        let options = '';
        if (pattern.match(/^[/].*[/][dgimsuy]*$/)) {
            const lastSlash = pattern.lastIndexOf('/');
            options = pattern.substring(lastSlash + 1);
            pattern = pattern.substring(1, lastSlash);
        }
        return new RegExp(pattern, options);
    }
    async settleArtifactResults(promises) {
        const promiseResults = await Promise.allSettled(promises);
        let results = [];
        promiseResults.forEach((promiseResult) => {
            if (promiseResult.status == 'fulfilled')
                results = results.concat(promiseResult.value);
            else {
                if (typeof promiseResult.reason === 'string')
                    throw new RangeError(promiseResult.reason);
                throw promiseResult.reason;
            }
        });
        return results;
    }
}
exports.AbstractBuilder = AbstractBuilder;

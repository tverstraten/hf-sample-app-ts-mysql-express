"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationManager = void 0;
const await_semaphore_1 = require("await-semaphore");
const fs_1 = __importDefault(require("fs"));
const applicationArchitecture = __importStar(require("../plugins/application-architecture"));
const cSharpBindings = __importStar(require("../plugins/csharp-bindings"));
const goBindings = __importStar(require("../plugins/golang-bindings"));
const handlebars = __importStar(require("../plugins/handlebars"));
const javaBindings = __importStar(require("../plugins/java-bindings"));
const javaScript = __importStar(require("../plugins/javaScript"));
const javaScriptBindings = __importStar(require("../plugins/javascript-bindings"));
const node = __importStar(require("../plugins/node"));
const npm = __importStar(require("../plugins/npm"));
const rdbmsBasic = __importStar(require("../plugins/rdbms-basic"));
const ormBasic = __importStar(require("../plugins/orm-basic"));
const phpBindings = __importStar(require("../plugins/php-bindings"));
const pythonBindings = __importStar(require("../plugins/python-bindings"));
const mysql = __importStar(require("../plugins/mysql"));
const rest = __importStar(require("../plugins/rest"));
const typescriptBindings = __importStar(require("../plugins/typescript-bindings"));
const typescriptTypeOrm = __importStar(require("../plugins/typescript-typeorm"));
const vbBindings = __importStar(require("../plugins/vb-bindings"));
const vbNetBindings = __importStar(require("../plugins/vbnet-bindings"));
const ProgrammingLanguage_1 = require("../system/ProgrammingLanguage");
const ValueType_1 = require("../system/ValueType");
const LogAsyncMethod_1 = require("../util/LogAsyncMethod");
const LogMethod_1 = require("../util/LogMethod");
const BuilderFactory_1 = require("./BuilderFactory");
const Logging_1 = require("./Logging");
const TemplateFactory_1 = require("./TemplateFactory");
class ConfigurationManager {
    static registerConfigurationModuleBuilder(pluginName, builders) {
        if (builders) {
            Object.keys(builders).forEach((builderName) => {
                const builderFullName = `${pluginName}/${builderName}`;
                const factoryMethod = builders[builderName];
                BuilderFactory_1.BuilderFactory.registerBuilder(builderFullName, factoryMethod);
            });
        }
    }
    static registerConfigurationModuleTemplates(pluginName, templates) {
        if (templates) {
            Object.keys(templates).forEach((templateName) => {
                const templateDetails = templates[templateName];
                const templateType = templateDetails.type;
                const templateContent = templateDetails.contents;
                const templateFullName = `${templateType}/${pluginName}/${templateName}`;
                TemplateFactory_1.TemplateFactory.registerTemplate(templateFullName, templateContent);
            });
        }
    }
    static registerConfigurationModuleTypeResolvers(typeResolvers) {
        if (typeResolvers) {
            Object.keys(typeResolvers).forEach((languageName) => {
                const resolver = typeResolvers[languageName];
                const language = ProgrammingLanguage_1.ProgrammingLanguage.fromName(languageName);
                ValueType_1.ValueType.install(language, resolver);
            });
        }
    }
    static registerConfigurationByModule(path, module) {
        const pluginName = module['name'] ? module['name'] : path;
        this.registerConfigurationModuleBuilder(pluginName, module['builders']);
        this.registerConfigurationModuleTemplates(pluginName, module['templates']);
        this.registerConfigurationModuleTypeResolvers(module['typeResolvers']);
    }
    static async registerConfigurationByPath(path) {
        if (!path)
            throw RangeError('path was not provided');
        const module = await Promise.resolve().then(() => __importStar(require(path)));
        ConfigurationManager.registerConfigurationByModule(path, module);
    }
    static async registerPluginList(configurationName, pluginList) {
        const promises = [];
        pluginList.forEach((plugInPath) => {
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`registerConfigurationFile(${configurationName}) found ${plugInPath}`) : '';
            promises.push(ConfigurationManager.registerConfigurationByPath(plugInPath));
        });
        const promiseResults = await Promise.allSettled(promises);
        promiseResults.forEach((promiseResult) => {
            if (promiseResult.status === 'rejected') {
                throw promiseResult.reason;
            }
        });
    }
    static async registerConfigurationFile(configurationName, configurationFullPath) {
        const realConfigFilePath = fs_1.default.realpathSync(configurationFullPath);
        this.logger.isLevelEnabled('debug') ? this.logger.debug(`registerConfigurationFile() loading ${realConfigFilePath}`) : '';
        const configurationBodyText = fs_1.default.readFileSync(realConfigFilePath, 'utf-8');
        const configurationBody = JSON.parse(configurationBodyText);
        const pluginList = configurationBody['plugins'];
        if (pluginList)
            await this.registerPluginList(configurationName, pluginList);
        const systemName = configurationBody['name'];
        const systemConfiguration = configurationBody['configuration'];
        if (systemName || systemConfiguration)
            return { name: systemName ? systemName : configurationName, configuration: systemConfiguration ? systemConfiguration : {} };
    }
    static registerPotentialPluginFile(cwd, configFileName) {
        const fullFileName = `${cwd}/${configFileName}`;
        let exists;
        try {
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`registerPlugins() checking for ${fullFileName}`) : '';
            fs_1.default.statSync(fullFileName);
            exists = true;
        }
        catch (problem) {
            exists = false;
        }
        if (exists)
            return ConfigurationManager.registerConfigurationFile(configFileName, fullFileName);
    }
    static registerIncludedPlugins() {
        ConfigurationManager.registerConfigurationByModule('builtIn/handlebars', handlebars);
        ConfigurationManager.registerConfigurationByModule('builtIn/node', node);
        ConfigurationManager.registerConfigurationByModule('builtIn/npm', npm);
        ConfigurationManager.registerConfigurationByModule('builtIn/javascript', javaScript);
        ConfigurationManager.registerConfigurationByModule('builtIn/cSharpBindings', cSharpBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/goBindings', goBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/javaBindings', javaBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/javascriptBindings', javaScriptBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/phpBindings', phpBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/pythonBindings', pythonBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/typescriptBindings', typescriptBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/vbBindings', vbBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/vbNetBindings', vbNetBindings);
        ConfigurationManager.registerConfigurationByModule('builtIn/applicationArchitecture', applicationArchitecture);
        ConfigurationManager.registerConfigurationByModule('builtIn/rdbmsBasic', rdbmsBasic);
        ConfigurationManager.registerConfigurationByModule('builtIn/ormBasic', ormBasic);
        ConfigurationManager.registerConfigurationByModule('builtIn/rest', rest);
        ConfigurationManager.registerConfigurationByModule('builtIn/mysql', mysql);
        ConfigurationManager.registerConfigurationByModule('builtIn/typescriptTypeorm', typescriptTypeOrm);
    }
    static async registerPlugins(configurationFileNames = ConfigurationManager.defaultConfigurationFileNames) {
        if (ConfigurationManager.plugInsRegistered)
            return;
        const semaphore = new await_semaphore_1.Semaphore(10);
        const release = await semaphore.acquire();
        try {
            ConfigurationManager.registerIncludedPlugins();
            const promises = [];
            for (const entry in configurationFileNames) {
                const promise = ConfigurationManager.registerPotentialPluginFile(process.cwd(), configurationFileNames[entry]);
                if (promise)
                    promises.push(promise);
            }
            const promiseResults = await Promise.allSettled(promises);
            promiseResults.forEach((promiseResult) => {
                if (promiseResult.status === 'rejected')
                    throw promiseResult.reason;
            });
            ConfigurationManager.plugInsRegistered = true;
        }
        finally {
            release();
        }
    }
}
ConfigurationManager.plugInsRegistered = false;
ConfigurationManager.defaultConfigurationFileNames = ['.hfrc', '.hf.json', '.hfrc.json'];
ConfigurationManager.logger = Logging_1.Logging.newLogger('ConfigurationManager');
__decorate([
    (0, LogMethod_1.LogMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], ConfigurationManager, "registerConfigurationByModule", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ConfigurationManager, "registerConfigurationByPath", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ConfigurationManager, "registerConfigurationFile", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ConfigurationManager, "registerPlugins", null);
exports.ConfigurationManager = ConfigurationManager;

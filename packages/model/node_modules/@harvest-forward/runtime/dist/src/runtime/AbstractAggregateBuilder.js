"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractAggregateBuilder = void 0;
const LogAsyncMethod_1 = require("../util/LogAsyncMethod");
const AbstractBuilder_1 = require("./AbstractBuilder");
class AbstractAggregateBuilder extends AbstractBuilder_1.AbstractBuilder {
    constructor(nameToUse, descriptionToUse, buildersToUse) {
        super(nameToUse, descriptionToUse);
        this.builders = buildersToUse;
    }
    getConfiguration() {
        const allParameters = {};
        if (this.builders) {
            this.builders.forEach((builder) => {
                const buildersConfig = builder.getConfiguration();
                const keys = Object.keys(buildersConfig);
                keys.forEach((key) => {
                    const parameter = buildersConfig[key];
                    const adjustedKey = `${builder.name}${AbstractAggregateBuilder.nameSeparator}${key}`;
                    allParameters[adjustedKey] = parameter;
                });
            });
        }
        return allParameters;
    }
    getConfigurationNames() {
        const allNames = [];
        this.builders.forEach((builder) => {
            const buildersConfig = builder.getConfiguration();
            const keys = Object.keys(buildersConfig);
            keys.forEach((key) => {
                const adjustedKey = `${builder.name}${AbstractAggregateBuilder.nameSeparator}${key}`;
                allNames.push(adjustedKey);
            });
        });
        return allNames;
    }
    getConfiguredValue(name) {
        const exclaimAt = name.indexOf(AbstractAggregateBuilder.nameSeparator);
        const builderName = name.substring(0, exclaimAt);
        const parameterName = name.substring(exclaimAt + 1);
        for (let builderIndex = 0; builderIndex < this.builders.length; builderIndex++) {
            const builder = this.builders[builderIndex];
            if (builder.name == builderName) {
                if (builder.hasConfigurableValue(parameterName))
                    return builder.getConfiguredValue(parameterName);
            }
        }
        return null;
    }
    setConfiguredValue(name, value) {
        const exclaimAt = name.indexOf(AbstractAggregateBuilder.nameSeparator);
        const builderName = name.substring(0, exclaimAt);
        const parameterName = name.substring(exclaimAt + 1);
        for (let builderIndex = 0; builderIndex < this.builders.length; builderIndex++) {
            const builder = this.builders[builderIndex];
            if (builder.name == builderName) {
                if (builder.hasConfigurableValue(parameterName))
                    builder.setConfiguredValue(parameterName, value);
            }
        }
    }
    async doesConfigurationWork() {
        if (!this.isConfigured())
            return false;
        const promises = [];
        this.builders.map((builder) => {
            promises.push(builder.doesConfigurationWork());
        });
        const results = await Promise.all(promises);
        const anyFail = results.filter((item) => !item);
        return anyFail.length == 0;
    }
    async getFailingConfigurations() {
        const failing = [];
        for (let index = 0; index < this.builders.length; index++) {
            const builder = this.builders[index];
            const works = await builder.doesConfigurationWork();
            if (!works)
                failing.push(builder);
        }
        return failing;
    }
    async testConfiguration() {
        const missingSettings = this.getMissingConfigurationValues();
        if (missingSettings.length > 0)
            throw new ReferenceError(`Configuration is incomplete, missing ${JSON.stringify(missingSettings)}`);
        const failing = await this.getFailingConfigurations();
        if (failing.length > 0) {
            let failText = '';
            failing.forEach((builder) => {
                failText += `${builder.name} with {`;
                const names = builder.getConfigurationNames();
                names.forEach((name) => {
                    const value = builder.getConfiguredValue(name);
                    failText += `${name}-${value},`;
                });
                failText += `}`;
            });
            throw new ReferenceError(`Configuration is complete but does not function, failing builders are: ${failText}`);
        }
    }
}
AbstractAggregateBuilder.nameSeparator = '!';
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AbstractAggregateBuilder.prototype, "doesConfigurationWork", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], AbstractAggregateBuilder.prototype, "getFailingConfigurations", null);
exports.AbstractAggregateBuilder = AbstractAggregateBuilder;

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TemplateFactory = void 0;
const LogAsyncMethod_1 = require("../util/LogAsyncMethod");
const LogMethod_1 = require("../util/LogMethod");
const Logging_1 = require("./Logging");
class TemplateFactory {
    static registerTemplate(templateName, content) {
        if (!templateName)
            throw new RangeError('templateName must be provided');
        if (!content)
            throw new RangeError('content must be provided');
        if (TemplateFactory.templateResolvers[templateName])
            throw new RangeError(`Template "${templateName}" has already been registered, there is a duplicate`);
        TemplateFactory.templateResolvers[templateName] = content;
    }
    static async getTemplate(name) {
        let content = TemplateFactory.templates[name];
        if (!content) {
            const resolver = TemplateFactory.templateResolvers[name];
            const resolverType = typeof resolver;
            if (resolverType === 'string') {
                content = resolver;
                TemplateFactory.templates[name] = content;
            }
            else if (resolverType === 'function') {
                try {
                    content = (await resolver());
                    TemplateFactory.templates[name] = content;
                }
                catch (problem) {
                    this.logger.error(`getTemplate failed for ${name} ${problem}`);
                    throw problem;
                }
            }
            else
                throw new RangeError(`Cannot resolve content for template with the name ${name}`);
        }
        return content;
    }
}
TemplateFactory.logger = Logging_1.Logging.newLogger('TemplateFactory');
TemplateFactory.templateResolvers = {};
TemplateFactory.templates = {};
__decorate([
    (0, LogMethod_1.LogMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", void 0)
], TemplateFactory, "registerTemplate", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TemplateFactory, "getTemplate", null);
exports.TemplateFactory = TemplateFactory;

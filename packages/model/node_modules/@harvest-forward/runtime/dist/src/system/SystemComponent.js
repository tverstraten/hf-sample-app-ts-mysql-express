"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SystemComponent = void 0;
const ChangeCase = __importStar(require("change-case"));
class SystemComponent {
    constructor(componentType) {
        this._children = {};
        this._descendants = {};
        this._componentType = componentType;
    }
    disconnectRecursion() {
        Object.values(this._children).forEach((element) => {
            element.disconnectRecursion();
        });
    }
    reconnectRecursion(system) {
        Object.values(this._children).forEach((element) => {
            element.reconnectRecursion(system);
        });
    }
    static constantCase(name, preserveSlashes = false) {
        let constantCaseName = '';
        if (preserveSlashes) {
            const pieces = name.split('/');
            pieces.forEach((piece) => {
                if (constantCaseName !== '')
                    constantCaseName += '/';
                constantCaseName += ChangeCase.constantCase(piece);
            });
        }
        else
            constantCaseName = ChangeCase.constantCase(name);
        return this.normalizePathSlashes(constantCaseName.replace(/[\\ !#\.]/g, '/'));
    }
    static normalizePathSlashes(name) {
        return name.replace(/^\//, '').replace(/\/$/, '').replace(/\/\//, '/');
    }
    static fullConstantCase(nameSpace, name) {
        const adjustedNameSpace = this.constantCase(nameSpace, true);
        const adjustedName = this.constantCase(name);
        return `${adjustedNameSpace}/${adjustedName}`;
    }
    get componentType() {
        return this._componentType;
    }
    set componentType(newValue) {
        this._componentType = newValue;
    }
    get children() {
        return this._children;
    }
    hasChild(component) {
        const fullName = component.fullConstantCaseName;
        return this._children[fullName] != null;
    }
    addChild(child) {
        if (!this.hasChild(child)) {
            const fullName = child.fullConstantCaseName;
            this._children[fullName] = child;
            child.parent = this;
            this.addDescendant(child);
        }
    }
    removeChild(child) {
        if (this.hasChild(child)) {
            const fullName = child.fullConstantCaseName;
            delete this._children[fullName];
            this.removeDescendant(child);
            child.parent = undefined;
            return true;
        }
        return false;
    }
    removeChildByName(childName) {
        if (!childName)
            throw RangeError(`childName must be defined`);
        const child = this._children[childName];
        return child ? this.removeChild(child) : false;
    }
    get descendants() {
        return this._descendants;
    }
    hasDescendant(component) {
        const fullName = component.fullConstantCaseName;
        return this._descendants[fullName] != null;
    }
    addDescendant(component) {
        if (!this.hasDescendant(component)) {
            const fullName = component.fullConstantCaseName;
            this._descendants[fullName] = component;
            if (this.parent != null)
                this.parent.addDescendant(component);
            Object.values(component.descendants).forEach((grandDescendant) => {
                this.addDescendant(grandDescendant);
            });
        }
    }
    removeDescendant(component) {
        if (this.hasDescendant(component)) {
            const fullName = component.fullConstantCaseName;
            delete this._descendants[fullName];
            if (this.parent != null)
                this.parent.removeDescendant(component);
            Object.values(component._children).forEach((grandChild) => {
                this.removeDescendant(grandChild);
            });
        }
    }
    findComponentsByString(searchString) {
        if (searchString == null || searchString.length == 0)
            return [this];
        try {
            const searchJson = JSON.parse(searchString);
            return this.findComponents(searchJson);
        }
        catch (problem) {
            throw new RangeError(`Cannot extract search criteria from JSON string ${searchString}`);
        }
    }
    findOneComponent(search) {
        const results = this._findComponents(search, true);
        if (results.length === 1)
            return results[0];
        return undefined;
    }
    findComponents(search) {
        return this._findComponents(search);
    }
    findByFullName(fullConstantCaseName) {
        const searchValues = Array.isArray(fullConstantCaseName) ? fullConstantCaseName : [fullConstantCaseName];
        let matched = [];
        searchValues.forEach((searchValue) => {
            const found = this.descendants[searchValue];
            if (found)
                matched = [found];
        });
        return matched;
    }
    transformSearchCriteria(search) {
        const searchEntries = Object.entries(search);
        const adjustedSearch = {};
        for (const [key, searchValueSpec] of searchEntries) {
            const searchValues = Array.isArray(searchValueSpec) ? searchValueSpec : [searchValueSpec];
            const adjustedSearchValues = [];
            searchValues.forEach((searchValue) => {
                if (typeof searchValue === 'string' && searchValue.startsWith('/') && searchValue.endsWith('/')) {
                    const regexString = searchValue.substring(1, searchValue.length - 1);
                    const searchRegex = new RegExp(regexString);
                    adjustedSearchValues.push(searchRegex);
                }
                else
                    adjustedSearchValues.push(searchValue);
            });
            adjustedSearch[key] = adjustedSearchValues;
        }
        return adjustedSearch;
    }
    doesObjectMatch(adjustedSearchEntries, component) {
        let matches = true;
        for (const [key, searchValues] of adjustedSearchEntries) {
            const componentValue = component[key];
            let oneValueMatches = false;
            searchValues.forEach((searchValue) => {
                if (searchValue instanceof RegExp && typeof componentValue === 'string') {
                    if (componentValue.match(searchValue))
                        oneValueMatches = true;
                }
                else if (searchValue == componentValue) {
                    oneValueMatches = true;
                }
            });
            if (!oneValueMatches)
                matches = false;
        }
        return matches;
    }
    _findComponents(search, stopAtOne = false) {
        if (search == null || Object.keys(search).length === 0)
            return [this];
        const searchedName = search['fullConstantCaseName'];
        if (searchedName)
            return this.findByFullName(searchedName);
        const adjustedSearch = this.transformSearchCriteria(search);
        const matchedComponents = [];
        const descendants = Object.values(this.descendants);
        const adjustedSearchEntries = Object.entries(adjustedSearch);
        for (let index = 0; index < descendants.length; index++) {
            const component = descendants[index];
            const matches = this.doesObjectMatch(adjustedSearchEntries, component);
            if (matches && !matchedComponents.includes(component)) {
                matchedComponents.push(component);
                if (stopAtOne && matchedComponents.length > 1)
                    throw RangeError(`More than 1 component matched ${JSON.stringify(search)}`);
            }
        }
        return matchedComponents;
    }
}
exports.SystemComponent = SystemComponent;

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueType = void 0;
const Logging_1 = require("../runtime/Logging");
const LogMethod_1 = require("../util/LogMethod");
const ProgrammingLanguage_1 = require("./ProgrammingLanguage");
const SystemComponentType_1 = require("./SystemComponentType");
const SystemDescendantComponent_1 = require("./SystemDescendantComponent");
class ValueType extends SystemDescendantComponent_1.SystemDescendantComponent {
    constructor(objectType, nameSpace, name, desc, primitive = true) {
        super(objectType, nameSpace, name, SystemComponentType_1.SystemComponentType.informationModel, desc);
        this.isCollection = false;
        this.updateable = false;
        this.primitive = primitive;
    }
    get asCollection() {
        if (this._asCollection == null) {
            this._asCollection = new ValueType('ValueType', this.constantCaseNameSpace, `${this.name}[]`, `A collection of objects described as: ${this.description}`, this.primitive);
            this._asCollection.collectedType = this;
            this._asCollection.isCollection = true;
            return this._asCollection;
        }
        else
            return this._asCollection;
    }
    static install(language, resolver) {
        ValueType.typeResolverMap[language.name] = resolver;
    }
    static uninstall(language) {
        delete ValueType.typeResolverMap[language.name];
    }
    static getValues() {
        return ValueType.types;
    }
    static hasNameInType(language, name) {
        const resolver = ValueType.typeResolverMap[language.name];
        return resolver ? resolver.hasName(name) : false;
    }
    static hasName(name) {
        if (name == null)
            throw RangeError(`a value must be provided for name`);
        for (let index = 0; index < ValueType.types.length; index++) {
            const type = ValueType.types[index];
            if (type.name === name)
                return true;
        }
        return false;
    }
    static fromNameInType(language, name) {
        const resolver = ValueType.typeResolverMap[language.name];
        if (resolver.doesSupport(language)) {
            for (let index = 0; index < ValueType.types.length; index++) {
                const type = ValueType.types[index];
                const optionalName = resolver.fromType(type, false);
                if (optionalName === name)
                    return type;
                const mandatoryName = resolver.fromType(type, true);
                if (mandatoryName === name)
                    return type;
            }
        }
        throw ReferenceError(`no ValueType for ${name}`);
    }
    static fromName(name) {
        for (let index = 0; index < ValueType.types.length; index++) {
            const type = ValueType.types[index];
            if (type.name === name)
                return type;
        }
        throw ReferenceError(`no ValueType for ${name}`);
    }
    inLanguage(language, nullable = false, length = 0) {
        if (this.isCollection) {
            const componentName = this.collectedType?.inLanguage(language, nullable, length);
            return `${componentName}[]`;
        }
        const resolver = ValueType.typeResolverMap[language.name];
        if (!resolver)
            throw new RangeError(`Cannot map to language ${language}`);
        const definitionSpec = resolver.doesMap(this) ? resolver.fromType(this, nullable) : this.name;
        if (definitionSpec != null) {
            let finalForm;
            if (length == null)
                finalForm = definitionSpec.replace(/\%l/, '');
            else
                finalForm = definitionSpec.replace(/\%l/, length.toString());
            return finalForm;
        }
        return this.name;
    }
    get isObject() {
        return false;
    }
}
ValueType.logger = Logging_1.Logging.newLogger('ValueType');
ValueType.typeResolverMap = {};
ValueType.OBJECT = new ValueType('ValueType', 'INFORMATION_MODEL', 'object', '', true);
ValueType.STRING = new ValueType('ValueType', 'INFORMATION_MODEL', 'string', '', true);
ValueType.INT = new ValueType('ValueType', 'INFORMATION_MODEL', 'int', '', true);
ValueType.FLOAT = new ValueType('ValueType', 'INFORMATION_MODEL', 'float', '', true);
ValueType.BOOLEAN = new ValueType('ValueType', 'INFORMATION_MODEL', 'boolean', '', true);
ValueType.DATE_TIME = new ValueType('ValueType', 'INFORMATION_MODEL', 'dateTime', '', true);
ValueType.DATE = new ValueType('ValueType', 'INFORMATION_MODEL', 'date', '', true);
ValueType.TIME = new ValueType('ValueType', 'INFORMATION_MODEL', 'time', '', true);
ValueType.INTERVAL = new ValueType('ValueType', 'INFORMATION_MODEL', 'interval', '', true);
ValueType.DECIMAL = new ValueType('ValueType', 'INFORMATION_MODEL', 'decimal', '', true);
ValueType.VOID = new ValueType('ValueType', 'INFORMATION_MODEL', 'void', '', true);
ValueType.types = [
    ValueType.OBJECT,
    ValueType.STRING,
    ValueType.INT,
    ValueType.FLOAT,
    ValueType.BOOLEAN,
    ValueType.DATE_TIME,
    ValueType.DATE,
    ValueType.TIME,
    ValueType.INTERVAL,
    ValueType.DECIMAL,
    ValueType.VOID,
];
__decorate([
    (0, LogMethod_1.LogMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [ProgrammingLanguage_1.ProgrammingLanguage, Object]),
    __metadata("design:returntype", void 0)
], ValueType, "install", null);
exports.ValueType = ValueType;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogAsyncMethod = void 0;
const LogAction_1 = require("./LogAction");
const LogHelper_1 = require("./LogHelper");
function LogAsyncMethod(logType = [LogAction_1.LogAction.exit, LogAction_1.LogAction.exception]) {
    return function (__target, methodName, descriptor) {
        const target_method = descriptor.value;
        descriptor.value = async function (...args) {
            const loggable = this;
            let arg_text;
            if (logType.includes(LogAction_1.LogAction.entry)) {
                arg_text = await LogHelper_1.LogHelper.argumentsTextAsync(args);
                loggable.logger.debug(`${methodName}(${arg_text}) enter`);
            }
            try {
                const result = await target_method.apply(this, args);
                if (logType.includes(LogAction_1.LogAction.exit)) {
                    const result_text = await LogHelper_1.LogHelper.argumentsTextAsync(result);
                    arg_text = arg_text ? arg_text : await LogHelper_1.LogHelper.argumentsTextAsync(args);
                    loggable.logger.debug(`${methodName}(${arg_text}) exit (${result_text})`);
                }
                return result;
            }
            catch (problem) {
                if (logType.includes(LogAction_1.LogAction.exception)) {
                    const problem_text = await LogHelper_1.LogHelper.argumentsTextAsync(problem, LogHelper_1.LogHelper.maxErrorTextLength);
                    arg_text = arg_text ? arg_text : await LogHelper_1.LogHelper.argumentsTextAsync(args);
                    const exception_text = `${methodName}(${arg_text}) exception:(${problem_text}) stack:${problem.stack}`;
                    loggable.logger.error(exception_text);
                }
                throw problem;
            }
        };
    };
}
exports.LogAsyncMethod = LogAsyncMethod;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractMySqlSchemaHarvester = void 0;
const mariadb_1 = __importDefault(require("mariadb"));
const System_1 = require("../../system/System");
const ValueType_1 = require("../../system/ValueType");
const rdbms_basic_1 = require("../rdbms-basic");
class AbstractMySqlSchemaHarvester extends rdbms_basic_1.AbstractSqlSchemaHarvester {
    constructor() {
        super(...arguments);
        this.columnTypeToValueTypeMap = {
            TINYINT: ValueType_1.ValueType.INT,
            BOOLEAN: ValueType_1.ValueType.BOOLEAN,
            SMALLINT: ValueType_1.ValueType.INT,
            MEDIUMINT: ValueType_1.ValueType.INT,
            INT: ValueType_1.ValueType.INT,
            INTEGER: ValueType_1.ValueType.INT,
            BIGINT: ValueType_1.ValueType.INT,
            DECIMAL: ValueType_1.ValueType.DECIMAL,
            DEC: ValueType_1.ValueType.DECIMAL,
            NUMERIC: ValueType_1.ValueType.FLOAT,
            FIXED: ValueType_1.ValueType.FLOAT,
            NUMBER: ValueType_1.ValueType.FLOAT,
            FLOAT: ValueType_1.ValueType.FLOAT,
            DOUBLE: ValueType_1.ValueType.FLOAT,
            BIT: ValueType_1.ValueType.BOOLEAN,
            INT1: ValueType_1.ValueType.INT,
            INT2: ValueType_1.ValueType.INT,
            INT3: ValueType_1.ValueType.INT,
            INT4: ValueType_1.ValueType.INT,
            INT8: ValueType_1.ValueType.INT,
            CHAR: ValueType_1.ValueType.STRING,
            VARCHAR: ValueType_1.ValueType.STRING,
            BINARY: ValueType_1.ValueType.STRING,
            CHARBYTE: ValueType_1.ValueType.STRING,
            VARBINARY: ValueType_1.ValueType.STRING,
            TINYBLOB: ValueType_1.ValueType.STRING,
            BLOB: ValueType_1.ValueType.STRING,
            MEDIUMBLOB: ValueType_1.ValueType.STRING,
            LONGBLOB: ValueType_1.ValueType.STRING,
            TINYTEXT: ValueType_1.ValueType.STRING,
            TEXT: ValueType_1.ValueType.STRING,
            MEDIUMTEXT: ValueType_1.ValueType.STRING,
            LONGTEXT: ValueType_1.ValueType.STRING,
            INET6: ValueType_1.ValueType.STRING,
            JSON: ValueType_1.ValueType.STRING,
            SET: ValueType_1.ValueType.STRING,
            ENUM: ValueType_1.ValueType.STRING,
            DATE: ValueType_1.ValueType.DATE,
            TIME: ValueType_1.ValueType.DATE_TIME,
            DATETIME: ValueType_1.ValueType.DATE_TIME,
            TIMESTAMP: ValueType_1.ValueType.DATE_TIME,
            YEAR: ValueType_1.ValueType.INT,
        };
    }
    connection() {
        if (this._connection == null)
            throw RangeError(`Not connected`);
        return this._connection;
    }
    async connect() {
        try {
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`connect(${this.name}) enter`) : '';
            this.pool = mariadb_1.default.createPool({
                host: this.getConfiguredValue('serverUrl'),
                user: this.getConfiguredValue('userName'),
                password: this.getConfiguredValue('password'),
                connectionLimit: 5,
            });
            this._connection = await this.pool.getConnection();
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`connect(${this.name}) exit`) : '';
        }
        catch (problem) {
            this.logger.error(`connect(${this.name}) failed ${problem}`);
            throw problem;
        }
    }
    async disconnect() {
        this.logger.isLevelEnabled('debug') ? this.logger.debug(`disconnect() enter`) : '';
        if (this.connection != null)
            this._connection?.release();
    }
    async performQuery(system) {
        this.logger.isLevelEnabled('debug') ? this.logger.debug(`performQuery(${this.name}) enter`) : '';
        try {
            const server = this.getConfiguredValue('serverUrl');
            const database = this.getConfiguredValue('database');
            const queryText = this.getConfiguredValue('queryText');
            const fullDbName = System_1.System.fullConstantCase(server, database);
            const db = system.descendants[fullDbName];
            const request = await this.connection().query(queryText);
            const results = [];
            if (request.recordset != null) {
                this.logger.isLevelEnabled('debug')
                    ? this.logger.debug(`performQuery(${this.name}) decoding data with ${request.recordsets.length} recordsets`)
                    : '';
                request.recordsets.forEach((recordset) => {
                    recordset.forEach((row) => {
                        const rowResults = this.harvestRow(system, db, row);
                        rowResults.forEach((rowArtifact) => results.push(rowArtifact));
                    });
                });
            }
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`performQuery(${this.name}) exit`) : '';
            return results;
        }
        catch (problem) {
            this.logger.error(`performQuery(${this.name}) failed ${problem}`);
            throw problem;
        }
    }
    getValueToValueTypeMap() {
        return this.columnTypeToValueTypeMap;
    }
}
exports.AbstractMySqlSchemaHarvester = AbstractMySqlSchemaHarvester;

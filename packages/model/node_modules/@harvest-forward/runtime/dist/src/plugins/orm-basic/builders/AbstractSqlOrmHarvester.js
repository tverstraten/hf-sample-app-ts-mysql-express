"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractSqlOrmHarvester = void 0;
const AbstractSingularBuilder_1 = require("../../../runtime/AbstractSingularBuilder");
const System_1 = require("../../../system/System");
const SystemComponentArtifact_1 = require("../../../system/SystemComponentArtifact");
const ValueType_1 = require("../../../system/ValueType");
const rdbms_basic_1 = require("../../rdbms-basic");
const ObjectRelationalMapping_1 = require("../ObjectRelationalMapping");
class AbstractSqlOrmHarvester extends AbstractSingularBuilder_1.AbstractSingularBuilder {
    constructor(name, description, configurationValues) {
        super(name, description, {
            serverUrl: {
                name: 'Server URL',
                required: true,
                description: 'The url to the server to connect to',
                valueType: ValueType_1.ValueType.STRING,
            },
            database: {
                name: 'Database Name',
                required: true,
                description: 'The name of the database in the server to connect to',
                valueType: ValueType_1.ValueType.STRING,
            },
            userName: {
                name: 'User Name',
                required: true,
                description: 'The user name to present to sql server for authentication',
                valueType: ValueType_1.ValueType.STRING,
            },
            password: {
                name: 'User Password',
                required: true,
                description: 'The character sequence that validates the user name',
                valueType: ValueType_1.ValueType.STRING,
            },
            queryText: {
                name: 'Query Text',
                required: true,
                description: 'The sql text to execute against the database, each row of which will result in a call to harvestRow',
                valueType: ValueType_1.ValueType.STRING,
                defaultValue: '.*',
            },
            schemaPattern: {
                name: 'Schema pattern',
                required: true,
                description: 'A regex used against the schema name to determine if it should be included in the harvesting',
                valueType: ValueType_1.ValueType.STRING,
                defaultValue: '.*',
            },
            tablePattern: {
                name: 'Table pattern',
                required: true,
                description: 'A regex used against the non-qualified table/view name to determine if it should be included in the harvesting',
                valueType: ValueType_1.ValueType.STRING,
                defaultValue: '.*',
            },
            columnPattern: {
                name: 'Column pattern',
                required: true,
                description: 'A regex used against the non-qualified column name to determine if it should be included in the harvesting',
                valueType: ValueType_1.ValueType.STRING,
                defaultValue: '.*',
            },
        }, configurationValues);
        this.regexSet = false;
        this.schemaRegex = new RegExp('.*');
        this.tableRegex = new RegExp('.*');
        this.columnRegex = new RegExp('.*');
    }
    async _doesConfigurationWork() {
        try {
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`_doesConfigurationWork(${this.name}) enter`) : '';
            await this.connect();
            this.ensureRegexes();
            return true;
        }
        catch (problem) {
            this.logger.error(`_doesConfigurationWork(${this.name}) failed ${problem}`);
            return false;
        }
        finally {
            await this.disconnect();
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`_doesConfigurationWork(${this.name}) exit`) : '';
        }
    }
    regexFromConfigurationString(configurationString) {
        let pattern = configurationString;
        let options = '';
        if (pattern.match(/^[/].*[/][dgimsuy]*$/)) {
            const lastSlash = pattern.lastIndexOf('/');
            options = pattern.substr(lastSlash + 1);
            pattern = pattern.substr(1, lastSlash - 1);
        }
        return new RegExp(pattern, options);
    }
    ensureRegexes() {
        if (!this.regexSet) {
            this.schemaRegex = this.regexFromConfigurationString(this.getConfiguredValue('schemaPattern'));
            this.tableRegex = this.regexFromConfigurationString(this.getConfiguredValue('tablePattern'));
            this.columnRegex = this.regexFromConfigurationString(this.getConfiguredValue('columnPattern'));
            this.regexSet = true;
        }
    }
    validTable(table) {
        return this.schemaRegex.test(table.nameSpace) && this.tableRegex.test(table.name);
    }
    validView(view) {
        return this.schemaRegex.test(view.nameSpace) && this.tableRegex.test(view.name);
    }
    validColumn(column) {
        return this.schemaRegex.test(column.schemaName) && this.tableRegex.test(column.tableName) && this.columnRegex.test(column.name);
    }
    validDomain(domain) {
        return this.schemaRegex.test(domain.nameSpace);
    }
    validForeignKey(fk) {
        return (this.schemaRegex.test(fk.schemaName) &&
            this.schemaRegex.test(fk.targetSchemaName) &&
            this.tableRegex.test(fk.sourceTableName) &&
            this.tableRegex.test(fk.targetTableName) &&
            this.columnRegex.test(fk.sourceColumnName));
    }
    validPrimaryKey(pk) {
        return this.schemaRegex.test(pk.schemaName) && this.tableRegex.test(pk.tableName) && this.columnRegex.test(pk.columnName);
    }
    validConstraint(constraint) {
        return this.schemaRegex.test(constraint.nameSpace) && this.tableRegex.test(constraint.name);
    }
    async buildInternal(system, __component) {
        const results = [];
        try {
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`buildInternal(${system.name}) enter`) : '';
            this.ensureRegexes();
            const server = this.getConfiguredValue('serverUrl');
            const database = this.getConfiguredValue('database');
            const fullDbName = System_1.System.fullConstantCase(server, database);
            let db = system.descendants[fullDbName];
            if (db == null) {
                db = new rdbms_basic_1.RelationalDatabase(server, database, '');
                system.addChild(db);
                results.push(new SystemComponentArtifact_1.SystemComponentArtifact(db));
            }
            let orm = system.findOneComponent({
                objectTypeName: 'ObjectRelationalMapping',
            });
            if (orm == null) {
                orm = new ObjectRelationalMapping_1.ObjectRelationalMapping('ORM', db.fullConstantCaseName, '');
                system.addChild(orm);
                results.push(new SystemComponentArtifact_1.SystemComponentArtifact(orm));
            }
            await this.connect();
            const queryResults = await this.performQuery(system);
            results.concat(queryResults);
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`buildInternal(${system.name}) exit`) : '';
            return results;
        }
        catch (problem) {
            this.logger.error(`buildInternal(${system.name}) failed ${problem}`);
            throw problem;
        }
        finally {
            await this.disconnect();
        }
    }
}
exports.AbstractSqlOrmHarvester = AbstractSqlOrmHarvester;

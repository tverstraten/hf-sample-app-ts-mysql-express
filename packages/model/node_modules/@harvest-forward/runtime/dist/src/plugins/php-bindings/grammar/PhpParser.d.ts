declare class PhpParser {
    static grammarFileName: string;
    static literalNames: (string | null)[];
    static symbolicNames: (string | null)[];
    static ruleNames: string[];
    constructor(input: any);
    _interp: any;
    ruleNames: string[];
    literalNames: (string | null)[];
    symbolicNames: (string | null)[];
    get atn(): any;
    sempred(localctx: any, ruleIndex: any, predIndex: any): any;
    typeHint_sempred(localctx: any, predIndex: any): any;
    expression_sempred(localctx: any, predIndex: any): any;
    htmlDocument(): HtmlDocumentContext;
    state: number | undefined;
    inlineHtml(): InlineHtmlContext;
    htmlElement(): HtmlElementContext;
    scriptText(): ScriptTextContext;
    phpBlock(): PhpBlockContext;
    importStatement(): ImportStatementContext;
    topStatement(): TopStatementContext;
    useDeclaration(): UseDeclarationContext;
    useDeclarationContentList(): UseDeclarationContentListContext;
    useDeclarationContent(): UseDeclarationContentContext;
    namespaceDeclaration(): NamespaceDeclarationContext;
    namespaceStatement(): NamespaceStatementContext;
    functionDeclaration(): FunctionDeclarationContext;
    classDeclaration(): ClassDeclarationContext;
    classEntryType(): ClassEntryTypeContext;
    interfaceList(): InterfaceListContext;
    typeParameterListInBrackets(): TypeParameterListInBracketsContext;
    typeParameterList(): TypeParameterListContext;
    typeParameterWithDefaultsList(): TypeParameterWithDefaultsListContext;
    typeParameterDecl(): TypeParameterDeclContext;
    typeParameterWithDefaultDecl(): TypeParameterWithDefaultDeclContext;
    genericDynamicArgs(): GenericDynamicArgsContext;
    attributes(): AttributesContext;
    attributeGroup(): AttributeGroupContext;
    attribute(): AttributeContext;
    innerStatementList(): InnerStatementListContext;
    innerStatement(): InnerStatementContext;
    statement(): StatementContext;
    emptyStatement(): EmptyStatementContext;
    blockStatement(): BlockStatementContext;
    ifStatement(): IfStatementContext;
    elseIfStatement(): ElseIfStatementContext;
    elseIfColonStatement(): ElseIfColonStatementContext;
    elseStatement(): ElseStatementContext;
    elseColonStatement(): ElseColonStatementContext;
    whileStatement(): WhileStatementContext;
    doWhileStatement(): DoWhileStatementContext;
    forStatement(): ForStatementContext;
    forInit(): ForInitContext;
    forUpdate(): ForUpdateContext;
    switchStatement(): SwitchStatementContext;
    switchBlock(): SwitchBlockContext;
    breakStatement(): BreakStatementContext;
    continueStatement(): ContinueStatementContext;
    returnStatement(): ReturnStatementContext;
    expressionStatement(): ExpressionStatementContext;
    unsetStatement(): UnsetStatementContext;
    foreachStatement(): ForeachStatementContext;
    tryCatchFinally(): TryCatchFinallyContext;
    catchClause(): CatchClauseContext;
    finallyStatement(): FinallyStatementContext;
    throwStatement(): ThrowStatementContext;
    gotoStatement(): GotoStatementContext;
    declareStatement(): DeclareStatementContext;
    inlineHtmlStatement(): InlineHtmlStatementContext;
    declareList(): DeclareListContext;
    formalParameterList(): FormalParameterListContext;
    formalParameter(): FormalParameterContext;
    typeHint(_p: any): TypeHintContext;
    globalStatement(): GlobalStatementContext;
    globalVar(): GlobalVarContext;
    echoStatement(): EchoStatementContext;
    staticVariableStatement(): StaticVariableStatementContext;
    classStatement(): ClassStatementContext;
    traitAdaptations(): TraitAdaptationsContext;
    traitAdaptationStatement(): TraitAdaptationStatementContext;
    traitPrecedence(): TraitPrecedenceContext;
    traitAlias(): TraitAliasContext;
    traitMethodReference(): TraitMethodReferenceContext;
    baseCtorCall(): BaseCtorCallContext;
    methodBody(): MethodBodyContext;
    propertyModifiers(): PropertyModifiersContext;
    memberModifiers(): MemberModifiersContext;
    variableInitializer(): VariableInitializerContext;
    identifierInitializer(): IdentifierInitializerContext;
    globalConstantDeclaration(): GlobalConstantDeclarationContext;
    expressionList(): ExpressionListContext;
    parentheses(): ParenthesesContext;
    expression(_p: any): any;
    _ctx: any;
    assignable(): AssignableContext;
    arrayCreation(): ArrayCreationContext;
    lambdaFunctionExpr(): LambdaFunctionExprContext;
    matchExpr(): MatchExprContext;
    matchItem(): MatchItemContext;
    newExpr(): NewExprContext;
    assignmentOperator(): AssignmentOperatorContext;
    yieldExpression(): YieldExpressionContext;
    arrayItemList(): ArrayItemListContext;
    arrayItem(): ArrayItemContext;
    lambdaFunctionUseVars(): LambdaFunctionUseVarsContext;
    lambdaFunctionUseVar(): LambdaFunctionUseVarContext;
    qualifiedStaticTypeRef(): QualifiedStaticTypeRefContext;
    typeRef(): TypeRefContext;
    anonymousClass(): AnonymousClassContext;
    indirectTypeRef(): IndirectTypeRefContext;
    qualifiedNamespaceName(): QualifiedNamespaceNameContext;
    namespaceNameList(): NamespaceNameListContext;
    namespaceNameTail(): NamespaceNameTailContext;
    qualifiedNamespaceNameList(): QualifiedNamespaceNameListContext;
    arguments(): ArgumentsContext;
    actualArgument(): ActualArgumentContext;
    argumentName(): ArgumentNameContext;
    constantInitializer(): ConstantInitializerContext;
    constant(): ConstantContext;
    literalConstant(): LiteralConstantContext;
    numericConstant(): NumericConstantContext;
    classConstant(): ClassConstantContext;
    stringConstant(): StringConstantContext;
    string(): StringContext;
    interpolatedStringPart(): InterpolatedStringPartContext;
    chainList(): ChainListContext;
    chain(): ChainContext;
    chainOrigin(): ChainOriginContext;
    memberAccess(): MemberAccessContext;
    functionCall(): FunctionCallContext;
    functionCallName(): FunctionCallNameContext;
    actualArguments(): ActualArgumentsContext;
    chainBase(): ChainBaseContext;
    keyedFieldName(): KeyedFieldNameContext;
    keyedSimpleFieldName(): KeyedSimpleFieldNameContext;
    keyedVariable(): KeyedVariableContext;
    squareCurlyExpression(): SquareCurlyExpressionContext;
    assignmentList(): AssignmentListContext;
    assignmentListElement(): AssignmentListElementContext;
    modifier(): ModifierContext;
    identifier(): IdentifierContext;
    memberModifier(): MemberModifierContext;
    magicConstant(): MagicConstantContext;
    magicMethod(): MagicMethodContext;
    primitiveType(): PrimitiveTypeContext;
    castOperation(): CastOperationContext;
}
declare namespace PhpParser {
    export const EOF: any;
    export const SeaWhitespace: number;
    export const HtmlText: number;
    export const XmlStart: number;
    export const PHPStart: number;
    export const HtmlScriptOpen: number;
    export const HtmlStyleOpen: number;
    export const HtmlComment: number;
    export const HtmlDtd: number;
    export const HtmlOpen: number;
    export const Shebang: number;
    export const Error: number;
    export const XmlText: number;
    export const XmlClose: number;
    export const PHPStartInside: number;
    export const HtmlClose: number;
    export const HtmlSlashClose: number;
    export const HtmlSlash: number;
    export const HtmlEquals: number;
    export const HtmlStartQuoteString: number;
    export const HtmlStartDoubleQuoteString: number;
    export const HtmlHex: number;
    export const HtmlDecimal: number;
    export const HtmlSpace: number;
    export const HtmlName: number;
    export const ErrorInside: number;
    export const PHPStartInsideQuoteString: number;
    export const HtmlEndQuoteString: number;
    export const HtmlQuoteString: number;
    export const ErrorHtmlQuote: number;
    export const PHPStartDoubleQuoteString: number;
    export const HtmlEndDoubleQuoteString: number;
    export const HtmlDoubleQuoteString: number;
    export const ErrorHtmlDoubleQuote: number;
    export const ScriptText: number;
    export const HtmlScriptClose: number;
    export const PHPStartInsideScript: number;
    export const StyleBody: number;
    export const PHPEnd: number;
    export const Whitespace: number;
    export const MultiLineComment: number;
    export const SingleLineComment: number;
    export const ShellStyleComment: number;
    export const AttributeStart: number;
    export const Abstract: number;
    export const Array: number;
    export const As: number;
    export const BinaryCast: number;
    export const BoolType: number;
    export const BooleanConstant: number;
    export const Break: number;
    export const Callable: number;
    export const Case: number;
    export const Catch: number;
    export const Class: number;
    export const Clone: number;
    export const Const: number;
    export const Continue: number;
    export const Declare: number;
    export const Default: number;
    export const Do: number;
    export const DoubleCast: number;
    export const DoubleType: number;
    export const Echo: number;
    export const Else: number;
    export const ElseIf: number;
    export const Empty: number;
    export const EndDeclare: number;
    export const EndFor: number;
    export const EndForeach: number;
    export const EndIf: number;
    export const EndSwitch: number;
    export const EndWhile: number;
    export const Eval: number;
    export const Exit: number;
    export const Extends: number;
    export const Final: number;
    export const Finally: number;
    export const FloatCast: number;
    export const For: number;
    export const Foreach: number;
    export const Function: number;
    export const Global: number;
    export const Goto: number;
    export const If: number;
    export const Implements: number;
    export const Import: number;
    export const Include: number;
    export const IncludeOnce: number;
    export const InstanceOf: number;
    export const InsteadOf: number;
    export const Int8Cast: number;
    export const Int16Cast: number;
    export const Int64Type: number;
    export const IntType: number;
    export const Interface: number;
    export const IsSet: number;
    export const List: number;
    export const LogicalAnd: number;
    export const LogicalOr: number;
    export const LogicalXor: number;
    export const Match: number;
    export const Namespace: number;
    export const New: number;
    export const Null: number;
    export const ObjectType: number;
    export const Parent_: number;
    export const Partial: number;
    export const Print: number;
    export const Private: number;
    export const Protected: number;
    export const Public: number;
    export const Require: number;
    export const RequireOnce: number;
    export const Resource: number;
    export const Return: number;
    export const Static: number;
    export const StringType: number;
    export const Switch: number;
    export const Throw: number;
    export const Trait: number;
    export const Try: number;
    export const Typeof: number;
    export const UintCast: number;
    export const UnicodeCast: number;
    export const Unset: number;
    export const Use: number;
    export const Var: number;
    export const While: number;
    export const Yield: number;
    export const From: number;
    export const LambdaFn: number;
    export const Get: number;
    export const Set: number;
    export const Call: number;
    export const CallStatic: number;
    export const Constructor: number;
    export const Destruct: number;
    export const Wakeup: number;
    export const Sleep: number;
    export const Autoload: number;
    export const IsSet__: number;
    export const Unset__: number;
    export const ToString__: number;
    export const Invoke: number;
    export const SetState: number;
    export const Clone__: number;
    export const DebugInfo: number;
    export const Namespace__: number;
    export const Class__: number;
    export const Traic__: number;
    export const Function__: number;
    export const Method__: number;
    export const Line__: number;
    export const File__: number;
    export const Dir__: number;
    export const Spaceship: number;
    export const Lgeneric: number;
    export const Rgeneric: number;
    export const DoubleArrow: number;
    export const Inc: number;
    export const Dec: number;
    export const IsIdentical: number;
    export const IsNoidentical: number;
    export const IsEqual: number;
    export const IsNotEq: number;
    export const IsSmallerOrEqual: number;
    export const IsGreaterOrEqual: number;
    export const PlusEqual: number;
    export const MinusEqual: number;
    export const MulEqual: number;
    export const Pow: number;
    export const PowEqual: number;
    export const DivEqual: number;
    export const Concaequal: number;
    export const ModEqual: number;
    export const ShiftLeftEqual: number;
    export const ShiftRightEqual: number;
    export const AndEqual: number;
    export const OrEqual: number;
    export const XorEqual: number;
    export const BooleanOr: number;
    export const BooleanAnd: number;
    export const NullCoalescing: number;
    export const NullCoalescingEqual: number;
    export const ShiftLeft: number;
    export const ShiftRight: number;
    export const DoubleColon: number;
    export const ObjectOperator: number;
    export const NamespaceSeparator: number;
    export const Ellipsis: number;
    export const Less: number;
    export const Greater: number;
    export const Ampersand: number;
    export const Pipe: number;
    export const Bang: number;
    export const Caret: number;
    export const Plus: number;
    export const Minus: number;
    export const Asterisk: number;
    export const Percent: number;
    export const Divide: number;
    export const Tilde: number;
    export const SuppressWarnings: number;
    export const Dollar: number;
    export const Dot: number;
    export const QuestionMark: number;
    export const OpenRoundBracket: number;
    export const CloseRoundBracket: number;
    export const OpenSquareBracket: number;
    export const CloseSquareBracket: number;
    export const OpenCurlyBracket: number;
    export const CloseCurlyBracket: number;
    export const Comma: number;
    export const Colon: number;
    export const SemiColon: number;
    export const Eq: number;
    export const Quote: number;
    export const BackQuote: number;
    export const VarName: number;
    export const Label: number;
    export const Octal: number;
    export const Decimal: number;
    export const Real: number;
    export const Hex: number;
    export const Binary: number;
    export const BackQuoteString: number;
    export const SingleQuoteString: number;
    export const DoubleQuote: number;
    export const StartNowDoc: number;
    export const StartHereDoc: number;
    export const ErrorPhp: number;
    export const CurlyDollar: number;
    export const UnicodeEscape: number;
    export const StringPart: number;
    export const Comment: number;
    export const PHPEndSingleLineComment: number;
    export const CommentEnd: number;
    export const HereDocText: number;
    export const XmlText2: number;
    export const RULE_htmlDocument: number;
    export const RULE_inlineHtml: number;
    export const RULE_htmlElement: number;
    export const RULE_scriptText: number;
    export const RULE_phpBlock: number;
    export const RULE_importStatement: number;
    export const RULE_topStatement: number;
    export const RULE_useDeclaration: number;
    export const RULE_useDeclarationContentList: number;
    export const RULE_useDeclarationContent: number;
    export const RULE_namespaceDeclaration: number;
    export const RULE_namespaceStatement: number;
    export const RULE_functionDeclaration: number;
    export const RULE_classDeclaration: number;
    export const RULE_classEntryType: number;
    export const RULE_interfaceList: number;
    export const RULE_typeParameterListInBrackets: number;
    export const RULE_typeParameterList: number;
    export const RULE_typeParameterWithDefaultsList: number;
    export const RULE_typeParameterDecl: number;
    export const RULE_typeParameterWithDefaultDecl: number;
    export const RULE_genericDynamicArgs: number;
    export const RULE_attributes: number;
    export const RULE_attributeGroup: number;
    export const RULE_attribute: number;
    export const RULE_innerStatementList: number;
    export const RULE_innerStatement: number;
    export const RULE_statement: number;
    export const RULE_emptyStatement: number;
    export const RULE_blockStatement: number;
    export const RULE_ifStatement: number;
    export const RULE_elseIfStatement: number;
    export const RULE_elseIfColonStatement: number;
    export const RULE_elseStatement: number;
    export const RULE_elseColonStatement: number;
    export const RULE_whileStatement: number;
    export const RULE_doWhileStatement: number;
    export const RULE_forStatement: number;
    export const RULE_forInit: number;
    export const RULE_forUpdate: number;
    export const RULE_switchStatement: number;
    export const RULE_switchBlock: number;
    export const RULE_breakStatement: number;
    export const RULE_continueStatement: number;
    export const RULE_returnStatement: number;
    export const RULE_expressionStatement: number;
    export const RULE_unsetStatement: number;
    export const RULE_foreachStatement: number;
    export const RULE_tryCatchFinally: number;
    export const RULE_catchClause: number;
    export const RULE_finallyStatement: number;
    export const RULE_throwStatement: number;
    export const RULE_gotoStatement: number;
    export const RULE_declareStatement: number;
    export const RULE_inlineHtmlStatement: number;
    export const RULE_declareList: number;
    export const RULE_formalParameterList: number;
    export const RULE_formalParameter: number;
    export const RULE_typeHint: number;
    export const RULE_globalStatement: number;
    export const RULE_globalVar: number;
    export const RULE_echoStatement: number;
    export const RULE_staticVariableStatement: number;
    export const RULE_classStatement: number;
    export const RULE_traitAdaptations: number;
    export const RULE_traitAdaptationStatement: number;
    export const RULE_traitPrecedence: number;
    export const RULE_traitAlias: number;
    export const RULE_traitMethodReference: number;
    export const RULE_baseCtorCall: number;
    export const RULE_methodBody: number;
    export const RULE_propertyModifiers: number;
    export const RULE_memberModifiers: number;
    export const RULE_variableInitializer: number;
    export const RULE_identifierInitializer: number;
    export const RULE_globalConstantDeclaration: number;
    export const RULE_expressionList: number;
    export const RULE_parentheses: number;
    export const RULE_expression: number;
    export const RULE_assignable: number;
    export const RULE_arrayCreation: number;
    export const RULE_lambdaFunctionExpr: number;
    export const RULE_matchExpr: number;
    export const RULE_matchItem: number;
    export const RULE_newExpr: number;
    export const RULE_assignmentOperator: number;
    export const RULE_yieldExpression: number;
    export const RULE_arrayItemList: number;
    export const RULE_arrayItem: number;
    export const RULE_lambdaFunctionUseVars: number;
    export const RULE_lambdaFunctionUseVar: number;
    export const RULE_qualifiedStaticTypeRef: number;
    export const RULE_typeRef: number;
    export const RULE_anonymousClass: number;
    export const RULE_indirectTypeRef: number;
    export const RULE_qualifiedNamespaceName: number;
    export const RULE_namespaceNameList: number;
    export const RULE_namespaceNameTail: number;
    export const RULE_qualifiedNamespaceNameList: number;
    export const RULE_arguments: number;
    export const RULE_actualArgument: number;
    export const RULE_argumentName: number;
    export const RULE_constantInitializer: number;
    export const RULE_constant: number;
    export const RULE_literalConstant: number;
    export const RULE_numericConstant: number;
    export const RULE_classConstant: number;
    export const RULE_stringConstant: number;
    export const RULE_string: number;
    export const RULE_interpolatedStringPart: number;
    export const RULE_chainList: number;
    export const RULE_chain: number;
    export const RULE_chainOrigin: number;
    export const RULE_memberAccess: number;
    export const RULE_functionCall: number;
    export const RULE_functionCallName: number;
    export const RULE_actualArguments: number;
    export const RULE_chainBase: number;
    export const RULE_keyedFieldName: number;
    export const RULE_keyedSimpleFieldName: number;
    export const RULE_keyedVariable: number;
    export const RULE_squareCurlyExpression: number;
    export const RULE_assignmentList: number;
    export const RULE_assignmentListElement: number;
    export const RULE_modifier: number;
    export const RULE_identifier: number;
    export const RULE_memberModifier: number;
    export const RULE_magicConstant: number;
    export const RULE_magicMethod: number;
    export const RULE_primitiveType: number;
    export const RULE_castOperation: number;
    export { ChainExpressionContext };
    export { SpecialWordExpressionContext };
    export { ArrayCreationExpressionContext };
    export { BackQuoteStringExpressionContext };
    export { MatchExpressionContext };
    export { LogicalExpressionContext };
    export { PrintExpressionContext };
    export { AssignmentExpressionContext };
    export { PostfixIncDecExpressionContext };
    export { CloneExpressionContext };
    export { UnaryOperatorExpressionContext };
    export { NewExpressionContext };
    export { ParenthesisExpressionContext };
    export { SpaceshipExpressionContext };
    export { ConditionalExpressionContext };
    export { NullCoalescingExpressionContext };
    export { ArithmeticExpressionContext };
    export { IndexerExpressionContext };
    export { ScalarExpressionContext };
    export { PrefixIncDecExpressionContext };
    export { ComparisonExpressionContext };
    export { CastExpressionContext };
    export { InstanceOfExpressionContext };
    export { LambdaFunctionExpressionContext };
    export { BitwiseExpressionContext };
    export { HtmlDocumentContext };
    export { InlineHtmlContext };
    export { HtmlElementContext };
    export { ScriptTextContext };
    export { PhpBlockContext };
    export { ImportStatementContext };
    export { TopStatementContext };
    export { UseDeclarationContext };
    export { UseDeclarationContentListContext };
    export { UseDeclarationContentContext };
    export { NamespaceDeclarationContext };
    export { NamespaceStatementContext };
    export { FunctionDeclarationContext };
    export { ClassDeclarationContext };
    export { ClassEntryTypeContext };
    export { InterfaceListContext };
    export { TypeParameterListInBracketsContext };
    export { TypeParameterListContext };
    export { TypeParameterWithDefaultsListContext };
    export { TypeParameterDeclContext };
    export { TypeParameterWithDefaultDeclContext };
    export { GenericDynamicArgsContext };
    export { AttributesContext };
    export { AttributeGroupContext };
    export { AttributeContext };
    export { InnerStatementListContext };
    export { InnerStatementContext };
    export { StatementContext };
    export { EmptyStatementContext };
    export { BlockStatementContext };
    export { IfStatementContext };
    export { ElseIfStatementContext };
    export { ElseIfColonStatementContext };
    export { ElseStatementContext };
    export { ElseColonStatementContext };
    export { WhileStatementContext };
    export { DoWhileStatementContext };
    export { ForStatementContext };
    export { ForInitContext };
    export { ForUpdateContext };
    export { SwitchStatementContext };
    export { SwitchBlockContext };
    export { BreakStatementContext };
    export { ContinueStatementContext };
    export { ReturnStatementContext };
    export { ExpressionStatementContext };
    export { UnsetStatementContext };
    export { ForeachStatementContext };
    export { TryCatchFinallyContext };
    export { CatchClauseContext };
    export { FinallyStatementContext };
    export { ThrowStatementContext };
    export { GotoStatementContext };
    export { DeclareStatementContext };
    export { InlineHtmlStatementContext };
    export { DeclareListContext };
    export { FormalParameterListContext };
    export { FormalParameterContext };
    export { TypeHintContext };
    export { GlobalStatementContext };
    export { GlobalVarContext };
    export { EchoStatementContext };
    export { StaticVariableStatementContext };
    export { ClassStatementContext };
    export { TraitAdaptationsContext };
    export { TraitAdaptationStatementContext };
    export { TraitPrecedenceContext };
    export { TraitAliasContext };
    export { TraitMethodReferenceContext };
    export { BaseCtorCallContext };
    export { MethodBodyContext };
    export { PropertyModifiersContext };
    export { MemberModifiersContext };
    export { VariableInitializerContext };
    export { IdentifierInitializerContext };
    export { GlobalConstantDeclarationContext };
    export { ExpressionListContext };
    export { ParenthesesContext };
    export { ExpressionContext };
    export { AssignableContext };
    export { ArrayCreationContext };
    export { LambdaFunctionExprContext };
    export { MatchExprContext };
    export { MatchItemContext };
    export { NewExprContext };
    export { AssignmentOperatorContext };
    export { YieldExpressionContext };
    export { ArrayItemListContext };
    export { ArrayItemContext };
    export { LambdaFunctionUseVarsContext };
    export { LambdaFunctionUseVarContext };
    export { QualifiedStaticTypeRefContext };
    export { TypeRefContext };
    export { AnonymousClassContext };
    export { IndirectTypeRefContext };
    export { QualifiedNamespaceNameContext };
    export { NamespaceNameListContext };
    export { NamespaceNameTailContext };
    export { QualifiedNamespaceNameListContext };
    export { ArgumentsContext };
    export { ActualArgumentContext };
    export { ArgumentNameContext };
    export { ConstantInitializerContext };
    export { ConstantContext };
    export { LiteralConstantContext };
    export { NumericConstantContext };
    export { ClassConstantContext };
    export { StringConstantContext };
    export { StringContext };
    export { InterpolatedStringPartContext };
    export { ChainListContext };
    export { ChainContext };
    export { ChainOriginContext };
    export { MemberAccessContext };
    export { FunctionCallContext };
    export { FunctionCallNameContext };
    export { ActualArgumentsContext };
    export { ChainBaseContext };
    export { KeyedFieldNameContext };
    export { KeyedSimpleFieldNameContext };
    export { KeyedVariableContext };
    export { SquareCurlyExpressionContext };
    export { AssignmentListContext };
    export { AssignmentListElementContext };
    export { ModifierContext };
    export { IdentifierContext };
    export { MemberModifierContext };
    export { MagicConstantContext };
    export { MagicMethodContext };
    export { PrimitiveTypeContext };
    export { CastOperationContext };
}
export default PhpParser;
declare class HtmlDocumentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EOF(): any;
    Shebang(): any;
    inlineHtml: (i: any) => any;
    phpBlock: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InlineHtmlContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    htmlElement: (i: any) => any;
    scriptText(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class HtmlElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    HtmlDtd(): any;
    HtmlClose(): any;
    HtmlStyleOpen(): any;
    HtmlOpen(): any;
    HtmlName(): any;
    HtmlSlashClose(): any;
    HtmlSlash(): any;
    HtmlText(): any;
    HtmlEquals(): any;
    HtmlStartQuoteString(): any;
    HtmlEndQuoteString(): any;
    HtmlStartDoubleQuoteString(): any;
    HtmlEndDoubleQuoteString(): any;
    HtmlHex(): any;
    HtmlDecimal(): any;
    HtmlQuoteString(): any;
    HtmlDoubleQuoteString(): any;
    StyleBody(): any;
    HtmlScriptOpen(): any;
    HtmlScriptClose(): any;
    XmlStart(): any;
    XmlClose(): any;
    XmlText: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ScriptTextContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ScriptText: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PhpBlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    importStatement: (i: any) => any;
    topStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImportStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Import(): any;
    Namespace(): any;
    namespaceNameList(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TopStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    statement(): any;
    useDeclaration(): any;
    namespaceDeclaration(): any;
    functionDeclaration(): any;
    classDeclaration(): any;
    globalConstantDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UseDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Use(): any;
    useDeclarationContentList(): any;
    SemiColon(): any;
    Function(): any;
    Const(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UseDeclarationContentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    useDeclarationContent: (i: any) => any;
    NamespaceSeparator: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UseDeclarationContentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    namespaceNameList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamespaceDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Namespace(): any;
    OpenCurlyBracket(): any;
    CloseCurlyBracket(): any;
    namespaceNameList(): any;
    SemiColon(): any;
    namespaceStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamespaceStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    statement(): any;
    useDeclaration(): any;
    functionDeclaration(): any;
    classDeclaration(): any;
    globalConstantDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FunctionDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Function(): any;
    identifier(): any;
    OpenRoundBracket(): any;
    formalParameterList(): any;
    CloseRoundBracket(): any;
    blockStatement(): any;
    attributes(): any;
    Ampersand(): any;
    typeParameterListInBrackets(): any;
    Colon(): any;
    typeHint(): any;
    QuestionMark(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OpenCurlyBracket(): any;
    CloseCurlyBracket(): any;
    classEntryType(): any;
    identifier(): any;
    Interface(): any;
    attributes(): any;
    Private(): any;
    modifier(): any;
    Partial(): any;
    classStatement: (i: any) => any;
    typeParameterListInBrackets(): any;
    Extends(): any;
    qualifiedStaticTypeRef(): any;
    Implements(): any;
    interfaceList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassEntryTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Class(): any;
    Trait(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedStaticTypeRef: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterListInBracketsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Lgeneric(): any;
    typeParameterList(): any;
    Rgeneric(): any;
    typeParameterWithDefaultsList(): any;
    Comma(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeParameterDecl: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterWithDefaultsListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeParameterWithDefaultDecl: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterDeclContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    attributes(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterWithDefaultDeclContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    Eq(): any;
    qualifiedStaticTypeRef(): any;
    primitiveType(): any;
    attributes(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GenericDynamicArgsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Lgeneric(): any;
    typeRef: (i: any) => any;
    Rgeneric(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    attributeGroup: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeGroupContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AttributeStart(): any;
    attribute: (i: any) => any;
    CloseSquareBracket(): any;
    identifier(): any;
    Colon(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedNamespaceName(): any;
    arguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InnerStatementListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    innerStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InnerStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    statement(): any;
    functionDeclaration(): any;
    classDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    Colon(): any;
    blockStatement(): any;
    ifStatement(): any;
    whileStatement(): any;
    doWhileStatement(): any;
    forStatement(): any;
    switchStatement(): any;
    breakStatement(): any;
    continueStatement(): any;
    returnStatement(): any;
    yieldExpression(): any;
    SemiColon(): any;
    globalStatement(): any;
    staticVariableStatement(): any;
    echoStatement(): any;
    expressionStatement(): any;
    unsetStatement(): any;
    foreachStatement(): any;
    tryCatchFinally(): any;
    throwStatement(): any;
    gotoStatement(): any;
    declareStatement(): any;
    emptyStatement(): any;
    inlineHtmlStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EmptyStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BlockStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OpenCurlyBracket(): any;
    innerStatementList(): any;
    CloseCurlyBracket(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IfStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    If(): any;
    parentheses(): any;
    statement(): any;
    elseIfStatement: (i: any) => any;
    elseStatement(): any;
    Colon(): any;
    innerStatementList(): any;
    EndIf(): any;
    SemiColon(): any;
    elseIfColonStatement: (i: any) => any;
    elseColonStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ElseIfStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ElseIf(): any;
    parentheses(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ElseIfColonStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ElseIf(): any;
    parentheses(): any;
    Colon(): any;
    innerStatementList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ElseStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Else(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ElseColonStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Else(): any;
    Colon(): any;
    innerStatementList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WhileStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    While(): any;
    parentheses(): any;
    statement(): any;
    Colon(): any;
    innerStatementList(): any;
    EndWhile(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DoWhileStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Do(): any;
    statement(): any;
    While(): any;
    parentheses(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    For(): any;
    OpenRoundBracket(): any;
    SemiColon: (i: any) => any;
    CloseRoundBracket(): any;
    statement(): any;
    Colon(): any;
    innerStatementList(): any;
    EndFor(): any;
    forInit(): any;
    expressionList(): any;
    forUpdate(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForInitContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expressionList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForUpdateContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expressionList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SwitchStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Switch(): any;
    parentheses(): any;
    OpenCurlyBracket(): any;
    CloseCurlyBracket(): any;
    Colon(): any;
    EndSwitch(): any;
    SemiColon: (i: any) => any;
    switchBlock: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SwitchBlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    innerStatementList(): any;
    Colon: (i: any) => any;
    SemiColon: (i: any) => any;
    Case: (i: any) => any;
    expression: (i: any) => any;
    Default: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BreakStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Break(): any;
    SemiColon(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ContinueStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Continue(): any;
    SemiColon(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ReturnStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Return(): any;
    SemiColon(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UnsetStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Unset(): any;
    OpenRoundBracket(): any;
    chainList(): any;
    CloseRoundBracket(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForeachStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Foreach(): any;
    OpenRoundBracket: (i: any) => any;
    chain: (i: any) => any;
    As(): any;
    assignable(): any;
    CloseRoundBracket: (i: any) => any;
    expression(): any;
    List(): any;
    assignmentList(): any;
    statement(): any;
    Colon(): any;
    innerStatementList(): any;
    EndForeach(): any;
    SemiColon(): any;
    Ampersand: (i: any) => any;
    DoubleArrow(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TryCatchFinallyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Try(): any;
    blockStatement(): any;
    finallyStatement(): any;
    catchClause: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CatchClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Catch(): any;
    OpenRoundBracket(): any;
    qualifiedStaticTypeRef: (i: any) => any;
    VarName(): any;
    CloseRoundBracket(): any;
    blockStatement(): any;
    Pipe: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FinallyStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Finally(): any;
    blockStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ThrowStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Throw(): any;
    expression(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GotoStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Goto(): any;
    identifier(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DeclareStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Declare(): any;
    OpenRoundBracket(): any;
    declareList(): any;
    CloseRoundBracket(): any;
    statement(): any;
    Colon(): any;
    innerStatementList(): any;
    EndDeclare(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InlineHtmlStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    inlineHtml: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DeclareListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifierInitializer: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FormalParameterListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    formalParameter: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FormalParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variableInitializer(): any;
    attributes(): any;
    memberModifier(): any;
    QuestionMark(): any;
    typeHint(): any;
    Ampersand(): any;
    Ellipsis(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeHintContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedStaticTypeRef(): any;
    Callable(): any;
    primitiveType(): any;
    typeHint: (i: any) => any;
    Pipe(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GlobalStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Global(): any;
    globalVar: (i: any) => any;
    SemiColon(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GlobalVarContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    VarName(): any;
    Dollar(): any;
    chain(): any;
    OpenCurlyBracket(): any;
    expression(): any;
    CloseCurlyBracket(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EchoStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Echo(): any;
    expressionList(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StaticVariableStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Static(): any;
    variableInitializer: (i: any) => any;
    SemiColon(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    propertyModifiers(): any;
    variableInitializer: (i: any) => any;
    SemiColon(): any;
    attributes(): any;
    Const(): any;
    identifierInitializer: (i: any) => any;
    Function(): any;
    identifier(): any;
    OpenRoundBracket(): any;
    formalParameterList(): any;
    CloseRoundBracket(): any;
    methodBody(): any;
    typeHint(): any;
    Comma: (i: any) => any;
    memberModifiers(): any;
    Ampersand(): any;
    typeParameterListInBrackets(): any;
    baseCtorCall(): any;
    Use(): any;
    qualifiedNamespaceNameList(): any;
    traitAdaptations(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TraitAdaptationsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SemiColon(): any;
    OpenCurlyBracket(): any;
    CloseCurlyBracket(): any;
    traitAdaptationStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TraitAdaptationStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    traitPrecedence(): any;
    traitAlias(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TraitPrecedenceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedNamespaceName(): any;
    DoubleColon(): any;
    identifier(): any;
    InsteadOf(): any;
    qualifiedNamespaceNameList(): any;
    SemiColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TraitAliasContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    traitMethodReference(): any;
    As(): any;
    SemiColon(): any;
    memberModifier(): any;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TraitMethodReferenceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    qualifiedNamespaceName(): any;
    DoubleColon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BaseCtorCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Colon(): any;
    identifier(): any;
    arguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MethodBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SemiColon(): any;
    blockStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertyModifiersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    memberModifiers(): any;
    Var(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MemberModifiersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    memberModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    VarName(): any;
    Eq(): any;
    constantInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    Eq(): any;
    constantInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GlobalConstantDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Const(): any;
    identifierInitializer: (i: any) => any;
    SemiColon(): any;
    attributes(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParenthesesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OpenRoundBracket(): any;
    CloseRoundBracket(): any;
    expression(): any;
    yieldExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AssignableContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    chain(): any;
    arrayCreation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayCreationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Array(): any;
    OpenRoundBracket(): any;
    CloseRoundBracket(): any;
    OpenSquareBracket: (i: any) => any;
    CloseSquareBracket: (i: any) => any;
    expression(): any;
    arrayItemList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LambdaFunctionExprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Function(): any;
    OpenRoundBracket(): any;
    formalParameterList(): any;
    CloseRoundBracket(): any;
    blockStatement(): any;
    Static(): any;
    Ampersand(): any;
    lambdaFunctionUseVars(): any;
    Colon(): any;
    typeHint(): any;
    LambdaFn(): any;
    DoubleArrow(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MatchExprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Match(): any;
    OpenRoundBracket(): any;
    expression(): any;
    CloseRoundBracket(): any;
    OpenCurlyBracket(): any;
    matchItem: (i: any) => any;
    CloseCurlyBracket(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MatchItemContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    DoubleArrow(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NewExprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    New(): any;
    typeRef(): any;
    arguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AssignmentOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Eq(): any;
    PlusEqual(): any;
    MinusEqual(): any;
    MulEqual(): any;
    PowEqual(): any;
    DivEqual(): any;
    Concaequal(): any;
    ModEqual(): any;
    AndEqual(): any;
    OrEqual(): any;
    XorEqual(): any;
    ShiftLeftEqual(): any;
    ShiftRightEqual(): any;
    NullCoalescingEqual(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class YieldExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Yield(): any;
    expression: (i: any) => any;
    From(): any;
    DoubleArrow(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayItemListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    arrayItem: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayItemContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    DoubleArrow(): any;
    Ampersand(): any;
    chain(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LambdaFunctionUseVarsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Use(): any;
    OpenRoundBracket(): any;
    lambdaFunctionUseVar: (i: any) => any;
    CloseRoundBracket(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LambdaFunctionUseVarContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    VarName(): any;
    Ampersand(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QualifiedStaticTypeRefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedNamespaceName(): any;
    genericDynamicArgs(): any;
    Static(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeRefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedNamespaceName(): any;
    indirectTypeRef(): any;
    genericDynamicArgs(): any;
    primitiveType(): any;
    Static(): any;
    anonymousClass(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AnonymousClassContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OpenCurlyBracket(): any;
    CloseCurlyBracket(): any;
    classEntryType(): any;
    Interface(): any;
    identifier(): any;
    attributes(): any;
    Private(): any;
    modifier(): any;
    Partial(): any;
    classStatement: (i: any) => any;
    typeParameterListInBrackets(): any;
    Extends(): any;
    qualifiedStaticTypeRef(): any;
    Implements(): any;
    interfaceList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IndirectTypeRefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    chainBase(): any;
    ObjectOperator: (i: any) => any;
    keyedFieldName: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QualifiedNamespaceNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    namespaceNameList(): any;
    Namespace(): any;
    NamespaceSeparator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamespaceNameListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier: (i: any) => any;
    NamespaceSeparator: (i: any) => any;
    namespaceNameTail(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamespaceNameTailContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier: (i: any) => any;
    As(): any;
    OpenCurlyBracket(): any;
    namespaceNameTail: (i: any) => any;
    CloseCurlyBracket(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QualifiedNamespaceNameListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedNamespaceName: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgumentsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OpenRoundBracket(): any;
    CloseRoundBracket(): any;
    actualArgument: (i: any) => any;
    yieldExpression(): any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ActualArgumentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    argumentName(): any;
    Ellipsis(): any;
    Ampersand(): any;
    chain(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgumentNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    Colon(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstantInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constant(): any;
    string(): any;
    Array(): any;
    OpenRoundBracket(): any;
    CloseRoundBracket(): any;
    arrayItemList(): any;
    Comma(): any;
    OpenSquareBracket(): any;
    CloseSquareBracket(): any;
    constantInitializer(): any;
    Plus(): any;
    Minus(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Null(): any;
    literalConstant(): any;
    magicConstant(): any;
    classConstant(): any;
    qualifiedNamespaceName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LiteralConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Real(): any;
    BooleanConstant(): any;
    numericConstant(): any;
    stringConstant(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NumericConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Octal(): any;
    Decimal(): any;
    Hex(): any;
    Binary(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DoubleColon(): any;
    Class(): any;
    Parent_(): any;
    identifier(): any;
    Constructor(): any;
    Get(): any;
    Set(): any;
    qualifiedStaticTypeRef(): any;
    keyedVariable: (i: any) => any;
    string(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StringConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Label(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StringContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    StartHereDoc(): any;
    HereDocText: (i: any) => any;
    StartNowDoc(): any;
    SingleQuoteString(): any;
    DoubleQuote: (i: any) => any;
    interpolatedStringPart: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterpolatedStringPartContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    StringPart(): any;
    UnicodeEscape(): any;
    chain(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ChainListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    chain: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ChainContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    chainOrigin(): any;
    memberAccess: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ChainOriginContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    chainBase(): any;
    functionCall(): any;
    OpenRoundBracket(): any;
    newExpr(): any;
    CloseRoundBracket(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MemberAccessContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ObjectOperator(): any;
    keyedFieldName(): any;
    actualArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FunctionCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    functionCallName(): any;
    actualArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FunctionCallNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedNamespaceName(): any;
    classConstant(): any;
    chainBase(): any;
    parentheses(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ActualArgumentsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    arguments(): any;
    genericDynamicArgs(): any;
    squareCurlyExpression: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ChainBaseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    keyedVariable: (i: any) => any;
    DoubleColon(): any;
    qualifiedStaticTypeRef(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class KeyedFieldNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    keyedSimpleFieldName(): any;
    keyedVariable(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class KeyedSimpleFieldNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    OpenCurlyBracket(): any;
    expression(): any;
    CloseCurlyBracket(): any;
    squareCurlyExpression: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class KeyedVariableContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    VarName(): any;
    Dollar: (i: any) => any;
    OpenCurlyBracket(): any;
    expression(): any;
    CloseCurlyBracket(): any;
    squareCurlyExpression: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SquareCurlyExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OpenSquareBracket(): any;
    CloseSquareBracket(): any;
    expression(): any;
    OpenCurlyBracket(): any;
    CloseCurlyBracket(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AssignmentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    assignmentListElement: (i: any) => any;
    Comma: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AssignmentListElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    chain(): any;
    List(): any;
    OpenRoundBracket(): any;
    assignmentList(): any;
    CloseRoundBracket(): any;
    arrayItem(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Abstract(): any;
    Final(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Label(): any;
    Abstract(): any;
    Array(): any;
    As(): any;
    BinaryCast(): any;
    BoolType(): any;
    BooleanConstant(): any;
    Break(): any;
    Callable(): any;
    Case(): any;
    Catch(): any;
    Class(): any;
    Clone(): any;
    Const(): any;
    Continue(): any;
    Declare(): any;
    Default(): any;
    Do(): any;
    DoubleCast(): any;
    DoubleType(): any;
    Echo(): any;
    Else(): any;
    ElseIf(): any;
    Empty(): any;
    EndDeclare(): any;
    EndFor(): any;
    EndForeach(): any;
    EndIf(): any;
    EndSwitch(): any;
    EndWhile(): any;
    Eval(): any;
    Exit(): any;
    Extends(): any;
    Final(): any;
    Finally(): any;
    FloatCast(): any;
    For(): any;
    Foreach(): any;
    Function(): any;
    Global(): any;
    Goto(): any;
    If(): any;
    Implements(): any;
    Import(): any;
    Include(): any;
    IncludeOnce(): any;
    InstanceOf(): any;
    InsteadOf(): any;
    Int16Cast(): any;
    Int64Type(): any;
    Int8Cast(): any;
    Interface(): any;
    IntType(): any;
    IsSet(): any;
    List(): any;
    LogicalAnd(): any;
    LogicalOr(): any;
    LogicalXor(): any;
    Namespace(): any;
    New(): any;
    Null(): any;
    ObjectType(): any;
    Parent_(): any;
    Partial(): any;
    Print(): any;
    Private(): any;
    Protected(): any;
    Public(): any;
    Require(): any;
    RequireOnce(): any;
    Resource(): any;
    Return(): any;
    Static(): any;
    StringType(): any;
    Switch(): any;
    Throw(): any;
    Trait(): any;
    Try(): any;
    Typeof(): any;
    UintCast(): any;
    UnicodeCast(): any;
    Unset(): any;
    Use(): any;
    Var(): any;
    While(): any;
    Yield(): any;
    From(): any;
    Get(): any;
    Set(): any;
    Call(): any;
    CallStatic(): any;
    Constructor(): any;
    Destruct(): any;
    Wakeup(): any;
    Sleep(): any;
    Autoload(): any;
    IsSet__(): any;
    Unset__(): any;
    ToString__(): any;
    Invoke(): any;
    SetState(): any;
    Clone__(): any;
    DebugInfo(): any;
    Namespace__(): any;
    Class__(): any;
    Traic__(): any;
    Function__(): any;
    Method__(): any;
    Line__(): any;
    File__(): any;
    Dir__(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MemberModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Public(): any;
    Protected(): any;
    Private(): any;
    Static(): any;
    Abstract(): any;
    Final(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MagicConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Namespace__(): any;
    Class__(): any;
    Traic__(): any;
    Function__(): any;
    Method__(): any;
    Line__(): any;
    File__(): any;
    Dir__(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MagicMethodContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    Get(): any;
    Set(): any;
    Call(): any;
    CallStatic(): any;
    Constructor(): any;
    Destruct(): any;
    Wakeup(): any;
    Sleep(): any;
    Autoload(): any;
    IsSet__(): any;
    Unset__(): any;
    ToString__(): any;
    Invoke(): any;
    SetState(): any;
    Clone__(): any;
    DebugInfo(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PrimitiveTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BoolType(): any;
    IntType(): any;
    Int64Type(): any;
    DoubleType(): any;
    StringType(): any;
    Resource(): any;
    ObjectType(): any;
    Array(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CastOperationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BoolType(): any;
    Int8Cast(): any;
    Int16Cast(): any;
    IntType(): any;
    Int64Type(): any;
    UintCast(): any;
    DoubleCast(): any;
    DoubleType(): any;
    FloatCast(): any;
    StringType(): any;
    BinaryCast(): any;
    UnicodeCast(): any;
    Array(): any;
    ObjectType(): any;
    Resource(): any;
    Unset(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ChainExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    chain(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SpecialWordExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    Yield(): any;
    List(): any;
    OpenRoundBracket(): any;
    assignmentList(): any;
    CloseRoundBracket(): any;
    Eq(): any;
    expression(): any;
    IsSet(): any;
    chainList(): any;
    Empty(): any;
    chain(): any;
    Eval(): any;
    Exit(): any;
    parentheses(): any;
    Include(): any;
    IncludeOnce(): any;
    Require(): any;
    RequireOnce(): any;
    Throw(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayCreationExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    arrayCreation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BackQuoteStringExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    BackQuoteString(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MatchExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    matchExpr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LogicalExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    op: any;
    expression: (i: any) => any;
    LogicalAnd(): any;
    LogicalXor(): any;
    LogicalOr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PrintExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    Print(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AssignmentExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    assignable(): any;
    assignmentOperator(): any;
    expression(): any;
    attributes(): any;
    Eq(): any;
    Ampersand(): any;
    chain(): any;
    newExpr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PostfixIncDecExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    chain(): any;
    Inc(): any;
    Dec(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CloneExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    Clone(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UnaryOperatorExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    expression(): any;
    Tilde(): any;
    SuppressWarnings(): any;
    Bang(): any;
    Plus(): any;
    Minus(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NewExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    newExpr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParenthesisExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    parentheses(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SpaceshipExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    op: any;
    expression: (i: any) => any;
    Spaceship(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConditionalExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    op: any;
    expression: (i: any) => any;
    Colon(): any;
    QuestionMark(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NullCoalescingExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    op: any;
    expression: (i: any) => any;
    NullCoalescing(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArithmeticExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    op: any;
    expression: (i: any) => any;
    Pow(): any;
    Asterisk(): any;
    Divide(): any;
    Percent(): any;
    Plus(): any;
    Minus(): any;
    Dot(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IndexerExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    stringConstant(): any;
    OpenSquareBracket(): any;
    expression(): any;
    CloseSquareBracket(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ScalarExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    constant(): any;
    string(): any;
    Label(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PrefixIncDecExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    chain(): any;
    Inc(): any;
    Dec(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ComparisonExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    op: any;
    expression: (i: any) => any;
    ShiftLeft(): any;
    ShiftRight(): any;
    Less(): any;
    IsSmallerOrEqual(): any;
    Greater(): any;
    IsGreaterOrEqual(): any;
    IsIdentical(): any;
    IsNoidentical(): any;
    IsEqual(): any;
    IsNotEq(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CastExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    OpenRoundBracket(): any;
    castOperation(): any;
    CloseRoundBracket(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceOfExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    expression(): any;
    InstanceOf(): any;
    typeRef(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LambdaFunctionExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    lambdaFunctionExpr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BitwiseExpressionContext extends ExpressionContext {
    constructor(parser: any, ctx: any);
    op: any;
    expression: (i: any) => any;
    Ampersand(): any;
    Caret(): any;
    Pipe(): any;
    BooleanAnd(): any;
    BooleanOr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    copyFrom(ctx: any): void;
}
//# sourceMappingURL=PhpParser.d.ts.map
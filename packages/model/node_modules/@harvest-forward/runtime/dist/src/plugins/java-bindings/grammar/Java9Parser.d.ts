export function Java9Parser(input: any): this;
export class Java9Parser {
    constructor(input: any);
    _interp: any;
    ruleNames: string[];
    literalNames: (string | null)[];
    symbolicNames: (string | null)[];
    constructor: typeof Java9Parser;
    get atn(): any;
    literal(): LiteralContext;
    state: number | undefined;
    primitiveType(): PrimitiveTypeContext;
    numericType(): NumericTypeContext;
    integralType(): IntegralTypeContext;
    floatingPointType(): FloatingPointTypeContext;
    referenceType(): ReferenceTypeContext;
    classOrInterfaceType(): ClassOrInterfaceTypeContext;
    classType(): ClassTypeContext;
    classType_lf_classOrInterfaceType(): ClassType_lf_classOrInterfaceTypeContext;
    classType_lfno_classOrInterfaceType(): ClassType_lfno_classOrInterfaceTypeContext;
    interfaceType(): InterfaceTypeContext;
    interfaceType_lf_classOrInterfaceType(): InterfaceType_lf_classOrInterfaceTypeContext;
    interfaceType_lfno_classOrInterfaceType(): InterfaceType_lfno_classOrInterfaceTypeContext;
    typeVariable(): TypeVariableContext;
    arrayType(): ArrayTypeContext;
    dims(): DimsContext;
    typeParameter(): TypeParameterContext;
    typeParameterModifier(): TypeParameterModifierContext;
    typeBound(): TypeBoundContext;
    additionalBound(): AdditionalBoundContext;
    typeArguments(): TypeArgumentsContext;
    typeArgumentList(): TypeArgumentListContext;
    typeArgument(): TypeArgumentContext;
    wildcard(): WildcardContext;
    wildcardBounds(): WildcardBoundsContext;
    moduleName(_p: any): ModuleNameContext;
    packageName(_p: any): PackageNameContext;
    typeName(): TypeNameContext;
    packageOrTypeName(_p: any): PackageOrTypeNameContext;
    expressionName(): ExpressionNameContext;
    methodName(): MethodNameContext;
    ambiguousName(_p: any): AmbiguousNameContext;
    compilationUnit(): CompilationUnitContext;
    ordinaryCompilation(): OrdinaryCompilationContext;
    modularCompilation(): ModularCompilationContext;
    packageDeclaration(): PackageDeclarationContext;
    packageModifier(): PackageModifierContext;
    importDeclaration(): ImportDeclarationContext;
    singleTypeImportDeclaration(): SingleTypeImportDeclarationContext;
    typeImportOnDemandDeclaration(): TypeImportOnDemandDeclarationContext;
    singleStaticImportDeclaration(): SingleStaticImportDeclarationContext;
    staticImportOnDemandDeclaration(): StaticImportOnDemandDeclarationContext;
    typeDeclaration(): TypeDeclarationContext;
    moduleDeclaration(): ModuleDeclarationContext;
    moduleDirective(): ModuleDirectiveContext;
    requiresModifier(): RequiresModifierContext;
    classDeclaration(): ClassDeclarationContext;
    normalClassDeclaration(): NormalClassDeclarationContext;
    classModifier(): ClassModifierContext;
    typeParameters(): TypeParametersContext;
    typeParameterList(): TypeParameterListContext;
    superclass(): SuperclassContext;
    superinterfaces(): SuperinterfacesContext;
    interfaceTypeList(): InterfaceTypeListContext;
    classBody(): ClassBodyContext;
    classBodyDeclaration(): ClassBodyDeclarationContext;
    classMemberDeclaration(): ClassMemberDeclarationContext;
    fieldDeclaration(): FieldDeclarationContext;
    fieldModifier(): FieldModifierContext;
    variableDeclaratorList(): VariableDeclaratorListContext;
    variableDeclarator(): VariableDeclaratorContext;
    variableDeclaratorId(): VariableDeclaratorIdContext;
    variableInitializer(): VariableInitializerContext;
    unannType(): UnannTypeContext;
    unannPrimitiveType(): UnannPrimitiveTypeContext;
    unannReferenceType(): UnannReferenceTypeContext;
    unannClassOrInterfaceType(): UnannClassOrInterfaceTypeContext;
    unannClassType(): UnannClassTypeContext;
    unannClassType_lf_unannClassOrInterfaceType(): UnannClassType_lf_unannClassOrInterfaceTypeContext;
    unannClassType_lfno_unannClassOrInterfaceType(): UnannClassType_lfno_unannClassOrInterfaceTypeContext;
    unannInterfaceType(): UnannInterfaceTypeContext;
    unannInterfaceType_lf_unannClassOrInterfaceType(): UnannInterfaceType_lf_unannClassOrInterfaceTypeContext;
    unannInterfaceType_lfno_unannClassOrInterfaceType(): UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext;
    unannTypeVariable(): UnannTypeVariableContext;
    unannArrayType(): UnannArrayTypeContext;
    methodDeclaration(): MethodDeclarationContext;
    methodModifier(): MethodModifierContext;
    methodHeader(): MethodHeaderContext;
    result(): ResultContext;
    methodDeclarator(): MethodDeclaratorContext;
    formalParameterList(): FormalParameterListContext;
    formalParameters(): FormalParametersContext;
    formalParameter(): FormalParameterContext;
    variableModifier(): VariableModifierContext;
    lastFormalParameter(): LastFormalParameterContext;
    receiverParameter(): ReceiverParameterContext;
    throws_(): Throws_Context;
    exceptionTypeList(): ExceptionTypeListContext;
    exceptionType(): ExceptionTypeContext;
    methodBody(): MethodBodyContext;
    instanceInitializer(): InstanceInitializerContext;
    staticInitializer(): StaticInitializerContext;
    constructorDeclaration(): ConstructorDeclarationContext;
    constructorModifier(): ConstructorModifierContext;
    constructorDeclarator(): ConstructorDeclaratorContext;
    simpleTypeName(): SimpleTypeNameContext;
    constructorBody(): ConstructorBodyContext;
    explicitConstructorInvocation(): ExplicitConstructorInvocationContext;
    enumDeclaration(): EnumDeclarationContext;
    enumBody(): EnumBodyContext;
    enumConstantList(): EnumConstantListContext;
    enumConstant(): EnumConstantContext;
    enumConstantModifier(): EnumConstantModifierContext;
    enumBodyDeclarations(): EnumBodyDeclarationsContext;
    interfaceDeclaration(): InterfaceDeclarationContext;
    normalInterfaceDeclaration(): NormalInterfaceDeclarationContext;
    interfaceModifier(): InterfaceModifierContext;
    extendsInterfaces(): ExtendsInterfacesContext;
    interfaceBody(): InterfaceBodyContext;
    interfaceMemberDeclaration(): InterfaceMemberDeclarationContext;
    constantDeclaration(): ConstantDeclarationContext;
    constantModifier(): ConstantModifierContext;
    interfaceMethodDeclaration(): InterfaceMethodDeclarationContext;
    interfaceMethodModifier(): InterfaceMethodModifierContext;
    annotationTypeDeclaration(): AnnotationTypeDeclarationContext;
    annotationTypeBody(): AnnotationTypeBodyContext;
    annotationTypeMemberDeclaration(): AnnotationTypeMemberDeclarationContext;
    annotationTypeElementDeclaration(): AnnotationTypeElementDeclarationContext;
    annotationTypeElementModifier(): AnnotationTypeElementModifierContext;
    defaultValue(): DefaultValueContext;
    annotation(): AnnotationContext;
    normalAnnotation(): NormalAnnotationContext;
    elementValuePairList(): ElementValuePairListContext;
    elementValuePair(): ElementValuePairContext;
    elementValue(): ElementValueContext;
    elementValueArrayInitializer(): ElementValueArrayInitializerContext;
    elementValueList(): ElementValueListContext;
    markerAnnotation(): MarkerAnnotationContext;
    singleElementAnnotation(): SingleElementAnnotationContext;
    arrayInitializer(): ArrayInitializerContext;
    variableInitializerList(): VariableInitializerListContext;
    block(): BlockContext;
    blockStatements(): BlockStatementsContext;
    blockStatement(): BlockStatementContext;
    localVariableDeclarationStatement(): LocalVariableDeclarationStatementContext;
    localVariableDeclaration(): LocalVariableDeclarationContext;
    statement(): StatementContext;
    statementNoShortIf(): StatementNoShortIfContext;
    statementWithoutTrailingSubstatement(): StatementWithoutTrailingSubstatementContext;
    emptyStatement(): EmptyStatementContext;
    labeledStatement(): LabeledStatementContext;
    labeledStatementNoShortIf(): LabeledStatementNoShortIfContext;
    expressionStatement(): ExpressionStatementContext;
    statementExpression(): StatementExpressionContext;
    ifThenStatement(): IfThenStatementContext;
    ifThenElseStatement(): IfThenElseStatementContext;
    ifThenElseStatementNoShortIf(): IfThenElseStatementNoShortIfContext;
    assertStatement(): AssertStatementContext;
    switchStatement(): SwitchStatementContext;
    switchBlock(): SwitchBlockContext;
    switchBlockStatementGroup(): SwitchBlockStatementGroupContext;
    switchLabels(): SwitchLabelsContext;
    switchLabel(): SwitchLabelContext;
    enumConstantName(): EnumConstantNameContext;
    whileStatement(): WhileStatementContext;
    whileStatementNoShortIf(): WhileStatementNoShortIfContext;
    doStatement(): DoStatementContext;
    forStatement(): ForStatementContext;
    forStatementNoShortIf(): ForStatementNoShortIfContext;
    basicForStatement(): BasicForStatementContext;
    basicForStatementNoShortIf(): BasicForStatementNoShortIfContext;
    forInit(): ForInitContext;
    forUpdate(): ForUpdateContext;
    statementExpressionList(): StatementExpressionListContext;
    enhancedForStatement(): EnhancedForStatementContext;
    enhancedForStatementNoShortIf(): EnhancedForStatementNoShortIfContext;
    breakStatement(): BreakStatementContext;
    continueStatement(): ContinueStatementContext;
    returnStatement(): ReturnStatementContext;
    throwStatement(): ThrowStatementContext;
    synchronizedStatement(): SynchronizedStatementContext;
    tryStatement(): TryStatementContext;
    catches(): CatchesContext;
    catchClause(): CatchClauseContext;
    catchFormalParameter(): CatchFormalParameterContext;
    catchType(): CatchTypeContext;
    finally_(): Finally_Context;
    tryWithResourcesStatement(): TryWithResourcesStatementContext;
    resourceSpecification(): ResourceSpecificationContext;
    resourceList(): ResourceListContext;
    resource(): ResourceContext;
    variableAccess(): VariableAccessContext;
    primary(): PrimaryContext;
    primaryNoNewArray(): PrimaryNoNewArrayContext;
    primaryNoNewArray_lf_arrayAccess(): PrimaryNoNewArray_lf_arrayAccessContext;
    primaryNoNewArray_lfno_arrayAccess(): PrimaryNoNewArray_lfno_arrayAccessContext;
    primaryNoNewArray_lf_primary(): PrimaryNoNewArray_lf_primaryContext;
    primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(): PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext;
    primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(): PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext;
    primaryNoNewArray_lfno_primary(): PrimaryNoNewArray_lfno_primaryContext;
    primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(): PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext;
    primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(): PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext;
    classLiteral(): ClassLiteralContext;
    classInstanceCreationExpression(): ClassInstanceCreationExpressionContext;
    classInstanceCreationExpression_lf_primary(): ClassInstanceCreationExpression_lf_primaryContext;
    classInstanceCreationExpression_lfno_primary(): ClassInstanceCreationExpression_lfno_primaryContext;
    typeArgumentsOrDiamond(): TypeArgumentsOrDiamondContext;
    fieldAccess(): FieldAccessContext;
    fieldAccess_lf_primary(): FieldAccess_lf_primaryContext;
    fieldAccess_lfno_primary(): FieldAccess_lfno_primaryContext;
    arrayAccess(): ArrayAccessContext;
    arrayAccess_lf_primary(): ArrayAccess_lf_primaryContext;
    arrayAccess_lfno_primary(): ArrayAccess_lfno_primaryContext;
    methodInvocation(): MethodInvocationContext;
    methodInvocation_lf_primary(): MethodInvocation_lf_primaryContext;
    methodInvocation_lfno_primary(): MethodInvocation_lfno_primaryContext;
    argumentList(): ArgumentListContext;
    methodReference(): MethodReferenceContext;
    methodReference_lf_primary(): MethodReference_lf_primaryContext;
    methodReference_lfno_primary(): MethodReference_lfno_primaryContext;
    arrayCreationExpression(): ArrayCreationExpressionContext;
    dimExprs(): DimExprsContext;
    dimExpr(): DimExprContext;
    constantExpression(): ConstantExpressionContext;
    expression(): ExpressionContext;
    lambdaExpression(): LambdaExpressionContext;
    lambdaParameters(): LambdaParametersContext;
    inferredFormalParameterList(): InferredFormalParameterListContext;
    lambdaBody(): LambdaBodyContext;
    assignmentExpression(): AssignmentExpressionContext;
    assignment(): AssignmentContext;
    leftHandSide(): LeftHandSideContext;
    assignmentOperator(): AssignmentOperatorContext;
    conditionalExpression(): ConditionalExpressionContext;
    conditionalOrExpression(_p: any): ConditionalOrExpressionContext;
    conditionalAndExpression(_p: any): ConditionalAndExpressionContext;
    inclusiveOrExpression(_p: any): InclusiveOrExpressionContext;
    exclusiveOrExpression(_p: any): ExclusiveOrExpressionContext;
    andExpression(_p: any): AndExpressionContext;
    equalityExpression(_p: any): EqualityExpressionContext;
    relationalExpression(_p: any): RelationalExpressionContext;
    shiftExpression(_p: any): ShiftExpressionContext;
    additiveExpression(_p: any): AdditiveExpressionContext;
    multiplicativeExpression(_p: any): MultiplicativeExpressionContext;
    unaryExpression(): UnaryExpressionContext;
    preIncrementExpression(): PreIncrementExpressionContext;
    preDecrementExpression(): PreDecrementExpressionContext;
    unaryExpressionNotPlusMinus(): UnaryExpressionNotPlusMinusContext;
    postfixExpression(): PostfixExpressionContext;
    postIncrementExpression(): PostIncrementExpressionContext;
    postIncrementExpression_lf_postfixExpression(): PostIncrementExpression_lf_postfixExpressionContext;
    postDecrementExpression(): PostDecrementExpressionContext;
    postDecrementExpression_lf_postfixExpression(): PostDecrementExpression_lf_postfixExpressionContext;
    castExpression(): CastExpressionContext;
    identifier(): IdentifierContext;
    sempred(localctx: any, ruleIndex: any, predIndex: any): any;
    moduleName_sempred(localctx: any, predIndex: any): any;
    packageName_sempred(localctx: any, predIndex: any): any;
    packageOrTypeName_sempred(localctx: any, predIndex: any): any;
    ambiguousName_sempred(localctx: any, predIndex: any): any;
    conditionalOrExpression_sempred(localctx: any, predIndex: any): any;
    conditionalAndExpression_sempred(localctx: any, predIndex: any): any;
    inclusiveOrExpression_sempred(localctx: any, predIndex: any): any;
    exclusiveOrExpression_sempred(localctx: any, predIndex: any): any;
    andExpression_sempred(localctx: any, predIndex: any): any;
    equalityExpression_sempred(localctx: any, predIndex: any): any;
    relationalExpression_sempred(localctx: any, predIndex: any): any;
    shiftExpression_sempred(localctx: any, predIndex: any): any;
    additiveExpression_sempred(localctx: any, predIndex: any): any;
    multiplicativeExpression_sempred(localctx: any, predIndex: any): any;
}
export namespace Java9Parser {
    export const EOF: any;
    export const ABSTRACT: number;
    export const ASSERT: number;
    export const BOOLEAN: number;
    export const BREAK: number;
    export const BYTE: number;
    export const CASE: number;
    export const CATCH: number;
    export const CHAR: number;
    export const CLASS: number;
    export const CONST: number;
    export const CONTINUE: number;
    export const DEFAULT: number;
    export const DO: number;
    export const DOUBLE: number;
    export const ELSE: number;
    export const ENUM: number;
    export const EXPORTS: number;
    export const EXTENDS: number;
    export const FINAL: number;
    export const FINALLY: number;
    export const FLOAT: number;
    export const FOR: number;
    export const IF: number;
    export const GOTO: number;
    export const IMPLEMENTS: number;
    export const IMPORT: number;
    export const INSTANCEOF: number;
    export const INT: number;
    export const INTERFACE: number;
    export const LONG: number;
    export const MODULE: number;
    export const NATIVE: number;
    export const NEW: number;
    export const OPEN: number;
    export const OPERNS: number;
    export const PACKAGE: number;
    export const PRIVATE: number;
    export const PROTECTED: number;
    export const PROVIDES: number;
    export const PUBLIC: number;
    export const REQUIRES: number;
    export const RETURN: number;
    export const SHORT: number;
    export const STATIC: number;
    export const STRICTFP: number;
    export const SUPER: number;
    export const SWITCH: number;
    export const SYNCHRONIZED: number;
    export const THIS: number;
    export const THROW: number;
    export const THROWS: number;
    export const TO: number;
    export const TRANSIENT: number;
    export const TRANSITIVE: number;
    export const TRY: number;
    export const USES: number;
    export const VOID: number;
    export const VOLATILE: number;
    export const WHILE: number;
    export const WITH: number;
    export const UNDER_SCORE: number;
    export const IntegerLiteral: number;
    export const FloatingPointLiteral: number;
    export const BooleanLiteral: number;
    export const CharacterLiteral: number;
    export const StringLiteral: number;
    export const NullLiteral: number;
    export const LPAREN: number;
    export const RPAREN: number;
    export const LBRACE: number;
    export const RBRACE: number;
    export const LBRACK: number;
    export const RBRACK: number;
    export const SEMI: number;
    export const COMMA: number;
    export const DOT: number;
    export const ELLIPSIS: number;
    export const AT: number;
    export const COLONCOLON: number;
    export const ASSIGN: number;
    export const GT: number;
    export const LT: number;
    export const BANG: number;
    export const TILDE: number;
    export const QUESTION: number;
    export const COLON: number;
    export const ARROW: number;
    export const EQUAL: number;
    export const LE: number;
    export const GE: number;
    export const NOTEQUAL: number;
    export const AND: number;
    export const OR: number;
    export const INC: number;
    export const DEC: number;
    export const ADD: number;
    export const SUB: number;
    export const MUL: number;
    export const DIV: number;
    export const BITAND: number;
    export const BITOR: number;
    export const CARET: number;
    export const MOD: number;
    export const ADD_ASSIGN: number;
    export const SUB_ASSIGN: number;
    export const MUL_ASSIGN: number;
    export const DIV_ASSIGN: number;
    export const AND_ASSIGN: number;
    export const OR_ASSIGN: number;
    export const XOR_ASSIGN: number;
    export const MOD_ASSIGN: number;
    export const LSHIFT_ASSIGN: number;
    export const RSHIFT_ASSIGN: number;
    export const URSHIFT_ASSIGN: number;
    export const Identifier: number;
    export const WS: number;
    export const COMMENT: number;
    export const LINE_COMMENT: number;
    export const RULE_literal: number;
    export const RULE_primitiveType: number;
    export const RULE_numericType: number;
    export const RULE_integralType: number;
    export const RULE_floatingPointType: number;
    export const RULE_referenceType: number;
    export const RULE_classOrInterfaceType: number;
    export const RULE_classType: number;
    export const RULE_classType_lf_classOrInterfaceType: number;
    export const RULE_classType_lfno_classOrInterfaceType: number;
    export const RULE_interfaceType: number;
    export const RULE_interfaceType_lf_classOrInterfaceType: number;
    export const RULE_interfaceType_lfno_classOrInterfaceType: number;
    export const RULE_typeVariable: number;
    export const RULE_arrayType: number;
    export const RULE_dims: number;
    export const RULE_typeParameter: number;
    export const RULE_typeParameterModifier: number;
    export const RULE_typeBound: number;
    export const RULE_additionalBound: number;
    export const RULE_typeArguments: number;
    export const RULE_typeArgumentList: number;
    export const RULE_typeArgument: number;
    export const RULE_wildcard: number;
    export const RULE_wildcardBounds: number;
    export const RULE_moduleName: number;
    export const RULE_packageName: number;
    export const RULE_typeName: number;
    export const RULE_packageOrTypeName: number;
    export const RULE_expressionName: number;
    export const RULE_methodName: number;
    export const RULE_ambiguousName: number;
    export const RULE_compilationUnit: number;
    export const RULE_ordinaryCompilation: number;
    export const RULE_modularCompilation: number;
    export const RULE_packageDeclaration: number;
    export const RULE_packageModifier: number;
    export const RULE_importDeclaration: number;
    export const RULE_singleTypeImportDeclaration: number;
    export const RULE_typeImportOnDemandDeclaration: number;
    export const RULE_singleStaticImportDeclaration: number;
    export const RULE_staticImportOnDemandDeclaration: number;
    export const RULE_typeDeclaration: number;
    export const RULE_moduleDeclaration: number;
    export const RULE_moduleDirective: number;
    export const RULE_requiresModifier: number;
    export const RULE_classDeclaration: number;
    export const RULE_normalClassDeclaration: number;
    export const RULE_classModifier: number;
    export const RULE_typeParameters: number;
    export const RULE_typeParameterList: number;
    export const RULE_superclass: number;
    export const RULE_superinterfaces: number;
    export const RULE_interfaceTypeList: number;
    export const RULE_classBody: number;
    export const RULE_classBodyDeclaration: number;
    export const RULE_classMemberDeclaration: number;
    export const RULE_fieldDeclaration: number;
    export const RULE_fieldModifier: number;
    export const RULE_variableDeclaratorList: number;
    export const RULE_variableDeclarator: number;
    export const RULE_variableDeclaratorId: number;
    export const RULE_variableInitializer: number;
    export const RULE_unannType: number;
    export const RULE_unannPrimitiveType: number;
    export const RULE_unannReferenceType: number;
    export const RULE_unannClassOrInterfaceType: number;
    export const RULE_unannClassType: number;
    export const RULE_unannClassType_lf_unannClassOrInterfaceType: number;
    export const RULE_unannClassType_lfno_unannClassOrInterfaceType: number;
    export const RULE_unannInterfaceType: number;
    export const RULE_unannInterfaceType_lf_unannClassOrInterfaceType: number;
    export const RULE_unannInterfaceType_lfno_unannClassOrInterfaceType: number;
    export const RULE_unannTypeVariable: number;
    export const RULE_unannArrayType: number;
    export const RULE_methodDeclaration: number;
    export const RULE_methodModifier: number;
    export const RULE_methodHeader: number;
    export const RULE_result: number;
    export const RULE_methodDeclarator: number;
    export const RULE_formalParameterList: number;
    export const RULE_formalParameters: number;
    export const RULE_formalParameter: number;
    export const RULE_variableModifier: number;
    export const RULE_lastFormalParameter: number;
    export const RULE_receiverParameter: number;
    export const RULE_throws_: number;
    export const RULE_exceptionTypeList: number;
    export const RULE_exceptionType: number;
    export const RULE_methodBody: number;
    export const RULE_instanceInitializer: number;
    export const RULE_staticInitializer: number;
    export const RULE_constructorDeclaration: number;
    export const RULE_constructorModifier: number;
    export const RULE_constructorDeclarator: number;
    export const RULE_simpleTypeName: number;
    export const RULE_constructorBody: number;
    export const RULE_explicitConstructorInvocation: number;
    export const RULE_enumDeclaration: number;
    export const RULE_enumBody: number;
    export const RULE_enumConstantList: number;
    export const RULE_enumConstant: number;
    export const RULE_enumConstantModifier: number;
    export const RULE_enumBodyDeclarations: number;
    export const RULE_interfaceDeclaration: number;
    export const RULE_normalInterfaceDeclaration: number;
    export const RULE_interfaceModifier: number;
    export const RULE_extendsInterfaces: number;
    export const RULE_interfaceBody: number;
    export const RULE_interfaceMemberDeclaration: number;
    export const RULE_constantDeclaration: number;
    export const RULE_constantModifier: number;
    export const RULE_interfaceMethodDeclaration: number;
    export const RULE_interfaceMethodModifier: number;
    export const RULE_annotationTypeDeclaration: number;
    export const RULE_annotationTypeBody: number;
    export const RULE_annotationTypeMemberDeclaration: number;
    export const RULE_annotationTypeElementDeclaration: number;
    export const RULE_annotationTypeElementModifier: number;
    export const RULE_defaultValue: number;
    export const RULE_annotation: number;
    export const RULE_normalAnnotation: number;
    export const RULE_elementValuePairList: number;
    export const RULE_elementValuePair: number;
    export const RULE_elementValue: number;
    export const RULE_elementValueArrayInitializer: number;
    export const RULE_elementValueList: number;
    export const RULE_markerAnnotation: number;
    export const RULE_singleElementAnnotation: number;
    export const RULE_arrayInitializer: number;
    export const RULE_variableInitializerList: number;
    export const RULE_block: number;
    export const RULE_blockStatements: number;
    export const RULE_blockStatement: number;
    export const RULE_localVariableDeclarationStatement: number;
    export const RULE_localVariableDeclaration: number;
    export const RULE_statement: number;
    export const RULE_statementNoShortIf: number;
    export const RULE_statementWithoutTrailingSubstatement: number;
    export const RULE_emptyStatement: number;
    export const RULE_labeledStatement: number;
    export const RULE_labeledStatementNoShortIf: number;
    export const RULE_expressionStatement: number;
    export const RULE_statementExpression: number;
    export const RULE_ifThenStatement: number;
    export const RULE_ifThenElseStatement: number;
    export const RULE_ifThenElseStatementNoShortIf: number;
    export const RULE_assertStatement: number;
    export const RULE_switchStatement: number;
    export const RULE_switchBlock: number;
    export const RULE_switchBlockStatementGroup: number;
    export const RULE_switchLabels: number;
    export const RULE_switchLabel: number;
    export const RULE_enumConstantName: number;
    export const RULE_whileStatement: number;
    export const RULE_whileStatementNoShortIf: number;
    export const RULE_doStatement: number;
    export const RULE_forStatement: number;
    export const RULE_forStatementNoShortIf: number;
    export const RULE_basicForStatement: number;
    export const RULE_basicForStatementNoShortIf: number;
    export const RULE_forInit: number;
    export const RULE_forUpdate: number;
    export const RULE_statementExpressionList: number;
    export const RULE_enhancedForStatement: number;
    export const RULE_enhancedForStatementNoShortIf: number;
    export const RULE_breakStatement: number;
    export const RULE_continueStatement: number;
    export const RULE_returnStatement: number;
    export const RULE_throwStatement: number;
    export const RULE_synchronizedStatement: number;
    export const RULE_tryStatement: number;
    export const RULE_catches: number;
    export const RULE_catchClause: number;
    export const RULE_catchFormalParameter: number;
    export const RULE_catchType: number;
    export const RULE_finally_: number;
    export const RULE_tryWithResourcesStatement: number;
    export const RULE_resourceSpecification: number;
    export const RULE_resourceList: number;
    export const RULE_resource: number;
    export const RULE_variableAccess: number;
    export const RULE_primary: number;
    export const RULE_primaryNoNewArray: number;
    export const RULE_primaryNoNewArray_lf_arrayAccess: number;
    export const RULE_primaryNoNewArray_lfno_arrayAccess: number;
    export const RULE_primaryNoNewArray_lf_primary: number;
    export const RULE_primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary: number;
    export const RULE_primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary: number;
    export const RULE_primaryNoNewArray_lfno_primary: number;
    export const RULE_primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary: number;
    export const RULE_primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary: number;
    export const RULE_classLiteral: number;
    export const RULE_classInstanceCreationExpression: number;
    export const RULE_classInstanceCreationExpression_lf_primary: number;
    export const RULE_classInstanceCreationExpression_lfno_primary: number;
    export const RULE_typeArgumentsOrDiamond: number;
    export const RULE_fieldAccess: number;
    export const RULE_fieldAccess_lf_primary: number;
    export const RULE_fieldAccess_lfno_primary: number;
    export const RULE_arrayAccess: number;
    export const RULE_arrayAccess_lf_primary: number;
    export const RULE_arrayAccess_lfno_primary: number;
    export const RULE_methodInvocation: number;
    export const RULE_methodInvocation_lf_primary: number;
    export const RULE_methodInvocation_lfno_primary: number;
    export const RULE_argumentList: number;
    export const RULE_methodReference: number;
    export const RULE_methodReference_lf_primary: number;
    export const RULE_methodReference_lfno_primary: number;
    export const RULE_arrayCreationExpression: number;
    export const RULE_dimExprs: number;
    export const RULE_dimExpr: number;
    export const RULE_constantExpression: number;
    export const RULE_expression: number;
    export const RULE_lambdaExpression: number;
    export const RULE_lambdaParameters: number;
    export const RULE_inferredFormalParameterList: number;
    export const RULE_lambdaBody: number;
    export const RULE_assignmentExpression: number;
    export const RULE_assignment: number;
    export const RULE_leftHandSide: number;
    export const RULE_assignmentOperator: number;
    export const RULE_conditionalExpression: number;
    export const RULE_conditionalOrExpression: number;
    export const RULE_conditionalAndExpression: number;
    export const RULE_inclusiveOrExpression: number;
    export const RULE_exclusiveOrExpression: number;
    export const RULE_andExpression: number;
    export const RULE_equalityExpression: number;
    export const RULE_relationalExpression: number;
    export const RULE_shiftExpression: number;
    export const RULE_additiveExpression: number;
    export const RULE_multiplicativeExpression: number;
    export const RULE_unaryExpression: number;
    export const RULE_preIncrementExpression: number;
    export const RULE_preDecrementExpression: number;
    export const RULE_unaryExpressionNotPlusMinus: number;
    export const RULE_postfixExpression: number;
    export const RULE_postIncrementExpression: number;
    export const RULE_postIncrementExpression_lf_postfixExpression: number;
    export const RULE_postDecrementExpression: number;
    export const RULE_postDecrementExpression_lf_postfixExpression: number;
    export const RULE_castExpression: number;
    export const RULE_identifier: number;
    export { LiteralContext };
    export { PrimitiveTypeContext };
    export { NumericTypeContext };
    export { IntegralTypeContext };
    export { FloatingPointTypeContext };
    export { ReferenceTypeContext };
    export { ClassOrInterfaceTypeContext };
    export { ClassTypeContext };
    export { ClassType_lf_classOrInterfaceTypeContext };
    export { ClassType_lfno_classOrInterfaceTypeContext };
    export { InterfaceTypeContext };
    export { InterfaceType_lf_classOrInterfaceTypeContext };
    export { InterfaceType_lfno_classOrInterfaceTypeContext };
    export { TypeVariableContext };
    export { ArrayTypeContext };
    export { DimsContext };
    export { TypeParameterContext };
    export { TypeParameterModifierContext };
    export { TypeBoundContext };
    export { AdditionalBoundContext };
    export { TypeArgumentsContext };
    export { TypeArgumentListContext };
    export { TypeArgumentContext };
    export { WildcardContext };
    export { WildcardBoundsContext };
    export { TypeNameContext };
    export { ExpressionNameContext };
    export { MethodNameContext };
    export { CompilationUnitContext };
    export { OrdinaryCompilationContext };
    export { ModularCompilationContext };
    export { PackageDeclarationContext };
    export { PackageModifierContext };
    export { ImportDeclarationContext };
    export { SingleTypeImportDeclarationContext };
    export { TypeImportOnDemandDeclarationContext };
    export { SingleStaticImportDeclarationContext };
    export { StaticImportOnDemandDeclarationContext };
    export { TypeDeclarationContext };
    export { ModuleDeclarationContext };
    export { ModuleDirectiveContext };
    export { RequiresModifierContext };
    export { ClassDeclarationContext };
    export { NormalClassDeclarationContext };
    export { ClassModifierContext };
    export { TypeParametersContext };
    export { TypeParameterListContext };
    export { SuperclassContext };
    export { SuperinterfacesContext };
    export { InterfaceTypeListContext };
    export { ClassBodyContext };
    export { ClassBodyDeclarationContext };
    export { ClassMemberDeclarationContext };
    export { FieldDeclarationContext };
    export { FieldModifierContext };
    export { VariableDeclaratorListContext };
    export { VariableDeclaratorContext };
    export { VariableDeclaratorIdContext };
    export { VariableInitializerContext };
    export { UnannTypeContext };
    export { UnannPrimitiveTypeContext };
    export { UnannReferenceTypeContext };
    export { UnannClassOrInterfaceTypeContext };
    export { UnannClassTypeContext };
    export { UnannClassType_lf_unannClassOrInterfaceTypeContext };
    export { UnannClassType_lfno_unannClassOrInterfaceTypeContext };
    export { UnannInterfaceTypeContext };
    export { UnannInterfaceType_lf_unannClassOrInterfaceTypeContext };
    export { UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext };
    export { UnannTypeVariableContext };
    export { UnannArrayTypeContext };
    export { MethodDeclarationContext };
    export { MethodModifierContext };
    export { MethodHeaderContext };
    export { ResultContext };
    export { MethodDeclaratorContext };
    export { FormalParameterListContext };
    export { FormalParametersContext };
    export { FormalParameterContext };
    export { VariableModifierContext };
    export { LastFormalParameterContext };
    export { ReceiverParameterContext };
    export { Throws_Context };
    export { ExceptionTypeListContext };
    export { ExceptionTypeContext };
    export { MethodBodyContext };
    export { InstanceInitializerContext };
    export { StaticInitializerContext };
    export { ConstructorDeclarationContext };
    export { ConstructorModifierContext };
    export { ConstructorDeclaratorContext };
    export { SimpleTypeNameContext };
    export { ConstructorBodyContext };
    export { ExplicitConstructorInvocationContext };
    export { EnumDeclarationContext };
    export { EnumBodyContext };
    export { EnumConstantListContext };
    export { EnumConstantContext };
    export { EnumConstantModifierContext };
    export { EnumBodyDeclarationsContext };
    export { InterfaceDeclarationContext };
    export { NormalInterfaceDeclarationContext };
    export { InterfaceModifierContext };
    export { ExtendsInterfacesContext };
    export { InterfaceBodyContext };
    export { InterfaceMemberDeclarationContext };
    export { ConstantDeclarationContext };
    export { ConstantModifierContext };
    export { InterfaceMethodDeclarationContext };
    export { InterfaceMethodModifierContext };
    export { AnnotationTypeDeclarationContext };
    export { AnnotationTypeBodyContext };
    export { AnnotationTypeMemberDeclarationContext };
    export { AnnotationTypeElementDeclarationContext };
    export { AnnotationTypeElementModifierContext };
    export { DefaultValueContext };
    export { AnnotationContext };
    export { NormalAnnotationContext };
    export { ElementValuePairListContext };
    export { ElementValuePairContext };
    export { ElementValueContext };
    export { ElementValueArrayInitializerContext };
    export { ElementValueListContext };
    export { MarkerAnnotationContext };
    export { SingleElementAnnotationContext };
    export { ArrayInitializerContext };
    export { VariableInitializerListContext };
    export { BlockContext };
    export { BlockStatementsContext };
    export { BlockStatementContext };
    export { LocalVariableDeclarationStatementContext };
    export { LocalVariableDeclarationContext };
    export { StatementContext };
    export { StatementNoShortIfContext };
    export { StatementWithoutTrailingSubstatementContext };
    export { EmptyStatementContext };
    export { LabeledStatementContext };
    export { LabeledStatementNoShortIfContext };
    export { ExpressionStatementContext };
    export { StatementExpressionContext };
    export { IfThenStatementContext };
    export { IfThenElseStatementContext };
    export { IfThenElseStatementNoShortIfContext };
    export { AssertStatementContext };
    export { SwitchStatementContext };
    export { SwitchBlockContext };
    export { SwitchBlockStatementGroupContext };
    export { SwitchLabelsContext };
    export { SwitchLabelContext };
    export { EnumConstantNameContext };
    export { WhileStatementContext };
    export { WhileStatementNoShortIfContext };
    export { DoStatementContext };
    export { ForStatementContext };
    export { ForStatementNoShortIfContext };
    export { BasicForStatementContext };
    export { BasicForStatementNoShortIfContext };
    export { ForInitContext };
    export { ForUpdateContext };
    export { StatementExpressionListContext };
    export { EnhancedForStatementContext };
    export { EnhancedForStatementNoShortIfContext };
    export { BreakStatementContext };
    export { ContinueStatementContext };
    export { ReturnStatementContext };
    export { ThrowStatementContext };
    export { SynchronizedStatementContext };
    export { TryStatementContext };
    export { CatchesContext };
    export { CatchClauseContext };
    export { CatchFormalParameterContext };
    export { CatchTypeContext };
    export { Finally_Context };
    export { TryWithResourcesStatementContext };
    export { ResourceSpecificationContext };
    export { ResourceListContext };
    export { ResourceContext };
    export { VariableAccessContext };
    export { PrimaryContext };
    export { PrimaryNoNewArrayContext };
    export { PrimaryNoNewArray_lf_arrayAccessContext };
    export { PrimaryNoNewArray_lfno_arrayAccessContext };
    export { PrimaryNoNewArray_lf_primaryContext };
    export { PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext };
    export { PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext };
    export { PrimaryNoNewArray_lfno_primaryContext };
    export { PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext };
    export { PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext };
    export { ClassLiteralContext };
    export { ClassInstanceCreationExpressionContext };
    export { ClassInstanceCreationExpression_lf_primaryContext };
    export { ClassInstanceCreationExpression_lfno_primaryContext };
    export { TypeArgumentsOrDiamondContext };
    export { FieldAccessContext };
    export { FieldAccess_lf_primaryContext };
    export { FieldAccess_lfno_primaryContext };
    export { ArrayAccessContext };
    export { ArrayAccess_lf_primaryContext };
    export { ArrayAccess_lfno_primaryContext };
    export { MethodInvocationContext };
    export { MethodInvocation_lf_primaryContext };
    export { MethodInvocation_lfno_primaryContext };
    export { ArgumentListContext };
    export { MethodReferenceContext };
    export { MethodReference_lf_primaryContext };
    export { MethodReference_lfno_primaryContext };
    export { ArrayCreationExpressionContext };
    export { DimExprsContext };
    export { DimExprContext };
    export { ConstantExpressionContext };
    export { ExpressionContext };
    export { LambdaExpressionContext };
    export { LambdaParametersContext };
    export { InferredFormalParameterListContext };
    export { LambdaBodyContext };
    export { AssignmentExpressionContext };
    export { AssignmentContext };
    export { LeftHandSideContext };
    export { AssignmentOperatorContext };
    export { ConditionalExpressionContext };
    export { UnaryExpressionContext };
    export { PreIncrementExpressionContext };
    export { PreDecrementExpressionContext };
    export { UnaryExpressionNotPlusMinusContext };
    export { PostfixExpressionContext };
    export { PostIncrementExpressionContext };
    export { PostIncrementExpression_lf_postfixExpressionContext };
    export { PostDecrementExpressionContext };
    export { PostDecrementExpression_lf_postfixExpressionContext };
    export { CastExpressionContext };
    export { IdentifierContext };
}
declare function LiteralContext(parser: any, parent: any, invokingState: any): this;
declare class LiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LiteralContext;
    IntegerLiteral(): any;
    FloatingPointLiteral(): any;
    BooleanLiteral(): any;
    CharacterLiteral(): any;
    StringLiteral(): any;
    NullLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimitiveTypeContext(parser: any, parent: any, invokingState: any): this;
declare class PrimitiveTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimitiveTypeContext;
    numericType(): any;
    annotation(i: any): any;
    BOOLEAN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function NumericTypeContext(parser: any, parent: any, invokingState: any): this;
declare class NumericTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof NumericTypeContext;
    integralType(): any;
    floatingPointType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function IntegralTypeContext(parser: any, parent: any, invokingState: any): this;
declare class IntegralTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof IntegralTypeContext;
    BYTE(): any;
    SHORT(): any;
    INT(): any;
    LONG(): any;
    CHAR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FloatingPointTypeContext(parser: any, parent: any, invokingState: any): this;
declare class FloatingPointTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FloatingPointTypeContext;
    FLOAT(): any;
    DOUBLE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ReferenceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class ReferenceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ReferenceTypeContext;
    classOrInterfaceType(): any;
    typeVariable(): any;
    arrayType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class ClassOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassOrInterfaceTypeContext;
    classType_lfno_classOrInterfaceType(): any;
    interfaceType_lfno_classOrInterfaceType(): any;
    classType_lf_classOrInterfaceType(i: any): any;
    interfaceType_lf_classOrInterfaceType(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassTypeContext(parser: any, parent: any, invokingState: any): this;
declare class ClassTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassTypeContext;
    identifier(): any;
    annotation(i: any): any;
    typeArguments(): any;
    classOrInterfaceType(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassType_lf_classOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class ClassType_lf_classOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassType_lf_classOrInterfaceTypeContext;
    DOT(): any;
    identifier(): any;
    annotation(i: any): any;
    typeArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassType_lfno_classOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class ClassType_lfno_classOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassType_lfno_classOrInterfaceTypeContext;
    identifier(): any;
    annotation(i: any): any;
    typeArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceTypeContext;
    classType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceType_lf_classOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceType_lf_classOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceType_lf_classOrInterfaceTypeContext;
    classType_lf_classOrInterfaceType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceType_lfno_classOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceType_lfno_classOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceType_lfno_classOrInterfaceTypeContext;
    classType_lfno_classOrInterfaceType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeVariableContext(parser: any, parent: any, invokingState: any): this;
declare class TypeVariableContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeVariableContext;
    identifier(): any;
    annotation(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArrayTypeContext(parser: any, parent: any, invokingState: any): this;
declare class ArrayTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArrayTypeContext;
    primitiveType(): any;
    dims(): any;
    classOrInterfaceType(): any;
    typeVariable(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DimsContext(parser: any, parent: any, invokingState: any): this;
declare class DimsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DimsContext;
    LBRACK(i: any): any;
    RBRACK(i: any): any;
    annotation(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeParameterContext(parser: any, parent: any, invokingState: any): this;
declare class TypeParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeParameterContext;
    identifier(): any;
    typeParameterModifier(i: any): any;
    typeBound(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeParameterModifierContext(parser: any, parent: any, invokingState: any): this;
declare class TypeParameterModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeParameterModifierContext;
    annotation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeBoundContext(parser: any, parent: any, invokingState: any): this;
declare class TypeBoundContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeBoundContext;
    EXTENDS(): any;
    typeVariable(): any;
    classOrInterfaceType(): any;
    additionalBound(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AdditionalBoundContext(parser: any, parent: any, invokingState: any): this;
declare class AdditionalBoundContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AdditionalBoundContext;
    BITAND(): any;
    interfaceType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeArgumentsContext(parser: any, parent: any, invokingState: any): this;
declare class TypeArgumentsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeArgumentsContext;
    LT(): any;
    typeArgumentList(): any;
    GT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeArgumentListContext(parser: any, parent: any, invokingState: any): this;
declare class TypeArgumentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeArgumentListContext;
    typeArgument(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeArgumentContext(parser: any, parent: any, invokingState: any): this;
declare class TypeArgumentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeArgumentContext;
    referenceType(): any;
    wildcard(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function WildcardContext(parser: any, parent: any, invokingState: any): this;
declare class WildcardContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof WildcardContext;
    QUESTION(): any;
    annotation(i: any): any;
    wildcardBounds(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function WildcardBoundsContext(parser: any, parent: any, invokingState: any): this;
declare class WildcardBoundsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof WildcardBoundsContext;
    EXTENDS(): any;
    referenceType(): any;
    SUPER(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ModuleNameContext(parser: any, parent: any, invokingState: any): this;
declare class ModuleNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ModuleNameContext;
    identifier(): any;
    moduleName(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PackageNameContext(parser: any, parent: any, invokingState: any): this;
declare class PackageNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PackageNameContext;
    identifier(): any;
    packageName(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeNameContext(parser: any, parent: any, invokingState: any): this;
declare class TypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeNameContext;
    identifier(): any;
    packageOrTypeName(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PackageOrTypeNameContext(parser: any, parent: any, invokingState: any): this;
declare class PackageOrTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PackageOrTypeNameContext;
    identifier(): any;
    packageOrTypeName(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExpressionNameContext(parser: any, parent: any, invokingState: any): this;
declare class ExpressionNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExpressionNameContext;
    identifier(): any;
    ambiguousName(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodNameContext(parser: any, parent: any, invokingState: any): this;
declare class MethodNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodNameContext;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AmbiguousNameContext(parser: any, parent: any, invokingState: any): this;
declare class AmbiguousNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AmbiguousNameContext;
    identifier(): any;
    ambiguousName(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function CompilationUnitContext(parser: any, parent: any, invokingState: any): this;
declare class CompilationUnitContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof CompilationUnitContext;
    ordinaryCompilation(): any;
    modularCompilation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function OrdinaryCompilationContext(parser: any, parent: any, invokingState: any): this;
declare class OrdinaryCompilationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof OrdinaryCompilationContext;
    EOF(): any;
    packageDeclaration(): any;
    importDeclaration(i: any): any;
    typeDeclaration(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ModularCompilationContext(parser: any, parent: any, invokingState: any): this;
declare class ModularCompilationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ModularCompilationContext;
    moduleDeclaration(): any;
    importDeclaration(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PackageDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class PackageDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PackageDeclarationContext;
    PACKAGE(): any;
    packageName(): any;
    SEMI(): any;
    packageModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PackageModifierContext(parser: any, parent: any, invokingState: any): this;
declare class PackageModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PackageModifierContext;
    annotation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ImportDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class ImportDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ImportDeclarationContext;
    singleTypeImportDeclaration(): any;
    typeImportOnDemandDeclaration(): any;
    singleStaticImportDeclaration(): any;
    staticImportOnDemandDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SingleTypeImportDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class SingleTypeImportDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SingleTypeImportDeclarationContext;
    IMPORT(): any;
    typeName(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeImportOnDemandDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class TypeImportOnDemandDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeImportOnDemandDeclarationContext;
    IMPORT(): any;
    packageOrTypeName(): any;
    DOT(): any;
    MUL(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SingleStaticImportDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class SingleStaticImportDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SingleStaticImportDeclarationContext;
    IMPORT(): any;
    STATIC(): any;
    typeName(): any;
    DOT(): any;
    identifier(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StaticImportOnDemandDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class StaticImportOnDemandDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StaticImportOnDemandDeclarationContext;
    IMPORT(): any;
    STATIC(): any;
    typeName(): any;
    DOT(): any;
    MUL(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class TypeDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeDeclarationContext;
    classDeclaration(): any;
    interfaceDeclaration(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ModuleDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class ModuleDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ModuleDeclarationContext;
    MODULE(): any;
    moduleName(): any;
    LBRACE(): any;
    RBRACE(): any;
    annotation(i: any): any;
    OPEN(): any;
    moduleDirective(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ModuleDirectiveContext(parser: any, parent: any, invokingState: any): this;
declare class ModuleDirectiveContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ModuleDirectiveContext;
    REQUIRES(): any;
    moduleName(i: any): any;
    SEMI(): any;
    requiresModifier(i: any): any;
    EXPORTS(): any;
    packageName(): any;
    TO(): any;
    COMMA(i: any): any;
    OPERNS(): any;
    USES(): any;
    typeName(i: any): any;
    PROVIDES(): any;
    WITH(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function RequiresModifierContext(parser: any, parent: any, invokingState: any): this;
declare class RequiresModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof RequiresModifierContext;
    TRANSITIVE(): any;
    STATIC(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class ClassDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassDeclarationContext;
    normalClassDeclaration(): any;
    enumDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function NormalClassDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class NormalClassDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof NormalClassDeclarationContext;
    CLASS(): any;
    identifier(): any;
    classBody(): any;
    classModifier(i: any): any;
    typeParameters(): any;
    superclass(): any;
    superinterfaces(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassModifierContext(parser: any, parent: any, invokingState: any): this;
declare class ClassModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassModifierContext;
    annotation(): any;
    PUBLIC(): any;
    PROTECTED(): any;
    PRIVATE(): any;
    ABSTRACT(): any;
    STATIC(): any;
    FINAL(): any;
    STRICTFP(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeParametersContext(parser: any, parent: any, invokingState: any): this;
declare class TypeParametersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeParametersContext;
    LT(): any;
    typeParameterList(): any;
    GT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeParameterListContext(parser: any, parent: any, invokingState: any): this;
declare class TypeParameterListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeParameterListContext;
    typeParameter(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SuperclassContext(parser: any, parent: any, invokingState: any): this;
declare class SuperclassContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SuperclassContext;
    EXTENDS(): any;
    classType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SuperinterfacesContext(parser: any, parent: any, invokingState: any): this;
declare class SuperinterfacesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SuperinterfacesContext;
    IMPLEMENTS(): any;
    interfaceTypeList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceTypeListContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceTypeListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceTypeListContext;
    interfaceType(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassBodyContext(parser: any, parent: any, invokingState: any): this;
declare class ClassBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassBodyContext;
    LBRACE(): any;
    RBRACE(): any;
    classBodyDeclaration(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassBodyDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class ClassBodyDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassBodyDeclarationContext;
    classMemberDeclaration(): any;
    instanceInitializer(): any;
    staticInitializer(): any;
    constructorDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassMemberDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class ClassMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassMemberDeclarationContext;
    fieldDeclaration(): any;
    methodDeclaration(): any;
    classDeclaration(): any;
    interfaceDeclaration(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FieldDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class FieldDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FieldDeclarationContext;
    unannType(): any;
    variableDeclaratorList(): any;
    SEMI(): any;
    fieldModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FieldModifierContext(parser: any, parent: any, invokingState: any): this;
declare class FieldModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FieldModifierContext;
    annotation(): any;
    PUBLIC(): any;
    PROTECTED(): any;
    PRIVATE(): any;
    STATIC(): any;
    FINAL(): any;
    TRANSIENT(): any;
    VOLATILE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VariableDeclaratorListContext(parser: any, parent: any, invokingState: any): this;
declare class VariableDeclaratorListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VariableDeclaratorListContext;
    variableDeclarator(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VariableDeclaratorContext(parser: any, parent: any, invokingState: any): this;
declare class VariableDeclaratorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VariableDeclaratorContext;
    variableDeclaratorId(): any;
    ASSIGN(): any;
    variableInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VariableDeclaratorIdContext(parser: any, parent: any, invokingState: any): this;
declare class VariableDeclaratorIdContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VariableDeclaratorIdContext;
    identifier(): any;
    dims(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VariableInitializerContext(parser: any, parent: any, invokingState: any): this;
declare class VariableInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VariableInitializerContext;
    expression(): any;
    arrayInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannTypeContext;
    unannPrimitiveType(): any;
    unannReferenceType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannPrimitiveTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannPrimitiveTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannPrimitiveTypeContext;
    numericType(): any;
    BOOLEAN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannReferenceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannReferenceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannReferenceTypeContext;
    unannClassOrInterfaceType(): any;
    unannTypeVariable(): any;
    unannArrayType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannClassOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannClassOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannClassOrInterfaceTypeContext;
    unannClassType_lfno_unannClassOrInterfaceType(): any;
    unannInterfaceType_lfno_unannClassOrInterfaceType(): any;
    unannClassType_lf_unannClassOrInterfaceType(i: any): any;
    unannInterfaceType_lf_unannClassOrInterfaceType(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannClassTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannClassTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannClassTypeContext;
    identifier(): any;
    typeArguments(): any;
    unannClassOrInterfaceType(): any;
    DOT(): any;
    annotation(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannClassType_lf_unannClassOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannClassType_lf_unannClassOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannClassType_lf_unannClassOrInterfaceTypeContext;
    DOT(): any;
    identifier(): any;
    annotation(i: any): any;
    typeArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannClassType_lfno_unannClassOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannClassType_lfno_unannClassOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannClassType_lfno_unannClassOrInterfaceTypeContext;
    identifier(): any;
    typeArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannInterfaceTypeContext;
    unannClassType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannInterfaceType_lf_unannClassOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannInterfaceType_lf_unannClassOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannInterfaceType_lf_unannClassOrInterfaceTypeContext;
    unannClassType_lf_unannClassOrInterfaceType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannInterfaceType_lfno_unannClassOrInterfaceTypeContext;
    unannClassType_lfno_unannClassOrInterfaceType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannTypeVariableContext(parser: any, parent: any, invokingState: any): this;
declare class UnannTypeVariableContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannTypeVariableContext;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnannArrayTypeContext(parser: any, parent: any, invokingState: any): this;
declare class UnannArrayTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnannArrayTypeContext;
    unannPrimitiveType(): any;
    dims(): any;
    unannClassOrInterfaceType(): any;
    unannTypeVariable(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class MethodDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodDeclarationContext;
    methodHeader(): any;
    methodBody(): any;
    methodModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodModifierContext(parser: any, parent: any, invokingState: any): this;
declare class MethodModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodModifierContext;
    annotation(): any;
    PUBLIC(): any;
    PROTECTED(): any;
    PRIVATE(): any;
    ABSTRACT(): any;
    STATIC(): any;
    FINAL(): any;
    SYNCHRONIZED(): any;
    NATIVE(): any;
    STRICTFP(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodHeaderContext(parser: any, parent: any, invokingState: any): this;
declare class MethodHeaderContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodHeaderContext;
    result(): any;
    methodDeclarator(): any;
    throws_(): any;
    typeParameters(): any;
    annotation(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ResultContext(parser: any, parent: any, invokingState: any): this;
declare class ResultContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ResultContext;
    unannType(): any;
    VOID(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodDeclaratorContext(parser: any, parent: any, invokingState: any): this;
declare class MethodDeclaratorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodDeclaratorContext;
    identifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    formalParameterList(): any;
    dims(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FormalParameterListContext(parser: any, parent: any, invokingState: any): this;
declare class FormalParameterListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FormalParameterListContext;
    formalParameters(): any;
    COMMA(): any;
    lastFormalParameter(): any;
    receiverParameter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FormalParametersContext(parser: any, parent: any, invokingState: any): this;
declare class FormalParametersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FormalParametersContext;
    formalParameter(i: any): any;
    COMMA(i: any): any;
    receiverParameter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FormalParameterContext(parser: any, parent: any, invokingState: any): this;
declare class FormalParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FormalParameterContext;
    unannType(): any;
    variableDeclaratorId(): any;
    variableModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VariableModifierContext(parser: any, parent: any, invokingState: any): this;
declare class VariableModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VariableModifierContext;
    annotation(): any;
    FINAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LastFormalParameterContext(parser: any, parent: any, invokingState: any): this;
declare class LastFormalParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LastFormalParameterContext;
    unannType(): any;
    ELLIPSIS(): any;
    variableDeclaratorId(): any;
    variableModifier(i: any): any;
    annotation(i: any): any;
    formalParameter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ReceiverParameterContext(parser: any, parent: any, invokingState: any): this;
declare class ReceiverParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ReceiverParameterContext;
    unannType(): any;
    THIS(): any;
    annotation(i: any): any;
    identifier(): any;
    DOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Throws_Context(parser: any, parent: any, invokingState: any): this;
declare class Throws_Context {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Throws_Context;
    THROWS(): any;
    exceptionTypeList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExceptionTypeListContext(parser: any, parent: any, invokingState: any): this;
declare class ExceptionTypeListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExceptionTypeListContext;
    exceptionType(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExceptionTypeContext(parser: any, parent: any, invokingState: any): this;
declare class ExceptionTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExceptionTypeContext;
    classType(): any;
    typeVariable(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodBodyContext(parser: any, parent: any, invokingState: any): this;
declare class MethodBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodBodyContext;
    block(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InstanceInitializerContext(parser: any, parent: any, invokingState: any): this;
declare class InstanceInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InstanceInitializerContext;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StaticInitializerContext(parser: any, parent: any, invokingState: any): this;
declare class StaticInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StaticInitializerContext;
    STATIC(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConstructorDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class ConstructorDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConstructorDeclarationContext;
    constructorDeclarator(): any;
    constructorBody(): any;
    constructorModifier(i: any): any;
    throws_(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConstructorModifierContext(parser: any, parent: any, invokingState: any): this;
declare class ConstructorModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConstructorModifierContext;
    annotation(): any;
    PUBLIC(): any;
    PROTECTED(): any;
    PRIVATE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConstructorDeclaratorContext(parser: any, parent: any, invokingState: any): this;
declare class ConstructorDeclaratorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConstructorDeclaratorContext;
    simpleTypeName(): any;
    LPAREN(): any;
    RPAREN(): any;
    typeParameters(): any;
    formalParameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SimpleTypeNameContext(parser: any, parent: any, invokingState: any): this;
declare class SimpleTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SimpleTypeNameContext;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConstructorBodyContext(parser: any, parent: any, invokingState: any): this;
declare class ConstructorBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConstructorBodyContext;
    LBRACE(): any;
    RBRACE(): any;
    explicitConstructorInvocation(): any;
    blockStatements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExplicitConstructorInvocationContext(parser: any, parent: any, invokingState: any): this;
declare class ExplicitConstructorInvocationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExplicitConstructorInvocationContext;
    THIS(): any;
    LPAREN(): any;
    RPAREN(): any;
    SEMI(): any;
    typeArguments(): any;
    argumentList(): any;
    SUPER(): any;
    expressionName(): any;
    DOT(): any;
    primary(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnumDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class EnumDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnumDeclarationContext;
    ENUM(): any;
    identifier(): any;
    enumBody(): any;
    classModifier(i: any): any;
    superinterfaces(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnumBodyContext(parser: any, parent: any, invokingState: any): this;
declare class EnumBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnumBodyContext;
    LBRACE(): any;
    RBRACE(): any;
    enumConstantList(): any;
    COMMA(): any;
    enumBodyDeclarations(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnumConstantListContext(parser: any, parent: any, invokingState: any): this;
declare class EnumConstantListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnumConstantListContext;
    enumConstant(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnumConstantContext(parser: any, parent: any, invokingState: any): this;
declare class EnumConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnumConstantContext;
    identifier(): any;
    enumConstantModifier(i: any): any;
    LPAREN(): any;
    RPAREN(): any;
    classBody(): any;
    argumentList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnumConstantModifierContext(parser: any, parent: any, invokingState: any): this;
declare class EnumConstantModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnumConstantModifierContext;
    annotation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnumBodyDeclarationsContext(parser: any, parent: any, invokingState: any): this;
declare class EnumBodyDeclarationsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnumBodyDeclarationsContext;
    SEMI(): any;
    classBodyDeclaration(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceDeclarationContext;
    normalInterfaceDeclaration(): any;
    annotationTypeDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function NormalInterfaceDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class NormalInterfaceDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof NormalInterfaceDeclarationContext;
    INTERFACE(): any;
    identifier(): any;
    interfaceBody(): any;
    interfaceModifier(i: any): any;
    typeParameters(): any;
    extendsInterfaces(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceModifierContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceModifierContext;
    annotation(): any;
    PUBLIC(): any;
    PROTECTED(): any;
    PRIVATE(): any;
    ABSTRACT(): any;
    STATIC(): any;
    STRICTFP(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExtendsInterfacesContext(parser: any, parent: any, invokingState: any): this;
declare class ExtendsInterfacesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExtendsInterfacesContext;
    EXTENDS(): any;
    interfaceTypeList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceBodyContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceBodyContext;
    LBRACE(): any;
    RBRACE(): any;
    interfaceMemberDeclaration(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceMemberDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceMemberDeclarationContext;
    constantDeclaration(): any;
    interfaceMethodDeclaration(): any;
    classDeclaration(): any;
    interfaceDeclaration(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConstantDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class ConstantDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConstantDeclarationContext;
    unannType(): any;
    variableDeclaratorList(): any;
    SEMI(): any;
    constantModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConstantModifierContext(parser: any, parent: any, invokingState: any): this;
declare class ConstantModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConstantModifierContext;
    annotation(): any;
    PUBLIC(): any;
    STATIC(): any;
    FINAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceMethodDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceMethodDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceMethodDeclarationContext;
    methodHeader(): any;
    methodBody(): any;
    interfaceMethodModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InterfaceMethodModifierContext(parser: any, parent: any, invokingState: any): this;
declare class InterfaceMethodModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InterfaceMethodModifierContext;
    annotation(): any;
    PUBLIC(): any;
    PRIVATE(): any;
    ABSTRACT(): any;
    DEFAULT(): any;
    STATIC(): any;
    STRICTFP(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AnnotationTypeDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class AnnotationTypeDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AnnotationTypeDeclarationContext;
    AT(): any;
    INTERFACE(): any;
    identifier(): any;
    annotationTypeBody(): any;
    interfaceModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AnnotationTypeBodyContext(parser: any, parent: any, invokingState: any): this;
declare class AnnotationTypeBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AnnotationTypeBodyContext;
    LBRACE(): any;
    RBRACE(): any;
    annotationTypeMemberDeclaration(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AnnotationTypeMemberDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class AnnotationTypeMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AnnotationTypeMemberDeclarationContext;
    annotationTypeElementDeclaration(): any;
    constantDeclaration(): any;
    classDeclaration(): any;
    interfaceDeclaration(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AnnotationTypeElementDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class AnnotationTypeElementDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AnnotationTypeElementDeclarationContext;
    unannType(): any;
    identifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    SEMI(): any;
    annotationTypeElementModifier(i: any): any;
    dims(): any;
    defaultValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AnnotationTypeElementModifierContext(parser: any, parent: any, invokingState: any): this;
declare class AnnotationTypeElementModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AnnotationTypeElementModifierContext;
    annotation(): any;
    PUBLIC(): any;
    ABSTRACT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DefaultValueContext(parser: any, parent: any, invokingState: any): this;
declare class DefaultValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DefaultValueContext;
    DEFAULT(): any;
    elementValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AnnotationContext(parser: any, parent: any, invokingState: any): this;
declare class AnnotationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AnnotationContext;
    normalAnnotation(): any;
    markerAnnotation(): any;
    singleElementAnnotation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function NormalAnnotationContext(parser: any, parent: any, invokingState: any): this;
declare class NormalAnnotationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof NormalAnnotationContext;
    AT(): any;
    typeName(): any;
    LPAREN(): any;
    RPAREN(): any;
    elementValuePairList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ElementValuePairListContext(parser: any, parent: any, invokingState: any): this;
declare class ElementValuePairListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ElementValuePairListContext;
    elementValuePair(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ElementValuePairContext(parser: any, parent: any, invokingState: any): this;
declare class ElementValuePairContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ElementValuePairContext;
    identifier(): any;
    ASSIGN(): any;
    elementValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ElementValueContext(parser: any, parent: any, invokingState: any): this;
declare class ElementValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ElementValueContext;
    conditionalExpression(): any;
    elementValueArrayInitializer(): any;
    annotation(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ElementValueArrayInitializerContext(parser: any, parent: any, invokingState: any): this;
declare class ElementValueArrayInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ElementValueArrayInitializerContext;
    LBRACE(): any;
    RBRACE(): any;
    elementValueList(): any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ElementValueListContext(parser: any, parent: any, invokingState: any): this;
declare class ElementValueListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ElementValueListContext;
    elementValue(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MarkerAnnotationContext(parser: any, parent: any, invokingState: any): this;
declare class MarkerAnnotationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MarkerAnnotationContext;
    AT(): any;
    typeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SingleElementAnnotationContext(parser: any, parent: any, invokingState: any): this;
declare class SingleElementAnnotationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SingleElementAnnotationContext;
    AT(): any;
    typeName(): any;
    LPAREN(): any;
    elementValue(): any;
    RPAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArrayInitializerContext(parser: any, parent: any, invokingState: any): this;
declare class ArrayInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArrayInitializerContext;
    LBRACE(): any;
    RBRACE(): any;
    variableInitializerList(): any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VariableInitializerListContext(parser: any, parent: any, invokingState: any): this;
declare class VariableInitializerListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VariableInitializerListContext;
    variableInitializer(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function BlockContext(parser: any, parent: any, invokingState: any): this;
declare class BlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof BlockContext;
    LBRACE(): any;
    RBRACE(): any;
    blockStatements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function BlockStatementsContext(parser: any, parent: any, invokingState: any): this;
declare class BlockStatementsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof BlockStatementsContext;
    blockStatement(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function BlockStatementContext(parser: any, parent: any, invokingState: any): this;
declare class BlockStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof BlockStatementContext;
    localVariableDeclarationStatement(): any;
    classDeclaration(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LocalVariableDeclarationStatementContext(parser: any, parent: any, invokingState: any): this;
declare class LocalVariableDeclarationStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LocalVariableDeclarationStatementContext;
    localVariableDeclaration(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LocalVariableDeclarationContext(parser: any, parent: any, invokingState: any): this;
declare class LocalVariableDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LocalVariableDeclarationContext;
    unannType(): any;
    variableDeclaratorList(): any;
    variableModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StatementContext(parser: any, parent: any, invokingState: any): this;
declare class StatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StatementContext;
    statementWithoutTrailingSubstatement(): any;
    labeledStatement(): any;
    ifThenStatement(): any;
    ifThenElseStatement(): any;
    whileStatement(): any;
    forStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StatementNoShortIfContext(parser: any, parent: any, invokingState: any): this;
declare class StatementNoShortIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StatementNoShortIfContext;
    statementWithoutTrailingSubstatement(): any;
    labeledStatementNoShortIf(): any;
    ifThenElseStatementNoShortIf(): any;
    whileStatementNoShortIf(): any;
    forStatementNoShortIf(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StatementWithoutTrailingSubstatementContext(parser: any, parent: any, invokingState: any): this;
declare class StatementWithoutTrailingSubstatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StatementWithoutTrailingSubstatementContext;
    block(): any;
    emptyStatement(): any;
    expressionStatement(): any;
    assertStatement(): any;
    switchStatement(): any;
    doStatement(): any;
    breakStatement(): any;
    continueStatement(): any;
    returnStatement(): any;
    synchronizedStatement(): any;
    throwStatement(): any;
    tryStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EmptyStatementContext(parser: any, parent: any, invokingState: any): this;
declare class EmptyStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EmptyStatementContext;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LabeledStatementContext(parser: any, parent: any, invokingState: any): this;
declare class LabeledStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LabeledStatementContext;
    identifier(): any;
    COLON(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LabeledStatementNoShortIfContext(parser: any, parent: any, invokingState: any): this;
declare class LabeledStatementNoShortIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LabeledStatementNoShortIfContext;
    identifier(): any;
    COLON(): any;
    statementNoShortIf(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExpressionStatementContext(parser: any, parent: any, invokingState: any): this;
declare class ExpressionStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExpressionStatementContext;
    statementExpression(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StatementExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class StatementExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StatementExpressionContext;
    assignment(): any;
    preIncrementExpression(): any;
    preDecrementExpression(): any;
    postIncrementExpression(): any;
    postDecrementExpression(): any;
    methodInvocation(): any;
    classInstanceCreationExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function IfThenStatementContext(parser: any, parent: any, invokingState: any): this;
declare class IfThenStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof IfThenStatementContext;
    IF(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function IfThenElseStatementContext(parser: any, parent: any, invokingState: any): this;
declare class IfThenElseStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof IfThenElseStatementContext;
    IF(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    statementNoShortIf(): any;
    ELSE(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function IfThenElseStatementNoShortIfContext(parser: any, parent: any, invokingState: any): this;
declare class IfThenElseStatementNoShortIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof IfThenElseStatementNoShortIfContext;
    IF(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    statementNoShortIf(i: any): any;
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AssertStatementContext(parser: any, parent: any, invokingState: any): this;
declare class AssertStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AssertStatementContext;
    ASSERT(): any;
    expression(i: any): any;
    SEMI(): any;
    COLON(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SwitchStatementContext(parser: any, parent: any, invokingState: any): this;
declare class SwitchStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SwitchStatementContext;
    SWITCH(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    switchBlock(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SwitchBlockContext(parser: any, parent: any, invokingState: any): this;
declare class SwitchBlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SwitchBlockContext;
    LBRACE(): any;
    RBRACE(): any;
    switchBlockStatementGroup(i: any): any;
    switchLabel(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SwitchBlockStatementGroupContext(parser: any, parent: any, invokingState: any): this;
declare class SwitchBlockStatementGroupContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SwitchBlockStatementGroupContext;
    switchLabels(): any;
    blockStatements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SwitchLabelsContext(parser: any, parent: any, invokingState: any): this;
declare class SwitchLabelsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SwitchLabelsContext;
    switchLabel(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SwitchLabelContext(parser: any, parent: any, invokingState: any): this;
declare class SwitchLabelContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SwitchLabelContext;
    CASE(): any;
    constantExpression(): any;
    COLON(): any;
    enumConstantName(): any;
    DEFAULT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnumConstantNameContext(parser: any, parent: any, invokingState: any): this;
declare class EnumConstantNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnumConstantNameContext;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function WhileStatementContext(parser: any, parent: any, invokingState: any): this;
declare class WhileStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof WhileStatementContext;
    WHILE(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function WhileStatementNoShortIfContext(parser: any, parent: any, invokingState: any): this;
declare class WhileStatementNoShortIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof WhileStatementNoShortIfContext;
    WHILE(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    statementNoShortIf(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DoStatementContext(parser: any, parent: any, invokingState: any): this;
declare class DoStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DoStatementContext;
    DO(): any;
    statement(): any;
    WHILE(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ForStatementContext(parser: any, parent: any, invokingState: any): this;
declare class ForStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ForStatementContext;
    basicForStatement(): any;
    enhancedForStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ForStatementNoShortIfContext(parser: any, parent: any, invokingState: any): this;
declare class ForStatementNoShortIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ForStatementNoShortIfContext;
    basicForStatementNoShortIf(): any;
    enhancedForStatementNoShortIf(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function BasicForStatementContext(parser: any, parent: any, invokingState: any): this;
declare class BasicForStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof BasicForStatementContext;
    FOR(): any;
    LPAREN(): any;
    SEMI(i: any): any;
    RPAREN(): any;
    statement(): any;
    forInit(): any;
    expression(): any;
    forUpdate(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function BasicForStatementNoShortIfContext(parser: any, parent: any, invokingState: any): this;
declare class BasicForStatementNoShortIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof BasicForStatementNoShortIfContext;
    FOR(): any;
    LPAREN(): any;
    SEMI(i: any): any;
    RPAREN(): any;
    statementNoShortIf(): any;
    forInit(): any;
    expression(): any;
    forUpdate(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ForInitContext(parser: any, parent: any, invokingState: any): this;
declare class ForInitContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ForInitContext;
    statementExpressionList(): any;
    localVariableDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ForUpdateContext(parser: any, parent: any, invokingState: any): this;
declare class ForUpdateContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ForUpdateContext;
    statementExpressionList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StatementExpressionListContext(parser: any, parent: any, invokingState: any): this;
declare class StatementExpressionListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StatementExpressionListContext;
    statementExpression(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnhancedForStatementContext(parser: any, parent: any, invokingState: any): this;
declare class EnhancedForStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnhancedForStatementContext;
    FOR(): any;
    LPAREN(): any;
    unannType(): any;
    variableDeclaratorId(): any;
    COLON(): any;
    expression(): any;
    RPAREN(): any;
    statement(): any;
    variableModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EnhancedForStatementNoShortIfContext(parser: any, parent: any, invokingState: any): this;
declare class EnhancedForStatementNoShortIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EnhancedForStatementNoShortIfContext;
    FOR(): any;
    LPAREN(): any;
    unannType(): any;
    variableDeclaratorId(): any;
    COLON(): any;
    expression(): any;
    RPAREN(): any;
    statementNoShortIf(): any;
    variableModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function BreakStatementContext(parser: any, parent: any, invokingState: any): this;
declare class BreakStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof BreakStatementContext;
    BREAK(): any;
    SEMI(): any;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ContinueStatementContext(parser: any, parent: any, invokingState: any): this;
declare class ContinueStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ContinueStatementContext;
    CONTINUE(): any;
    SEMI(): any;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ReturnStatementContext(parser: any, parent: any, invokingState: any): this;
declare class ReturnStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ReturnStatementContext;
    RETURN(): any;
    SEMI(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ThrowStatementContext(parser: any, parent: any, invokingState: any): this;
declare class ThrowStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ThrowStatementContext;
    THROW(): any;
    expression(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SynchronizedStatementContext(parser: any, parent: any, invokingState: any): this;
declare class SynchronizedStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SynchronizedStatementContext;
    SYNCHRONIZED(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TryStatementContext(parser: any, parent: any, invokingState: any): this;
declare class TryStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TryStatementContext;
    TRY(): any;
    block(): any;
    catches(): any;
    finally_(): any;
    tryWithResourcesStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function CatchesContext(parser: any, parent: any, invokingState: any): this;
declare class CatchesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof CatchesContext;
    catchClause(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function CatchClauseContext(parser: any, parent: any, invokingState: any): this;
declare class CatchClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof CatchClauseContext;
    CATCH(): any;
    LPAREN(): any;
    catchFormalParameter(): any;
    RPAREN(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function CatchFormalParameterContext(parser: any, parent: any, invokingState: any): this;
declare class CatchFormalParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof CatchFormalParameterContext;
    catchType(): any;
    variableDeclaratorId(): any;
    variableModifier(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function CatchTypeContext(parser: any, parent: any, invokingState: any): this;
declare class CatchTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof CatchTypeContext;
    unannClassType(): any;
    BITOR(i: any): any;
    classType(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Finally_Context(parser: any, parent: any, invokingState: any): this;
declare class Finally_Context {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Finally_Context;
    FINALLY(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TryWithResourcesStatementContext(parser: any, parent: any, invokingState: any): this;
declare class TryWithResourcesStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TryWithResourcesStatementContext;
    TRY(): any;
    resourceSpecification(): any;
    block(): any;
    catches(): any;
    finally_(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ResourceSpecificationContext(parser: any, parent: any, invokingState: any): this;
declare class ResourceSpecificationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ResourceSpecificationContext;
    LPAREN(): any;
    resourceList(): any;
    RPAREN(): any;
    SEMI(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ResourceListContext(parser: any, parent: any, invokingState: any): this;
declare class ResourceListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ResourceListContext;
    resource(i: any): any;
    SEMI(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ResourceContext(parser: any, parent: any, invokingState: any): this;
declare class ResourceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ResourceContext;
    unannType(): any;
    variableDeclaratorId(): any;
    ASSIGN(): any;
    expression(): any;
    variableModifier(i: any): any;
    variableAccess(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VariableAccessContext(parser: any, parent: any, invokingState: any): this;
declare class VariableAccessContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VariableAccessContext;
    expressionName(): any;
    fieldAccess(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryContext;
    primaryNoNewArray_lfno_primary(): any;
    arrayCreationExpression(): any;
    primaryNoNewArray_lf_primary(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArrayContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArrayContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArrayContext;
    literal(): any;
    classLiteral(): any;
    THIS(): any;
    typeName(): any;
    DOT(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    classInstanceCreationExpression(): any;
    fieldAccess(): any;
    arrayAccess(): any;
    methodInvocation(): any;
    methodReference(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lf_arrayAccessContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lf_arrayAccessContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lf_arrayAccessContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lfno_arrayAccessContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lfno_arrayAccessContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lfno_arrayAccessContext;
    literal(): any;
    typeName(): any;
    DOT(): any;
    CLASS(): any;
    LBRACK(i: any): any;
    RBRACK(i: any): any;
    VOID(): any;
    THIS(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    classInstanceCreationExpression(): any;
    fieldAccess(): any;
    methodInvocation(): any;
    methodReference(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lf_primaryContext;
    classInstanceCreationExpression_lf_primary(): any;
    fieldAccess_lf_primary(): any;
    arrayAccess_lf_primary(): any;
    methodInvocation_lf_primary(): any;
    methodReference_lf_primary(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primaryContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primaryContext;
    classInstanceCreationExpression_lf_primary(): any;
    fieldAccess_lf_primary(): any;
    methodInvocation_lf_primary(): any;
    methodReference_lf_primary(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lfno_primaryContext;
    literal(): any;
    typeName(): any;
    DOT(): any;
    CLASS(): any;
    LBRACK(i: any): any;
    RBRACK(i: any): any;
    unannPrimitiveType(): any;
    VOID(): any;
    THIS(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    classInstanceCreationExpression_lfno_primary(): any;
    fieldAccess_lfno_primary(): any;
    arrayAccess_lfno_primary(): any;
    methodInvocation_lfno_primary(): any;
    methodReference_lfno_primary(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primaryContext;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primaryContext;
    literal(): any;
    typeName(): any;
    DOT(): any;
    CLASS(): any;
    LBRACK(i: any): any;
    RBRACK(i: any): any;
    unannPrimitiveType(): any;
    VOID(): any;
    THIS(): any;
    LPAREN(): any;
    expression(): any;
    RPAREN(): any;
    classInstanceCreationExpression_lfno_primary(): any;
    fieldAccess_lfno_primary(): any;
    methodInvocation_lfno_primary(): any;
    methodReference_lfno_primary(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassLiteralContext(parser: any, parent: any, invokingState: any): this;
declare class ClassLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassLiteralContext;
    DOT(): any;
    CLASS(): any;
    typeName(): any;
    numericType(): any;
    BOOLEAN(): any;
    LBRACK(i: any): any;
    RBRACK(i: any): any;
    VOID(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassInstanceCreationExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ClassInstanceCreationExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassInstanceCreationExpressionContext;
    NEW(): any;
    identifier(i: any): any;
    LPAREN(): any;
    RPAREN(): any;
    typeArguments(): any;
    annotation(i: any): any;
    DOT(i: any): any;
    typeArgumentsOrDiamond(): any;
    argumentList(): any;
    classBody(): any;
    expressionName(): any;
    primary(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassInstanceCreationExpression_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class ClassInstanceCreationExpression_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassInstanceCreationExpression_lf_primaryContext;
    DOT(): any;
    NEW(): any;
    identifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    typeArguments(): any;
    annotation(i: any): any;
    typeArgumentsOrDiamond(): any;
    argumentList(): any;
    classBody(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassInstanceCreationExpression_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class ClassInstanceCreationExpression_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassInstanceCreationExpression_lfno_primaryContext;
    NEW(): any;
    identifier(i: any): any;
    LPAREN(): any;
    RPAREN(): any;
    typeArguments(): any;
    annotation(i: any): any;
    DOT(i: any): any;
    typeArgumentsOrDiamond(): any;
    argumentList(): any;
    classBody(): any;
    expressionName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypeArgumentsOrDiamondContext(parser: any, parent: any, invokingState: any): this;
declare class TypeArgumentsOrDiamondContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypeArgumentsOrDiamondContext;
    typeArguments(): any;
    LT(): any;
    GT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FieldAccessContext(parser: any, parent: any, invokingState: any): this;
declare class FieldAccessContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FieldAccessContext;
    primary(): any;
    DOT(i: any): any;
    identifier(): any;
    SUPER(): any;
    typeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FieldAccess_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class FieldAccess_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FieldAccess_lf_primaryContext;
    DOT(): any;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FieldAccess_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class FieldAccess_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FieldAccess_lfno_primaryContext;
    SUPER(): any;
    DOT(i: any): any;
    identifier(): any;
    typeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArrayAccessContext(parser: any, parent: any, invokingState: any): this;
declare class ArrayAccessContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArrayAccessContext;
    expressionName(): any;
    LBRACK(i: any): any;
    expression(i: any): any;
    RBRACK(i: any): any;
    primaryNoNewArray_lfno_arrayAccess(): any;
    primaryNoNewArray_lf_arrayAccess(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArrayAccess_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class ArrayAccess_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArrayAccess_lf_primaryContext;
    primaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary(): any;
    LBRACK(i: any): any;
    expression(i: any): any;
    RBRACK(i: any): any;
    primaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArrayAccess_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class ArrayAccess_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArrayAccess_lfno_primaryContext;
    expressionName(): any;
    LBRACK(i: any): any;
    expression(i: any): any;
    RBRACK(i: any): any;
    primaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary(): any;
    primaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodInvocationContext(parser: any, parent: any, invokingState: any): this;
declare class MethodInvocationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodInvocationContext;
    methodName(): any;
    LPAREN(): any;
    RPAREN(): any;
    argumentList(): any;
    typeName(): any;
    DOT(i: any): any;
    identifier(): any;
    typeArguments(): any;
    expressionName(): any;
    primary(): any;
    SUPER(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodInvocation_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class MethodInvocation_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodInvocation_lf_primaryContext;
    DOT(): any;
    identifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    typeArguments(): any;
    argumentList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodInvocation_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class MethodInvocation_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodInvocation_lfno_primaryContext;
    methodName(): any;
    LPAREN(): any;
    RPAREN(): any;
    argumentList(): any;
    typeName(): any;
    DOT(i: any): any;
    identifier(): any;
    typeArguments(): any;
    expressionName(): any;
    SUPER(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArgumentListContext(parser: any, parent: any, invokingState: any): this;
declare class ArgumentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArgumentListContext;
    expression(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodReferenceContext(parser: any, parent: any, invokingState: any): this;
declare class MethodReferenceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodReferenceContext;
    expressionName(): any;
    COLONCOLON(): any;
    identifier(): any;
    typeArguments(): any;
    referenceType(): any;
    primary(): any;
    SUPER(): any;
    typeName(): any;
    DOT(): any;
    classType(): any;
    NEW(): any;
    arrayType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodReference_lf_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class MethodReference_lf_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodReference_lf_primaryContext;
    COLONCOLON(): any;
    identifier(): any;
    typeArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MethodReference_lfno_primaryContext(parser: any, parent: any, invokingState: any): this;
declare class MethodReference_lfno_primaryContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MethodReference_lfno_primaryContext;
    expressionName(): any;
    COLONCOLON(): any;
    identifier(): any;
    typeArguments(): any;
    referenceType(): any;
    SUPER(): any;
    typeName(): any;
    DOT(): any;
    classType(): any;
    NEW(): any;
    arrayType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArrayCreationExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ArrayCreationExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArrayCreationExpressionContext;
    NEW(): any;
    primitiveType(): any;
    dimExprs(): any;
    dims(): any;
    classOrInterfaceType(): any;
    arrayInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DimExprsContext(parser: any, parent: any, invokingState: any): this;
declare class DimExprsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DimExprsContext;
    dimExpr(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DimExprContext(parser: any, parent: any, invokingState: any): this;
declare class DimExprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DimExprContext;
    LBRACK(): any;
    expression(): any;
    RBRACK(): any;
    annotation(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConstantExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ConstantExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConstantExpressionContext;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExpressionContext;
    lambdaExpression(): any;
    assignmentExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LambdaExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class LambdaExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LambdaExpressionContext;
    lambdaParameters(): any;
    ARROW(): any;
    lambdaBody(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LambdaParametersContext(parser: any, parent: any, invokingState: any): this;
declare class LambdaParametersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LambdaParametersContext;
    identifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    formalParameterList(): any;
    inferredFormalParameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InferredFormalParameterListContext(parser: any, parent: any, invokingState: any): this;
declare class InferredFormalParameterListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InferredFormalParameterListContext;
    identifier(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LambdaBodyContext(parser: any, parent: any, invokingState: any): this;
declare class LambdaBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LambdaBodyContext;
    expression(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AssignmentExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class AssignmentExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AssignmentExpressionContext;
    conditionalExpression(): any;
    assignment(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AssignmentContext(parser: any, parent: any, invokingState: any): this;
declare class AssignmentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AssignmentContext;
    leftHandSide(): any;
    assignmentOperator(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LeftHandSideContext(parser: any, parent: any, invokingState: any): this;
declare class LeftHandSideContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LeftHandSideContext;
    expressionName(): any;
    fieldAccess(): any;
    arrayAccess(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AssignmentOperatorContext(parser: any, parent: any, invokingState: any): this;
declare class AssignmentOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AssignmentOperatorContext;
    ASSIGN(): any;
    MUL_ASSIGN(): any;
    DIV_ASSIGN(): any;
    MOD_ASSIGN(): any;
    ADD_ASSIGN(): any;
    SUB_ASSIGN(): any;
    LSHIFT_ASSIGN(): any;
    RSHIFT_ASSIGN(): any;
    URSHIFT_ASSIGN(): any;
    AND_ASSIGN(): any;
    XOR_ASSIGN(): any;
    OR_ASSIGN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConditionalExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ConditionalExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConditionalExpressionContext;
    conditionalOrExpression(): any;
    QUESTION(): any;
    expression(): any;
    COLON(): any;
    conditionalExpression(): any;
    lambdaExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConditionalOrExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ConditionalOrExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConditionalOrExpressionContext;
    conditionalAndExpression(): any;
    conditionalOrExpression(): any;
    OR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ConditionalAndExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ConditionalAndExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ConditionalAndExpressionContext;
    inclusiveOrExpression(): any;
    conditionalAndExpression(): any;
    AND(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function InclusiveOrExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class InclusiveOrExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof InclusiveOrExpressionContext;
    exclusiveOrExpression(): any;
    inclusiveOrExpression(): any;
    BITOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExclusiveOrExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ExclusiveOrExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExclusiveOrExpressionContext;
    andExpression(): any;
    exclusiveOrExpression(): any;
    CARET(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AndExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class AndExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AndExpressionContext;
    equalityExpression(): any;
    andExpression(): any;
    BITAND(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function EqualityExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class EqualityExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof EqualityExpressionContext;
    relationalExpression(): any;
    equalityExpression(): any;
    EQUAL(): any;
    NOTEQUAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function RelationalExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class RelationalExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof RelationalExpressionContext;
    shiftExpression(): any;
    relationalExpression(): any;
    LT(): any;
    GT(): any;
    LE(): any;
    GE(): any;
    INSTANCEOF(): any;
    referenceType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ShiftExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class ShiftExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ShiftExpressionContext;
    additiveExpression(): any;
    shiftExpression(): any;
    LT(i: any): any;
    GT(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AdditiveExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class AdditiveExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AdditiveExpressionContext;
    multiplicativeExpression(): any;
    additiveExpression(): any;
    ADD(): any;
    SUB(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function MultiplicativeExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class MultiplicativeExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof MultiplicativeExpressionContext;
    unaryExpression(): any;
    multiplicativeExpression(): any;
    MUL(): any;
    DIV(): any;
    MOD(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnaryExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class UnaryExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnaryExpressionContext;
    preIncrementExpression(): any;
    preDecrementExpression(): any;
    ADD(): any;
    unaryExpression(): any;
    SUB(): any;
    unaryExpressionNotPlusMinus(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PreIncrementExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class PreIncrementExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PreIncrementExpressionContext;
    INC(): any;
    unaryExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PreDecrementExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class PreDecrementExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PreDecrementExpressionContext;
    DEC(): any;
    unaryExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function UnaryExpressionNotPlusMinusContext(parser: any, parent: any, invokingState: any): this;
declare class UnaryExpressionNotPlusMinusContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof UnaryExpressionNotPlusMinusContext;
    postfixExpression(): any;
    TILDE(): any;
    unaryExpression(): any;
    BANG(): any;
    castExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PostfixExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class PostfixExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PostfixExpressionContext;
    primary(): any;
    expressionName(): any;
    postIncrementExpression_lf_postfixExpression(i: any): any;
    postDecrementExpression_lf_postfixExpression(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PostIncrementExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class PostIncrementExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PostIncrementExpressionContext;
    postfixExpression(): any;
    INC(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PostIncrementExpression_lf_postfixExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class PostIncrementExpression_lf_postfixExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PostIncrementExpression_lf_postfixExpressionContext;
    INC(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PostDecrementExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class PostDecrementExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PostDecrementExpressionContext;
    postfixExpression(): any;
    DEC(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PostDecrementExpression_lf_postfixExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class PostDecrementExpression_lf_postfixExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PostDecrementExpression_lf_postfixExpressionContext;
    DEC(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function CastExpressionContext(parser: any, parent: any, invokingState: any): this;
declare class CastExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof CastExpressionContext;
    LPAREN(): any;
    primitiveType(): any;
    RPAREN(): any;
    unaryExpression(): any;
    referenceType(): any;
    unaryExpressionNotPlusMinus(): any;
    additionalBound(i: any): any;
    lambdaExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function IdentifierContext(parser: any, parent: any, invokingState: any): this;
declare class IdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof IdentifierContext;
    Identifier(): any;
    TO(): any;
    MODULE(): any;
    OPEN(): any;
    WITH(): any;
    PROVIDES(): any;
    USES(): any;
    OPERNS(): any;
    REQUIRES(): any;
    EXPORTS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
export {};
//# sourceMappingURL=Java9Parser.d.ts.map
/**
 * NOTE: this is a generated file, do not edit it will be overwritten 
 */
import { AbstractDal } from './AbstractDal.generated'
import CircularReplacer from '../util/CircularReplacer'
import { Traceable } from '@harvest-forward/hf-model'
import Pino from "pino"
import { validate } from 'class-validator'
import { DeepPartial, Repository } from 'typeorm'

export abstract class AbstractCrudDal<T extends Traceable> extends AbstractDal {
    protected logger = Pino({ name: this.constructor.name, level: process.env.LOG_LEVEL || 'info' })

    constructor(userId: number) {
        super(userId)
    }

    abstract getRepository(): Promise<Repository<T>>

    async create(newItem: T): Promise<T> {
        try {
            this.logger.debug(`create(${JSON.stringify(newItem, CircularReplacer())})`)
            let currentUser = await this.getCurrentUser()
            newItem.createdBy = currentUser
            newItem.createdOn = new Date()
            newItem.lastUpdatedBy = currentUser
            newItem.lastUpdatedOn = new Date()

            let failures = await validate(newItem)
            if (failures && failures.length > 0)
                throw new RangeError(JSON.stringify(failures))

            let repo = await this.getRepository()
            let data = await repo.save(newItem as DeepPartial<T>)
            return data as unknown as T
        }
        catch (problem) {
            this.logger.error(`create failed ${JSON.stringify(newItem, CircularReplacer())} reason ${problem}`)
            throw problem
        }
    };

    async findOneById(id: number): Promise<T> {
        let repo = await this.getRepository()
        let theOne = await repo.findOne(id)
        if (theOne == null)
            throw Error(`Object with the id of ${id} does not exist`)
        return theOne
    };

    async update(itemUpdate: T): Promise<T> {
        try {
            this.logger.debug(`update(${JSON.stringify(itemUpdate, CircularReplacer())})`)
            let currentUser = await this.getCurrentUser()
            itemUpdate.lastUpdatedBy = currentUser
            itemUpdate.lastUpdatedOn = new Date()

            let failures = await validate(itemUpdate)
            if (failures && failures.length > 0)
                throw new Error(JSON.stringify(failures))

            let repo = await this.getRepository()
            let data = await repo.save(itemUpdate as DeepPartial<T>)
            return data as unknown as T
        }
        catch (problem) {
            this.logger.error(`update failed ${JSON.stringify(itemUpdate, CircularReplacer())}, reason ${problem}`)
            throw problem
        }
    };

    async remove(id: number): Promise<boolean> {
        try {
            this.logger.debug(`remove(${id})`)
            let repo = await this.getRepository()
            await repo.delete({ id: id })
            return true
        }
        catch (problem) {
            this.logger.error(`remove failed ${id} reson ${problem}`)
            throw problem
        }
    }
}
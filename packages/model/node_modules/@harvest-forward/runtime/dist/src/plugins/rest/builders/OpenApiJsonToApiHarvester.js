"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenApiJsonToApiHarvester = void 0;
const fs_1 = __importDefault(require("fs"));
const sh = __importStar(require("shelljs"));
const AbstractSingularBuilder_1 = require("../../../runtime/AbstractSingularBuilder");
const ProgrammingLanguage_1 = require("../../../system/ProgrammingLanguage");
const SystemComponent_1 = require("../../../system/SystemComponent");
const SystemComponentType_1 = require("../../../system/SystemComponentType");
const ValueType_1 = require("../../../system/ValueType");
const Variable_1 = require("../../../system/Variable");
const CircularReplacer_1 = require("../../../util/CircularReplacer");
const information_architecture_1 = require("../../information-architecture");
const HttpVerb_1 = require("../HttpVerb");
const Path_1 = require("../Path");
const PathParameter_1 = require("../PathParameter");
const Resource_1 = require("../Resource");
const RestParameterLocation_1 = require("../RestParameterLocation");
class OpenApiJsonToApiHarvester extends AbstractSingularBuilder_1.AbstractSingularBuilder {
    constructor(configurationValues) {
        super('OpenApiJsonToApiHarvester', 'A harvester that reads an openapi.json file and creates an api spec from it', {
            sourcePath: {
                name: 'Source Path',
                required: true,
                description: 'The fully qualified file name and path to the open api json specification file',
                valueType: ValueType_1.ValueType.STRING,
            },
        }, configurationValues);
    }
    valueTypeFromJson(system, typeSpec) {
        const typeString = typeSpec['type'];
        if (typeString != null) {
            const upperSpec = typeString.toUpperCase();
            if (upperSpec == 'ARRAY') {
                const componentType = this.valueTypeFromJson(system, typeSpec.items);
                return componentType.asCollection;
            }
            const builtInTypes = ValueType_1.ValueType.getValues();
            for (let index = 0; index < builtInTypes.length; index++) {
                const type = builtInTypes[index];
                if (type.name == typeString || type.name.toUpperCase() === upperSpec)
                    return type;
                const typeScriptName = type.inLanguage(ProgrammingLanguage_1.ProgrammingLanguage.typeScript);
                if (typeScriptName == typeString || typeScriptName == upperSpec)
                    return type;
            }
        }
        const referenceString = typeSpec['$ref'];
        if (referenceString != null) {
            const model = information_architecture_1.InformationModel.fromSystem(system);
            const referenceName = referenceString.replace(/#.components.schemas./, '');
            const fullName = SystemComponent_1.SystemComponent.fullConstantCase(model.fullConstantCaseName, referenceName);
            let referencedClass = system.descendants[fullName];
            if (referenceName === '') {
                this.logger.info(`valueTypeFromJson(${JSON.stringify(typeSpec, (0, CircularReplacer_1.CircularReplacer)())}) has empty type specification`);
                return referencedClass;
            }
            if (referencedClass != null)
                return referencedClass;
            try {
                referencedClass = ValueType_1.ValueType.fromNameInType(ProgrammingLanguage_1.ProgrammingLanguage.typeScript, referenceName.toLowerCase());
            }
            catch (problem) {
                this.logger.error(`valueTypeFromJson(failed) looking for type '${referenceName.toLowerCase()}' ${problem}`);
            }
            if (referencedClass != null)
                return referencedClass;
        }
        return ValueType_1.ValueType.STRING;
    }
    harvestContentType(system, returnContext) {
        if (returnContext == null)
            return ValueType_1.ValueType.VOID;
        if (returnContext['application/json'] != null && returnContext['application/json']['schema'] != null)
            return this.valueTypeFromJson(system, returnContext['application/json']['schema']);
        return ValueType_1.ValueType.STRING;
    }
    harvestParameter(system, proxyClass, method, parameterAsJson) {
        const name = parameterAsJson['name'];
        const required = parameterAsJson['required'];
        const location = parameterAsJson['in'];
        const description = parameterAsJson['description'];
        const schema = parameterAsJson['schema'];
        const valueType = this.valueTypeFromJson(system, schema);
        const parameter = new PathParameter_1.PathParameter(method.fullConstantCaseName, name, description, valueType, 0);
        parameter.required = required;
        parameter.location = location == 'path' ? RestParameterLocation_1.RestParameterLocation.path : location == 'query' ? RestParameterLocation_1.RestParameterLocation.query : RestParameterLocation_1.RestParameterLocation.body;
        let rawType = valueType;
        this.logger.isLevelEnabled('debug')
            ? this.logger.debug(`harvestParameter(${parameterAsJson}) trying to add parameter dependency to ${rawType.name}`)
            : '';
        while (rawType != null && rawType.isCollection)
            rawType = rawType.collectedType;
        if (rawType instanceof information_architecture_1.Class) {
            if (!proxyClass.specifiedDependencies.includes(rawType)) {
                this.logger.isLevelEnabled('debug')
                    ? this.logger.debug(`harvestFromPathAndVerb(${parameterAsJson}) adding parameter type dependency to ${rawType.name}`)
                    : '';
                proxyClass.specifiedDependencies.push(rawType);
            }
        }
        method.addChild(parameter);
    }
    harvestFromPathAndVerb(system, verb, pathUrlSpec, pathDetails) {
        const urlPieces = pathUrlSpec.split('/');
        let index = 0;
        while (urlPieces[index] == '')
            index++;
        const resourceName = urlPieces[index++];
        const pathNamePieces = pathDetails['operationId'].split('_');
        const pathName = pathNamePieces[1];
        if (pathName != null) {
            const summary = pathDetails['summary'];
            const parameters = pathDetails['parameters'];
            const proxyName = SystemComponent_1.SystemComponent.fullConstantCase('api', resourceName);
            let proxyResource = system.descendants[proxyName];
            if (proxyResource == null) {
                proxyResource = new Resource_1.Resource('api', resourceName, `Service proxy class representing the path at ${resourceName}`, SystemComponentType_1.SystemComponentType.clientApiProxy);
                system.addChild(proxyResource);
            }
            let path = proxyResource.paths[pathName];
            if (path == null) {
                path = new Path_1.Path(proxyName, pathName, summary);
                path.httpVerb = verb;
                proxyResource.addChild(path);
            }
            path.urlPath = pathUrlSpec;
            if (pathDetails['requestBody'] != null && pathDetails['requestBody']['content'] != null) {
                const bodyParameterName = 'body';
                const bodyValue = pathDetails['requestBody']['content'];
                const bodyType = this.harvestContentType(system, bodyValue);
                this.logger.isLevelEnabled('debug')
                    ? this.logger.debug(`harvestFromPathAndVerb(${pathUrlSpec}) trying to add body type dependency to ${bodyType.name}`)
                    : '';
                if (bodyType instanceof information_architecture_1.Class) {
                    if (!proxyResource.allDependencies.includes(bodyType)) {
                        this.logger.isLevelEnabled('debug')
                            ? this.logger.debug(`harvestFromPathAndVerb(${pathUrlSpec}) adding body type dependency to ${bodyType.name}`)
                            : '';
                        proxyResource.specifiedDependencies.push(bodyType);
                    }
                }
                else
                    this.logger.isLevelEnabled('debug')
                        ? this.logger.debug(`harvestFromPathAndVerb(${pathUrlSpec}) skipping body type dependency ${JSON.stringify(bodyType, (0, CircularReplacer_1.CircularReplacer)())}`)
                        : '';
                const bodyParameter = new PathParameter_1.PathParameter(path.constantCaseFullName, bodyParameterName, '', bodyType, 0);
                bodyParameter.location = RestParameterLocation_1.RestParameterLocation.body;
                path.addChild(bodyParameter);
            }
            if (parameters != null) {
                parameters.forEach((parameterAsJson) => {
                    if (parameterAsJson['in'] == 'path')
                        this.harvestParameter(system, proxyResource, path, parameterAsJson);
                });
                parameters.forEach((parameterAsJson) => {
                    if (parameterAsJson['in'] == 'query')
                        this.harvestParameter(system, proxyResource, path, parameterAsJson);
                });
            }
            const responses = pathDetails['responses'];
            let responseDetails;
            if (responses['200'] != null)
                responseDetails = responses['200'];
            if (responses['201'] != null)
                responseDetails = responses['201'];
            if (responseDetails != null) {
                const returnsDescription = responseDetails['description'];
                const returnValue = responseDetails['content'];
                const returnType = this.harvestContentType(system, returnValue);
                path.returns = new Variable_1.Variable('ValueSpecification', `${proxyResource.constantCaseFullName}/${pathName}`, 'returns', returnsDescription, returnType, 0);
                let rawReturn = returnType;
                this.logger.isLevelEnabled('debug')
                    ? this.logger.debug(`harvestFromPathAndVerb(${pathUrlSpec}) trying to add return type dependency to ${rawReturn.name}`)
                    : '';
                while (rawReturn != null && rawReturn.isCollection)
                    rawReturn = rawReturn.collectedType;
                if (rawReturn instanceof Resource_1.Resource) {
                    if (!proxyResource.specifiedDependencies.includes(rawReturn)) {
                        this.logger.isLevelEnabled('debug')
                            ? this.logger.debug(`harvestFromPathAndVerb(${pathUrlSpec}) adding return type dependency to ${rawReturn.name}`)
                            : '';
                        proxyResource.specifiedDependencies.push(rawReturn);
                    }
                }
                else
                    this.logger.isLevelEnabled('debug')
                        ? this.logger.debug(`harvestFromPathAndVerb(${pathUrlSpec}) skipping return type dependency ${JSON.stringify(rawReturn, (0, CircularReplacer_1.CircularReplacer)())}`)
                        : '';
            }
        }
    }
    harvestFromPath(system, pathUrlSpec, pathDetails) {
        Object.entries(HttpVerb_1.HttpVerb).forEach((verbEntry) => {
            const verb = verbEntry[1];
            const verbName = verbEntry[0];
            const verbPaths = pathDetails[verbName];
            if (Array.isArray(verbPaths)) {
                verbPaths.forEach((verbPath) => {
                    this.harvestFromPathAndVerb(system, verb, pathUrlSpec, verbPath);
                });
            }
            else if (verbPaths != null)
                this.harvestFromPathAndVerb(system, verb, pathUrlSpec, verbPaths);
        });
    }
    async harvestFromFile(system, fileNameFullPath) {
        try {
            const cwd = sh.pwd();
            const realPath = fs_1.default.realpathSync(`${cwd}/${fileNameFullPath}`);
            this.logger.isLevelEnabled('debug') ? this.logger.debug(`harvestFromFile(${this.name}) loading ${realPath}`) : '';
            const sourceText = await fs_1.default.promises.readFile(fileNameFullPath);
            const openApiAst = JSON.parse(sourceText.toString());
            const paths = openApiAst['paths'];
            Object.keys(paths).forEach((pathUrlSpec) => {
                const pathDetails = paths[pathUrlSpec];
                this.harvestFromPath(system, pathUrlSpec, pathDetails);
            });
        }
        catch (problem) {
            this.logger.error(`harvestFromFile(failed) ${problem}`);
        }
    }
    async _doesConfigurationWork() {
        const sourcePath = this.getConfiguredValue('sourcePath');
        const result = fs_1.default.existsSync(sourcePath);
        return result;
    }
    async buildInternal(system, __component) {
        const result = [];
        const sourcePath = this.getConfiguredValue('sourcePath');
        await this.harvestFromFile(system, sourcePath);
        return result;
    }
}
exports.OpenApiJsonToApiHarvester = OpenApiJsonToApiHarvester;

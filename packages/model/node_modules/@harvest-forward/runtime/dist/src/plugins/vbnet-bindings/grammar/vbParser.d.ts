declare class vbParser {
    static grammarFileName: string;
    static literalNames: (string | null)[];
    static symbolicNames: (string | null)[];
    static ruleNames: string[];
    constructor(input: any);
    _interp: any;
    ruleNames: string[];
    literalNames: (string | null)[];
    symbolicNames: (string | null)[];
    get atn(): any;
    sempred(localctx: any, ruleIndex: any, predIndex: any): any;
    cCExpression_sempred(localctx: any, predIndex: any): any;
    nonArrayTypeName_sempred(localctx: any, predIndex: any): any;
    expression_sempred(localctx: any, predIndex: any): any;
    start(): StartContext;
    state: number | undefined;
    hexDigit(): HexDigitContext;
    decimalDigit(): DecimalDigitContext;
    octalDigit(): OctalDigitContext;
    alphaCharacter(): AlphaCharacterContext;
    booleanLiteral(): BooleanLiteralContext;
    intLiteral(): IntLiteralContext;
    hexLiteral(): HexLiteralContext;
    octalLiteral(): OctalLiteralContext;
    integerLiteral(): IntegerLiteralContext;
    integerLiteralValue(): IntegerLiteralValueContext;
    floatingPointLiteral(): FloatingPointLiteralContext;
    floatingPointLiteralValue(): FloatingPointLiteralValueContext;
    exponent(): ExponentContext;
    sign(): SignContext;
    singleTypeCharacter(): SingleTypeCharacterContext;
    doubleTypeCharacter(): DoubleTypeCharacterContext;
    longTypeCharacter(): LongTypeCharacterContext;
    stringTypeCharacter(): StringTypeCharacterContext;
    integerTypeCharacter(): IntegerTypeCharacterContext;
    decimalTypeCharacter(): DecimalTypeCharacterContext;
    integralTypeCharacter(): IntegralTypeCharacterContext;
    floatingPointTypeCharacter(): FloatingPointTypeCharacterContext;
    monthValue(): MonthValueContext;
    dayValue(): DayValueContext;
    yearValue(): YearValueContext;
    hourValue(): HourValueContext;
    minuteValue(): MinuteValueContext;
    secondValue(): SecondValueContext;
    ampm(): AmpmContext;
    dateValue(): DateValueContext;
    timeValue(): TimeValueContext;
    dateOrTime(): DateOrTimeContext;
    dateLiteral(): DateLiteralContext;
    stringCharacter(): StringCharacterContext;
    stringLiteral(): StringLiteralContext;
    characterLiteral(): CharacterLiteralContext;
    identifierStart(): IdentifierStartContext;
    identifierName(): IdentifierNameContext;
    identifierCharacter(): IdentifierCharacterContext;
    identifier(): IdentifierContext;
    identifierOrKeyword(): IdentifierOrKeywordContext;
    typeCharacter(): TypeCharacterContext;
    literal(): LiteralContext;
    elseIf(): ElseIfContext;
    cCStart(): CCStartContext;
    cCStatement(): CCStatementContext;
    cCExpression(_p: any): CCExpressionContext;
    cCParenthesizedExpression(): CCParenthesizedExpressionContext;
    cCSimpleNameExpression(): CCSimpleNameExpressionContext;
    cCCastExpression(): CCCastExpressionContext;
    cCPlusMinus(): CCPlusMinusContext;
    cCUnaryOperator(): CCUnaryOperatorContext;
    cCBinaryOperator(): CCBinaryOperatorContext;
    cCConditionalExpression(): CCConditionalExpressionContext;
    cCConstantDeclaration(): CCConstantDeclarationContext;
    cCIfGroup(): CCIfGroupContext;
    cCElseIfGroup(): CCElseIfGroupContext;
    cCElseGroup(): CCElseGroupContext;
    regionStart(): RegionStartContext;
    regionStatement(): RegionStatementContext;
    regionGroup(): RegionGroupContext;
    accessModifier(): AccessModifierContext;
    typeParameterList(): TypeParameterListContext;
    typeParameter(): TypeParameterContext;
    varianceModifier(): VarianceModifierContext;
    typeParameterConstraints(): TypeParameterConstraintsContext;
    constraintList(): ConstraintListContext;
    constraint(): ConstraintContext;
    attributes(): AttributesContext;
    attributeBlock(): AttributeBlockContext;
    attributeList(): AttributeListContext;
    attribute(): AttributeContext;
    attributeModifier(): AttributeModifierContext;
    attributeArguments(): AttributeArgumentsContext;
    attributePositionalArgumentList(): AttributePositionalArgumentListContext;
    variablePropertyInitializerList(): VariablePropertyInitializerListContext;
    variablePropertyInitializer(): VariablePropertyInitializerContext;
    attributeArgumentExpression(): AttributeArgumentExpressionContext;
    statementTerminator(): StatementTerminatorContext;
    attributesStatement(): AttributesStatementContext;
    optionStatement(): OptionStatementContext;
    optionExplicitStatement(): OptionExplicitStatementContext;
    onOff(): OnOffContext;
    optionStrictStatement(): OptionStrictStatementContext;
    optionCompareStatement(): OptionCompareStatementContext;
    compareOption(): CompareOptionContext;
    optionInferStatement(): OptionInferStatementContext;
    importsStatement(): ImportsStatementContext;
    importsClauses(): ImportsClausesContext;
    importsClause(): ImportsClauseContext;
    aliasImportsClause(): AliasImportsClauseContext;
    membersImportsClause(): MembersImportsClauseContext;
    xMLNamespaceImportsClause(): XMLNamespaceImportsClauseContext;
    xMLNamespaceValue(): XMLNamespaceValueContext;
    namespaceDeclaration(): NamespaceDeclarationContext;
    namespaceName(): NamespaceNameContext;
    relativeNamespaceName(): RelativeNamespaceNameContext;
    namespaceMemberDeclaration(): NamespaceMemberDeclarationContext;
    typeDeclaration(): TypeDeclarationContext;
    nonModuleDeclaration(): NonModuleDeclarationContext;
    typeName(): TypeNameContext;
    nonArrayTypeName(_p: any): NonArrayTypeNameContext;
    simpleTypeName(): SimpleTypeNameContext;
    qualifiedTypeName(): QualifiedTypeNameContext;
    typeArguments(): TypeArgumentsContext;
    typeArgumentList(): TypeArgumentListContext;
    builtInTypeName(): BuiltInTypeNameContext;
    typeModifier(): TypeModifierContext;
    identifierModifiers(): IdentifierModifiersContext;
    nullableNameModifier(): NullableNameModifierContext;
    typeImplementsClause(): TypeImplementsClauseContext;
    typeImplements(): TypeImplementsContext;
    primitiveTypeName(): PrimitiveTypeNameContext;
    numericTypeName(): NumericTypeNameContext;
    integralTypeName(): IntegralTypeNameContext;
    floatingPointTypeName(): FloatingPointTypeNameContext;
    enumDeclaration(): EnumDeclarationContext;
    enumMemberDeclaration(): EnumMemberDeclarationContext;
    classDeclaration(): ClassDeclarationContext;
    classModifier(): ClassModifierContext;
    classBase(): ClassBaseContext;
    classMemberDeclaration(): ClassMemberDeclarationContext;
    structureDeclaration(): StructureDeclarationContext;
    structureModifier(): StructureModifierContext;
    structMemberDeclaration(): StructMemberDeclarationContext;
    moduleDeclaration(): ModuleDeclarationContext;
    moduleMemberDeclaration(): ModuleMemberDeclarationContext;
    interfaceDeclaration(): InterfaceDeclarationContext;
    interfaceBase(): InterfaceBaseContext;
    interfaceBases(): InterfaceBasesContext;
    interfaceMemberDeclaration(): InterfaceMemberDeclarationContext;
    arrayTypeName(): ArrayTypeNameContext;
    arrayTypeModifiers(): ArrayTypeModifiersContext;
    arrayTypeModifier(): ArrayTypeModifierContext;
    rankList(): RankListContext;
    arrayNameModifier(): ArrayNameModifierContext;
    delegateDeclaration(): DelegateDeclarationContext;
    methodSignature(): MethodSignatureContext;
    implementsClause(): ImplementsClauseContext;
    implementsList(): ImplementsListContext;
    interfaceMemberSpecifier(): InterfaceMemberSpecifierContext;
    methodMemberDeclaration(): MethodMemberDeclarationContext;
    interfaceMethodMemberDeclaration(): InterfaceMethodMemberDeclarationContext;
    methodDeclaration(): MethodDeclarationContext;
    interfaceMethodDeclaration(): InterfaceMethodDeclarationContext;
    subSignature(): SubSignatureContext;
    functionSignature(): FunctionSignatureContext;
    subDeclaration(): SubDeclarationContext;
    mustOverrideSubDeclaration(): MustOverrideSubDeclarationContext;
    interfaceSubDeclaration(): InterfaceSubDeclarationContext;
    functionDeclaration(): FunctionDeclarationContext;
    mustOverrideFunctionDeclaration(): MustOverrideFunctionDeclarationContext;
    interfaceFunctionDeclaration(): InterfaceFunctionDeclarationContext;
    procedureModifier(): ProcedureModifierContext;
    mustOverrideProcedureModifier(): MustOverrideProcedureModifierContext;
    interfaceProcedureModifier(): InterfaceProcedureModifierContext;
    handlesOrImplements(): HandlesOrImplementsContext;
    externalMethodDeclaration(): ExternalMethodDeclarationContext;
    externalSubDeclaration(): ExternalSubDeclarationContext;
    externalFunctionDeclaration(): ExternalFunctionDeclarationContext;
    externalMethodModifier(): ExternalMethodModifierContext;
    charsetModifier(): CharsetModifierContext;
    libraryClause(): LibraryClauseContext;
    aliasClause(): AliasClauseContext;
    parameterList(): ParameterListContext;
    parameter(): ParameterContext;
    parameterModifier(): ParameterModifierContext;
    parameterIdentifier(): ParameterIdentifierContext;
    handlesClause(): HandlesClauseContext;
    eventHandlesList(): EventHandlesListContext;
    eventMemberSpecifier(): EventMemberSpecifierContext;
    constructorMemberDeclaration(): ConstructorMemberDeclarationContext;
    constructorModifier(): ConstructorModifierContext;
    eventMemberDeclaration(): EventMemberDeclarationContext;
    regularEventMemberDeclaration(): RegularEventMemberDeclarationContext;
    interfaceEventMemberDeclaration(): InterfaceEventMemberDeclarationContext;
    parametersOrType(): ParametersOrTypeContext;
    eventModifiers(): EventModifiersContext;
    interfaceEventModifiers(): InterfaceEventModifiersContext;
    customEventMemberDeclaration(): CustomEventMemberDeclarationContext;
    eventAccessorDeclaration(): EventAccessorDeclarationContext;
    addHandlerDeclaration(): AddHandlerDeclarationContext;
    removeHandlerDeclaration(): RemoveHandlerDeclarationContext;
    raiseEventDeclaration(): RaiseEventDeclarationContext;
    constantMemberDeclaration(): ConstantMemberDeclarationContext;
    constantModifier(): ConstantModifierContext;
    constantDeclarators(): ConstantDeclaratorsContext;
    constantDeclarator(): ConstantDeclaratorContext;
    variableMemberDeclaration(): VariableMemberDeclarationContext;
    variableModifier(): VariableModifierContext;
    variableDeclarators(): VariableDeclaratorsContext;
    variableDeclarator(): VariableDeclaratorContext;
    variableIdentifiers(): VariableIdentifiersContext;
    variableIdentifier(): VariableIdentifierContext;
    arraySizeInitializationModifier(): ArraySizeInitializationModifierContext;
    boundList(): BoundListContext;
    bound(): BoundContext;
    propertyMemberDeclaration(): PropertyMemberDeclarationContext;
    propertySignature(): PropertySignatureContext;
    regularPropertyMemberDeclaration(): RegularPropertyMemberDeclarationContext;
    mustOverridePropertyMemberDeclaration(): MustOverridePropertyMemberDeclarationContext;
    autoPropertyMemberDeclaration(): AutoPropertyMemberDeclarationContext;
    interfacePropertyMemberDeclaration(): InterfacePropertyMemberDeclarationContext;
    autoPropertyModifier(): AutoPropertyModifierContext;
    propertyModifier(): PropertyModifierContext;
    mustOverridePropertyModifier(): MustOverridePropertyModifierContext;
    interfacePropertyModifier(): InterfacePropertyModifierContext;
    propertyAccessorDeclaration(): PropertyAccessorDeclarationContext;
    propertyGetDeclaration(): PropertyGetDeclarationContext;
    propertySetDeclaration(): PropertySetDeclarationContext;
    operatorDeclaration(): OperatorDeclarationContext;
    operatorModifier(): OperatorModifierContext;
    overloadableOperator(): OverloadableOperatorContext;
    statement(): StatementContext;
    block(): BlockContext;
    labelDeclarationStatement(): LabelDeclarationStatementContext;
    labelName(): LabelNameContext;
    statements(): StatementsContext;
    localDeclarationStatement(): LocalDeclarationStatementContext;
    localModifier(): LocalModifierContext;
    withStatement(): WithStatementContext;
    syncLockStatement(): SyncLockStatementContext;
    eventStatement(): EventStatementContext;
    raiseEventStatement(): RaiseEventStatementContext;
    addHandlerStatement(): AddHandlerStatementContext;
    removeHandlerStatement(): RemoveHandlerStatementContext;
    assignmentStatement(): AssignmentStatementContext;
    regularAssignmentStatement(): RegularAssignmentStatementContext;
    compoundAssignmentStatement(): CompoundAssignmentStatementContext;
    compoundBinaryOperator(): CompoundBinaryOperatorContext;
    midAssignmentStatement(): MidAssignmentStatementContext;
    invocationStatement(): InvocationStatementContext;
    conditionalStatement(): ConditionalStatementContext;
    ifStatement(): IfStatementContext;
    blockIfStatement(): BlockIfStatementContext;
    elseIfStatement(): ElseIfStatementContext;
    elseStatement(): ElseStatementContext;
    lineIfThenStatement(): LineIfThenStatementContext;
    selectStatement(): SelectStatementContext;
    caseStatement(): CaseStatementContext;
    caseClauses(): CaseClausesContext;
    caseClause(): CaseClauseContext;
    comparisonOperator(): ComparisonOperatorContext;
    caseElseStatement(): CaseElseStatementContext;
    loopStatement(): LoopStatementContext;
    whileStatement(): WhileStatementContext;
    doLoopStatement(): DoLoopStatementContext;
    doTopLoopStatement(): DoTopLoopStatementContext;
    doBottomLoopStatement(): DoBottomLoopStatementContext;
    whileOrUntil(): WhileOrUntilContext;
    forStatement(): ForStatementContext;
    loopControlVariable(): LoopControlVariableContext;
    nextExpressionList(): NextExpressionListContext;
    forEachStatement(): ForEachStatementContext;
    errorHandlingStatement(): ErrorHandlingStatementContext;
    structuredErrorStatement(): StructuredErrorStatementContext;
    tryStatement(): TryStatementContext;
    finallyStatement(): FinallyStatementContext;
    catchStatement(): CatchStatementContext;
    throwStatement(): ThrowStatementContext;
    unstructuredErrorStatement(): UnstructuredErrorStatementContext;
    errorStatement(): ErrorStatementContext;
    onErrorStatement(): OnErrorStatementContext;
    errorClause(): ErrorClauseContext;
    resumeStatement(): ResumeStatementContext;
    resumeClause(): ResumeClauseContext;
    branchStatement(): BranchStatementContext;
    goToStatement(): GoToStatementContext;
    exitStatement(): ExitStatementContext;
    exitKind(): ExitKindContext;
    continueStatement(): ContinueStatementContext;
    continueKind(): ContinueKindContext;
    stopStatement(): StopStatementContext;
    endStatement(): EndStatementContext;
    returnStatement(): ReturnStatementContext;
    arrayHandlingStatement(): ArrayHandlingStatementContext;
    redimStatement(): RedimStatementContext;
    redimClauses(): RedimClausesContext;
    redimClause(): RedimClauseContext;
    eraseStatement(): EraseStatementContext;
    eraseExpressions(): EraseExpressionsContext;
    usingStatement(): UsingStatementContext;
    usingResources(): UsingResourcesContext;
    awaitStatement(): AwaitStatementContext;
    yieldStatement(): YieldStatementContext;
    expression(_p: any): ExpressionContext;
    memberAccessBase(): MemberAccessBaseContext;
    constantExpression(): ConstantExpressionContext;
    simpleExpression(): SimpleExpressionContext;
    literalExpression(): LiteralExpressionContext;
    parenthesizedExpression(): ParenthesizedExpressionContext;
    instanceExpression(): InstanceExpressionContext;
    simpleNameExpression(): SimpleNameExpressionContext;
    addressOfExpression(): AddressOfExpressionContext;
    getTypeExpression(): GetTypeExpressionContext;
    getTypeTypeName(): GetTypeTypeNameContext;
    qualifiedOpenTypeName(): QualifiedOpenTypeNameContext;
    typeArityList(): TypeArityListContext;
    commaList(): CommaListContext;
    typeOfIsExpression(): TypeOfIsExpressionContext;
    getXmlNamespaceExpression(): GetXmlNamespaceExpressionContext;
    argumentList(): ArgumentListContext;
    positionalArgumentList(): PositionalArgumentListContext;
    namedArgumentList(): NamedArgumentListContext;
    newExpression(): NewExpressionContext;
    objectCreationExpression(): ObjectCreationExpressionContext;
    objectCreationExpressionInitializer(): ObjectCreationExpressionInitializerContext;
    objectMemberInitializer(): ObjectMemberInitializerContext;
    fieldInitializerList(): FieldInitializerListContext;
    fieldInitializer(): FieldInitializerContext;
    objectCollectionInitializer(): ObjectCollectionInitializerContext;
    collectionInitializer(): CollectionInitializerContext;
    collectionElementList(): CollectionElementListContext;
    collectionElement(): CollectionElementContext;
    arrayExpression(): ArrayExpressionContext;
    arrayCreationExpression(): ArrayCreationExpressionContext;
    arrayLiteralExpression(): ArrayLiteralExpressionContext;
    anonymousObjectCreationExpression(): AnonymousObjectCreationExpressionContext;
    castExpression(): CastExpressionContext;
    castTarget(): CastTargetContext;
    unaryPlusExpression(): UnaryPlusExpressionContext;
    unaryMinusExpression(): UnaryMinusExpressionContext;
    booleanExpression(): BooleanExpressionContext;
    lambdaExpression(): LambdaExpressionContext;
    singleLineLambda(): SingleLineLambdaContext;
    multiLineLambda(): MultiLineLambdaContext;
    multiLineFunctionLambda(): MultiLineFunctionLambdaContext;
    multiLineSubLambda(): MultiLineSubLambdaContext;
    lambdaModifier(): LambdaModifierContext;
    queryExpression(): QueryExpressionContext;
    fromOrAggregateQueryOperator(): FromOrAggregateQueryOperatorContext;
    queryOperator(): QueryOperatorContext;
    joinOrGroupJoinQueryOperator(): JoinOrGroupJoinQueryOperatorContext;
    collectionRangeVariableDeclarationList(): CollectionRangeVariableDeclarationListContext;
    collectionRangeVariableDeclaration(): CollectionRangeVariableDeclarationContext;
    expressionRangeVariableDeclarationList(): ExpressionRangeVariableDeclarationListContext;
    expressionRangeVariableDeclaration(): ExpressionRangeVariableDeclarationContext;
    fromQueryOperator(): FromQueryOperatorContext;
    joinQueryOperator(): JoinQueryOperatorContext;
    joinConditionList(): JoinConditionListContext;
    joinCondition(): JoinConditionContext;
    letQueryOperator(): LetQueryOperatorContext;
    selectQueryOperator(): SelectQueryOperatorContext;
    distinctQueryOperator(): DistinctQueryOperatorContext;
    whereQueryOperator(): WhereQueryOperatorContext;
    partitionQueryOperator(): PartitionQueryOperatorContext;
    orderByQueryOperator(): OrderByQueryOperatorContext;
    orderExpressionList(): OrderExpressionListContext;
    orderExpression(): OrderExpressionContext;
    ordering(): OrderingContext;
    groupByQueryOperator(): GroupByQueryOperatorContext;
    aggregateQueryOperator(): AggregateQueryOperatorContext;
    groupJoinQueryOperator(): GroupJoinQueryOperatorContext;
    conditionalExpression(): ConditionalExpressionContext;
    xMLLiteralExpression(): XMLLiteralExpressionContext;
    xMLEmbeddedExpression(): XMLEmbeddedExpressionContext;
    xMLDocument(): XMLDocumentContext;
    xMLDocumentPrologue(): XMLDocumentPrologueContext;
    xMLVersion(): XMLVersionContext;
    xMLVersionNumberValue(): XMLVersionNumberValueContext;
    xMLEncoding(): XMLEncodingContext;
    xMLEncodingNameValue(): XMLEncodingNameValueContext;
    xMLEncodingName(): XMLEncodingNameContext;
    xMLEncodingNameCharacter(): XMLEncodingNameCharacterContext;
    xMLStandalone(): XMLStandaloneContext;
    xMLYesNoValue(): XMLYesNoValueContext;
    xMLYesNo(): XMLYesNoContext;
    xMLMisc(): XMLMiscContext;
    xMLDocumentBody(): XMLDocumentBodyContext;
    xMLElement(): XMLElementContext;
    xMLEmptyElement(): XMLEmptyElementContext;
    xMLElementStart(): XMLElementStartContext;
    xMLElementEnd(): XMLElementEndContext;
    xMLContent(): XMLContentContext;
    xMLNestedContent(): XMLNestedContentContext;
    xMLAttribute(): XMLAttributeContext;
    xMLAttributeName(): XMLAttributeNameContext;
    xMLAttributeValue(): XMLAttributeValueContext;
    xMLAttributeDoubleQuoteValueCharacter(): XMLAttributeDoubleQuoteValueCharacterContext;
    xMLAttributeSingleQuoteValueCharacter(): XMLAttributeSingleQuoteValueCharacterContext;
    xMLReference(): XMLReferenceContext;
    xMLEntityReference(): XMLEntityReferenceContext;
    xMLCharacterReference(): XMLCharacterReferenceContext;
    xMLNamespaceAttributeName(): XMLNamespaceAttributeNameContext;
    xMLPrefixedNamespaceAttributeName(): XMLPrefixedNamespaceAttributeNameContext;
    xMLDefaultNamespaceAttributeName(): XMLDefaultNamespaceAttributeNameContext;
    xMLNamespaceName(): XMLNamespaceNameContext;
    xMLNamespaceNameCharacter(): XMLNamespaceNameCharacterContext;
    xMLQualifiedNameOrExpression(): XMLQualifiedNameOrExpressionContext;
    xMLQualifiedName(): XMLQualifiedNameContext;
    xMLPrefixedName(): XMLPrefixedNameContext;
    xMLUnprefixedName(): XMLUnprefixedNameContext;
    xMLProcessingInstruction(): XMLProcessingInstructionContext;
    xMLComment(): XMLCommentContext;
    xMLCDATASection(): XMLCDATASectionContext;
    awaitOperatorExpression(): AwaitOperatorExpressionContext;
}
declare namespace vbParser {
    export const EOF: any;
    export const ADDHANDLER: number;
    export const ADDRESSOF: number;
    export const AGGREGATE: number;
    export const ALIAS: number;
    export const AND: number;
    export const ANDALSO: number;
    export const ANSI: number;
    export const AS: number;
    export const ASCENDING: number;
    export const ASSEMBLY: number;
    export const ASYNC: number;
    export const AUTO: number;
    export const AWAIT: number;
    export const BINARY: number;
    export const BOOLEAN: number;
    export const BY: number;
    export const BYREF: number;
    export const BYTE: number;
    export const BYVAL: number;
    export const CALL: number;
    export const CASE: number;
    export const CATCH: number;
    export const CBOOL: number;
    export const CBYTE: number;
    export const CCHAR: number;
    export const CDATE: number;
    export const CDBL: number;
    export const CDEC: number;
    export const CHAR: number;
    export const CINT: number;
    export const CLASS: number;
    export const CLNG: number;
    export const COBJ: number;
    export const COMPARE: number;
    export const CONST: number;
    export const CONTINUE: number;
    export const CSBYTE: number;
    export const CSHORT: number;
    export const CSNG: number;
    export const CSTR: number;
    export const CTYPE: number;
    export const CUINT: number;
    export const CULNG: number;
    export const CUSHORT: number;
    export const CUSTOM: number;
    export const DATE: number;
    export const DECIMAL: number;
    export const DECLARE: number;
    export const DEFAULT: number;
    export const DELEGATE: number;
    export const DESCENDING: number;
    export const DIM: number;
    export const DIRECTCAST: number;
    export const DISTINCT: number;
    export const DO: number;
    export const DOUBLE: number;
    export const EACH: number;
    export const ELSE: number;
    export const ELSEIF: number;
    export const END: number;
    export const ENUM: number;
    export const EQUALSKEYWORD: number;
    export const ERASE: number;
    export const ERROR: number;
    export const EVENT: number;
    export const EXIT: number;
    export const EXPLICIT: number;
    export const FINALLY: number;
    export const FOR: number;
    export const FRIEND: number;
    export const FROM: number;
    export const FUNCTION: number;
    export const GET: number;
    export const GETTYPE: number;
    export const GLOBAL: number;
    export const GOTO: number;
    export const GROUP: number;
    export const HANDLES: number;
    export const IF: number;
    export const IMPLEMENTS: number;
    export const IMPORTS: number;
    export const IN: number;
    export const INFER: number;
    export const INHERITS: number;
    export const INTEGER: number;
    export const INTERFACE: number;
    export const INTO: number;
    export const IS: number;
    export const IS_FALSE: number;
    export const IS_TRUE: number;
    export const ISNOT: number;
    export const ITERATOR: number;
    export const JOIN: number;
    export const KEY: number;
    export const LET: number;
    export const LIB: number;
    export const LIKE: number;
    export const LONG: number;
    export const LOOP: number;
    export const ME: number;
    export const MID: number;
    export const MOD: number;
    export const MODULE: number;
    export const MUST_INHERIT: number;
    export const MUSTOVERRIDE: number;
    export const MYBASE: number;
    export const MYCLASS: number;
    export const NAMESPACE: number;
    export const NARROWING: number;
    export const NEW: number;
    export const NEXT: number;
    export const NOT: number;
    export const NOT_INHERITABLE: number;
    export const NOTHING: number;
    export const NOTOVERRIDABLE: number;
    export const OBJECT: number;
    export const OF: number;
    export const OFF: number;
    export const ON: number;
    export const OPERATORKEYWORD: number;
    export const OPTION: number;
    export const OPTIONAL: number;
    export const OR: number;
    export const ORDER: number;
    export const ORELSE: number;
    export const OUT: number;
    export const OVERLOADS: number;
    export const OVERRIDABLE: number;
    export const OVERRIDES: number;
    export const PARAM_ARRAY: number;
    export const PARTIAL: number;
    export const PRESERVE: number;
    export const PRIVATE: number;
    export const PROPERTY: number;
    export const PROTECTED: number;
    export const PUBLIC: number;
    export const RAISEEVENT: number;
    export const READONLY: number;
    export const REDIM: number;
    export const REGION: number;
    export const REM: number;
    export const REMOVEHANDLER: number;
    export const RESUME: number;
    export const RETURN: number;
    export const SBYTE: number;
    export const SELECT: number;
    export const SET: number;
    export const SHADOWS: number;
    export const SHARED: number;
    export const SHORT: number;
    export const SINGLE: number;
    export const SKIP_KEYWORD: number;
    export const STATIC: number;
    export const STEP: number;
    export const STOP: number;
    export const STRICT: number;
    export const STRING: number;
    export const STRUCTURE: number;
    export const SUB: number;
    export const SYNCLOCK: number;
    export const TAKE: number;
    export const TEXT: number;
    export const THEN: number;
    export const THROW: number;
    export const TO: number;
    export const TRY: number;
    export const TRYCAST: number;
    export const TYPEOF: number;
    export const UINTEGER: number;
    export const ULONG: number;
    export const UNICODE: number;
    export const UNTIL: number;
    export const USHORT: number;
    export const USING: number;
    export const When: number;
    export const WHEN: number;
    export const WHERE: number;
    export const WHILE: number;
    export const WIDENING: number;
    export const WITH: number;
    export const WITH_EVENTS: number;
    export const WRITEONLY: number;
    export const XOR: number;
    export const YIELD: number;
    export const GET_XML_NAMESPACE: number;
    export const XML9: number;
    export const XMLA: number;
    export const XMLD: number;
    export const XMLLetter: number;
    export const XMLDigit: number;
    export const XMLCombiningCharacter: number;
    export const XMLExtender: number;
    export const XMLString: number;
    export const XMLWhitespace: number;
    export const XMLWhitespaceCharacter: number;
    export const XMLProcessingTarget: number;
    export const XMLProcessingValue: number;
    export const XMLCharacter: number;
    export const XMLLatinAlphaCharacter: number;
    export const XMLNumericCharacter: number;
    export const XMLHexNumericCharacter: number;
    export const XMLPeriodCharacter: number;
    export const XMLUnderscoreCharacter: number;
    export const XMLDashCharacter: number;
    export const XMLCommentCharacter: number;
    export const XMLCDATASectionString: number;
    export const XMLCharacterData: number;
    export const XMLCharacterDataString: number;
    export const VERSION: number;
    export const XML: number;
    export const CDATA: number;
    export const XMLNS: number;
    export const ENCODING: number;
    export const STANDALONE: number;
    export const YES: number;
    export const NO: number;
    export const XMLEntityName: number;
    export const XMLNamespaceNameStartCharacter: number;
    export const XMLNotDoubleQuote: number;
    export const XMLNotSingleQuote: number;
    export const ZERO: number;
    export const ONE: number;
    export const TWO: number;
    export const THREE: number;
    export const FOUR: number;
    export const FIVE: number;
    export const SIX: number;
    export const SEVEN: number;
    export const EIGHT: number;
    export const NINE: number;
    export const LINE_TERMINATOR: number;
    export const SINGLE_QUOTE_CHAR: number;
    export const DOUBLE_QUOTE_CHARACTER: number;
    export const QUESTION_MARK: number;
    export const COMMA: number;
    export const ASTERISK: number;
    export const EQUALS: number;
    export const LEFT_ARROW: number;
    export const RIGHT_ARROW: number;
    export const SLASH: number;
    export const DOUBLE_BACK_SLASH: number;
    export const CARET: number;
    export const COLON: number;
    export const SEMICOLON: number;
    export const AMPERSAND: number;
    export const EXCLAMATION: number;
    export const POUND: number;
    export const UNDERSCORE: number;
    export const PERIOD: number;
    export const MINUS: number;
    export const PLUS: number;
    export const PERCENT: number;
    export const DOLLAR: number;
    export const AT: number;
    export const LEFT_PAREN: number;
    export const RIGHT_PAREN: number;
    export const LEFT_BRACE: number;
    export const RIGHT_BRACE: number;
    export const LEFT_SQUARE_BRACKET: number;
    export const RIGHT_SQUARE_BRACKET: number;
    export const SHORT_CHARACTER: number;
    export const UNSIGNED_SHORT_CHARACTER: number;
    export const INTEGER_CHARACTER: number;
    export const UNSIGNED_INTEGER_CHARACTER: number;
    export const LONG_CHARACTER: number;
    export const UNSIGNED_LONG_CHARACTER: number;
    export const SINGLE_CHARACTER: number;
    export const DOUBLE_CHARACTER: number;
    export const DECIMAL_CHARACTER: number;
    export const A: number;
    export const B: number;
    export const C: number;
    export const D: number;
    export const E: number;
    export const F: number;
    export const G: number;
    export const H: number;
    export const I: number;
    export const J: number;
    export const K: number;
    export const L: number;
    export const M: number;
    export const N: number;
    export const O: number;
    export const P: number;
    export const Q: number;
    export const R: number;
    export const S: number;
    export const T: number;
    export const U: number;
    export const V: number;
    export const W: number;
    export const X: number;
    export const Y: number;
    export const Z: number;
    export const WS: number;
    export const RULE_start: number;
    export const RULE_hexDigit: number;
    export const RULE_decimalDigit: number;
    export const RULE_octalDigit: number;
    export const RULE_alphaCharacter: number;
    export const RULE_booleanLiteral: number;
    export const RULE_intLiteral: number;
    export const RULE_hexLiteral: number;
    export const RULE_octalLiteral: number;
    export const RULE_integerLiteral: number;
    export const RULE_integerLiteralValue: number;
    export const RULE_floatingPointLiteral: number;
    export const RULE_floatingPointLiteralValue: number;
    export const RULE_exponent: number;
    export const RULE_sign: number;
    export const RULE_singleTypeCharacter: number;
    export const RULE_doubleTypeCharacter: number;
    export const RULE_longTypeCharacter: number;
    export const RULE_stringTypeCharacter: number;
    export const RULE_integerTypeCharacter: number;
    export const RULE_decimalTypeCharacter: number;
    export const RULE_integralTypeCharacter: number;
    export const RULE_floatingPointTypeCharacter: number;
    export const RULE_monthValue: number;
    export const RULE_dayValue: number;
    export const RULE_yearValue: number;
    export const RULE_hourValue: number;
    export const RULE_minuteValue: number;
    export const RULE_secondValue: number;
    export const RULE_ampm: number;
    export const RULE_dateValue: number;
    export const RULE_timeValue: number;
    export const RULE_dateOrTime: number;
    export const RULE_dateLiteral: number;
    export const RULE_stringCharacter: number;
    export const RULE_stringLiteral: number;
    export const RULE_characterLiteral: number;
    export const RULE_identifierStart: number;
    export const RULE_identifierName: number;
    export const RULE_identifierCharacter: number;
    export const RULE_identifier: number;
    export const RULE_identifierOrKeyword: number;
    export const RULE_typeCharacter: number;
    export const RULE_literal: number;
    export const RULE_elseIf: number;
    export const RULE_cCStart: number;
    export const RULE_cCStatement: number;
    export const RULE_cCExpression: number;
    export const RULE_cCParenthesizedExpression: number;
    export const RULE_cCSimpleNameExpression: number;
    export const RULE_cCCastExpression: number;
    export const RULE_cCPlusMinus: number;
    export const RULE_cCUnaryOperator: number;
    export const RULE_cCBinaryOperator: number;
    export const RULE_cCConditionalExpression: number;
    export const RULE_cCConstantDeclaration: number;
    export const RULE_cCIfGroup: number;
    export const RULE_cCElseIfGroup: number;
    export const RULE_cCElseGroup: number;
    export const RULE_regionStart: number;
    export const RULE_regionStatement: number;
    export const RULE_regionGroup: number;
    export const RULE_accessModifier: number;
    export const RULE_typeParameterList: number;
    export const RULE_typeParameter: number;
    export const RULE_varianceModifier: number;
    export const RULE_typeParameterConstraints: number;
    export const RULE_constraintList: number;
    export const RULE_constraint: number;
    export const RULE_attributes: number;
    export const RULE_attributeBlock: number;
    export const RULE_attributeList: number;
    export const RULE_attribute: number;
    export const RULE_attributeModifier: number;
    export const RULE_attributeArguments: number;
    export const RULE_attributePositionalArgumentList: number;
    export const RULE_variablePropertyInitializerList: number;
    export const RULE_variablePropertyInitializer: number;
    export const RULE_attributeArgumentExpression: number;
    export const RULE_statementTerminator: number;
    export const RULE_attributesStatement: number;
    export const RULE_optionStatement: number;
    export const RULE_optionExplicitStatement: number;
    export const RULE_onOff: number;
    export const RULE_optionStrictStatement: number;
    export const RULE_optionCompareStatement: number;
    export const RULE_compareOption: number;
    export const RULE_optionInferStatement: number;
    export const RULE_importsStatement: number;
    export const RULE_importsClauses: number;
    export const RULE_importsClause: number;
    export const RULE_aliasImportsClause: number;
    export const RULE_membersImportsClause: number;
    export const RULE_xMLNamespaceImportsClause: number;
    export const RULE_xMLNamespaceValue: number;
    export const RULE_namespaceDeclaration: number;
    export const RULE_namespaceName: number;
    export const RULE_relativeNamespaceName: number;
    export const RULE_namespaceMemberDeclaration: number;
    export const RULE_typeDeclaration: number;
    export const RULE_nonModuleDeclaration: number;
    export const RULE_typeName: number;
    export const RULE_nonArrayTypeName: number;
    export const RULE_simpleTypeName: number;
    export const RULE_qualifiedTypeName: number;
    export const RULE_typeArguments: number;
    export const RULE_typeArgumentList: number;
    export const RULE_builtInTypeName: number;
    export const RULE_typeModifier: number;
    export const RULE_identifierModifiers: number;
    export const RULE_nullableNameModifier: number;
    export const RULE_typeImplementsClause: number;
    export const RULE_typeImplements: number;
    export const RULE_primitiveTypeName: number;
    export const RULE_numericTypeName: number;
    export const RULE_integralTypeName: number;
    export const RULE_floatingPointTypeName: number;
    export const RULE_enumDeclaration: number;
    export const RULE_enumMemberDeclaration: number;
    export const RULE_classDeclaration: number;
    export const RULE_classModifier: number;
    export const RULE_classBase: number;
    export const RULE_classMemberDeclaration: number;
    export const RULE_structureDeclaration: number;
    export const RULE_structureModifier: number;
    export const RULE_structMemberDeclaration: number;
    export const RULE_moduleDeclaration: number;
    export const RULE_moduleMemberDeclaration: number;
    export const RULE_interfaceDeclaration: number;
    export const RULE_interfaceBase: number;
    export const RULE_interfaceBases: number;
    export const RULE_interfaceMemberDeclaration: number;
    export const RULE_arrayTypeName: number;
    export const RULE_arrayTypeModifiers: number;
    export const RULE_arrayTypeModifier: number;
    export const RULE_rankList: number;
    export const RULE_arrayNameModifier: number;
    export const RULE_delegateDeclaration: number;
    export const RULE_methodSignature: number;
    export const RULE_implementsClause: number;
    export const RULE_implementsList: number;
    export const RULE_interfaceMemberSpecifier: number;
    export const RULE_methodMemberDeclaration: number;
    export const RULE_interfaceMethodMemberDeclaration: number;
    export const RULE_methodDeclaration: number;
    export const RULE_interfaceMethodDeclaration: number;
    export const RULE_subSignature: number;
    export const RULE_functionSignature: number;
    export const RULE_subDeclaration: number;
    export const RULE_mustOverrideSubDeclaration: number;
    export const RULE_interfaceSubDeclaration: number;
    export const RULE_functionDeclaration: number;
    export const RULE_mustOverrideFunctionDeclaration: number;
    export const RULE_interfaceFunctionDeclaration: number;
    export const RULE_procedureModifier: number;
    export const RULE_mustOverrideProcedureModifier: number;
    export const RULE_interfaceProcedureModifier: number;
    export const RULE_handlesOrImplements: number;
    export const RULE_externalMethodDeclaration: number;
    export const RULE_externalSubDeclaration: number;
    export const RULE_externalFunctionDeclaration: number;
    export const RULE_externalMethodModifier: number;
    export const RULE_charsetModifier: number;
    export const RULE_libraryClause: number;
    export const RULE_aliasClause: number;
    export const RULE_parameterList: number;
    export const RULE_parameter: number;
    export const RULE_parameterModifier: number;
    export const RULE_parameterIdentifier: number;
    export const RULE_handlesClause: number;
    export const RULE_eventHandlesList: number;
    export const RULE_eventMemberSpecifier: number;
    export const RULE_constructorMemberDeclaration: number;
    export const RULE_constructorModifier: number;
    export const RULE_eventMemberDeclaration: number;
    export const RULE_regularEventMemberDeclaration: number;
    export const RULE_interfaceEventMemberDeclaration: number;
    export const RULE_parametersOrType: number;
    export const RULE_eventModifiers: number;
    export const RULE_interfaceEventModifiers: number;
    export const RULE_customEventMemberDeclaration: number;
    export const RULE_eventAccessorDeclaration: number;
    export const RULE_addHandlerDeclaration: number;
    export const RULE_removeHandlerDeclaration: number;
    export const RULE_raiseEventDeclaration: number;
    export const RULE_constantMemberDeclaration: number;
    export const RULE_constantModifier: number;
    export const RULE_constantDeclarators: number;
    export const RULE_constantDeclarator: number;
    export const RULE_variableMemberDeclaration: number;
    export const RULE_variableModifier: number;
    export const RULE_variableDeclarators: number;
    export const RULE_variableDeclarator: number;
    export const RULE_variableIdentifiers: number;
    export const RULE_variableIdentifier: number;
    export const RULE_arraySizeInitializationModifier: number;
    export const RULE_boundList: number;
    export const RULE_bound: number;
    export const RULE_propertyMemberDeclaration: number;
    export const RULE_propertySignature: number;
    export const RULE_regularPropertyMemberDeclaration: number;
    export const RULE_mustOverridePropertyMemberDeclaration: number;
    export const RULE_autoPropertyMemberDeclaration: number;
    export const RULE_interfacePropertyMemberDeclaration: number;
    export const RULE_autoPropertyModifier: number;
    export const RULE_propertyModifier: number;
    export const RULE_mustOverridePropertyModifier: number;
    export const RULE_interfacePropertyModifier: number;
    export const RULE_propertyAccessorDeclaration: number;
    export const RULE_propertyGetDeclaration: number;
    export const RULE_propertySetDeclaration: number;
    export const RULE_operatorDeclaration: number;
    export const RULE_operatorModifier: number;
    export const RULE_overloadableOperator: number;
    export const RULE_statement: number;
    export const RULE_block: number;
    export const RULE_labelDeclarationStatement: number;
    export const RULE_labelName: number;
    export const RULE_statements: number;
    export const RULE_localDeclarationStatement: number;
    export const RULE_localModifier: number;
    export const RULE_withStatement: number;
    export const RULE_syncLockStatement: number;
    export const RULE_eventStatement: number;
    export const RULE_raiseEventStatement: number;
    export const RULE_addHandlerStatement: number;
    export const RULE_removeHandlerStatement: number;
    export const RULE_assignmentStatement: number;
    export const RULE_regularAssignmentStatement: number;
    export const RULE_compoundAssignmentStatement: number;
    export const RULE_compoundBinaryOperator: number;
    export const RULE_midAssignmentStatement: number;
    export const RULE_invocationStatement: number;
    export const RULE_conditionalStatement: number;
    export const RULE_ifStatement: number;
    export const RULE_blockIfStatement: number;
    export const RULE_elseIfStatement: number;
    export const RULE_elseStatement: number;
    export const RULE_lineIfThenStatement: number;
    export const RULE_selectStatement: number;
    export const RULE_caseStatement: number;
    export const RULE_caseClauses: number;
    export const RULE_caseClause: number;
    export const RULE_comparisonOperator: number;
    export const RULE_caseElseStatement: number;
    export const RULE_loopStatement: number;
    export const RULE_whileStatement: number;
    export const RULE_doLoopStatement: number;
    export const RULE_doTopLoopStatement: number;
    export const RULE_doBottomLoopStatement: number;
    export const RULE_whileOrUntil: number;
    export const RULE_forStatement: number;
    export const RULE_loopControlVariable: number;
    export const RULE_nextExpressionList: number;
    export const RULE_forEachStatement: number;
    export const RULE_errorHandlingStatement: number;
    export const RULE_structuredErrorStatement: number;
    export const RULE_tryStatement: number;
    export const RULE_finallyStatement: number;
    export const RULE_catchStatement: number;
    export const RULE_throwStatement: number;
    export const RULE_unstructuredErrorStatement: number;
    export const RULE_errorStatement: number;
    export const RULE_onErrorStatement: number;
    export const RULE_errorClause: number;
    export const RULE_resumeStatement: number;
    export const RULE_resumeClause: number;
    export const RULE_branchStatement: number;
    export const RULE_goToStatement: number;
    export const RULE_exitStatement: number;
    export const RULE_exitKind: number;
    export const RULE_continueStatement: number;
    export const RULE_continueKind: number;
    export const RULE_stopStatement: number;
    export const RULE_endStatement: number;
    export const RULE_returnStatement: number;
    export const RULE_arrayHandlingStatement: number;
    export const RULE_redimStatement: number;
    export const RULE_redimClauses: number;
    export const RULE_redimClause: number;
    export const RULE_eraseStatement: number;
    export const RULE_eraseExpressions: number;
    export const RULE_usingStatement: number;
    export const RULE_usingResources: number;
    export const RULE_awaitStatement: number;
    export const RULE_yieldStatement: number;
    export const RULE_expression: number;
    export const RULE_memberAccessBase: number;
    export const RULE_constantExpression: number;
    export const RULE_simpleExpression: number;
    export const RULE_literalExpression: number;
    export const RULE_parenthesizedExpression: number;
    export const RULE_instanceExpression: number;
    export const RULE_simpleNameExpression: number;
    export const RULE_addressOfExpression: number;
    export const RULE_getTypeExpression: number;
    export const RULE_getTypeTypeName: number;
    export const RULE_qualifiedOpenTypeName: number;
    export const RULE_typeArityList: number;
    export const RULE_commaList: number;
    export const RULE_typeOfIsExpression: number;
    export const RULE_getXmlNamespaceExpression: number;
    export const RULE_argumentList: number;
    export const RULE_positionalArgumentList: number;
    export const RULE_namedArgumentList: number;
    export const RULE_newExpression: number;
    export const RULE_objectCreationExpression: number;
    export const RULE_objectCreationExpressionInitializer: number;
    export const RULE_objectMemberInitializer: number;
    export const RULE_fieldInitializerList: number;
    export const RULE_fieldInitializer: number;
    export const RULE_objectCollectionInitializer: number;
    export const RULE_collectionInitializer: number;
    export const RULE_collectionElementList: number;
    export const RULE_collectionElement: number;
    export const RULE_arrayExpression: number;
    export const RULE_arrayCreationExpression: number;
    export const RULE_arrayLiteralExpression: number;
    export const RULE_anonymousObjectCreationExpression: number;
    export const RULE_castExpression: number;
    export const RULE_castTarget: number;
    export const RULE_unaryPlusExpression: number;
    export const RULE_unaryMinusExpression: number;
    export const RULE_booleanExpression: number;
    export const RULE_lambdaExpression: number;
    export const RULE_singleLineLambda: number;
    export const RULE_multiLineLambda: number;
    export const RULE_multiLineFunctionLambda: number;
    export const RULE_multiLineSubLambda: number;
    export const RULE_lambdaModifier: number;
    export const RULE_queryExpression: number;
    export const RULE_fromOrAggregateQueryOperator: number;
    export const RULE_queryOperator: number;
    export const RULE_joinOrGroupJoinQueryOperator: number;
    export const RULE_collectionRangeVariableDeclarationList: number;
    export const RULE_collectionRangeVariableDeclaration: number;
    export const RULE_expressionRangeVariableDeclarationList: number;
    export const RULE_expressionRangeVariableDeclaration: number;
    export const RULE_fromQueryOperator: number;
    export const RULE_joinQueryOperator: number;
    export const RULE_joinConditionList: number;
    export const RULE_joinCondition: number;
    export const RULE_letQueryOperator: number;
    export const RULE_selectQueryOperator: number;
    export const RULE_distinctQueryOperator: number;
    export const RULE_whereQueryOperator: number;
    export const RULE_partitionQueryOperator: number;
    export const RULE_orderByQueryOperator: number;
    export const RULE_orderExpressionList: number;
    export const RULE_orderExpression: number;
    export const RULE_ordering: number;
    export const RULE_groupByQueryOperator: number;
    export const RULE_aggregateQueryOperator: number;
    export const RULE_groupJoinQueryOperator: number;
    export const RULE_conditionalExpression: number;
    export const RULE_xMLLiteralExpression: number;
    export const RULE_xMLEmbeddedExpression: number;
    export const RULE_xMLDocument: number;
    export const RULE_xMLDocumentPrologue: number;
    export const RULE_xMLVersion: number;
    export const RULE_xMLVersionNumberValue: number;
    export const RULE_xMLEncoding: number;
    export const RULE_xMLEncodingNameValue: number;
    export const RULE_xMLEncodingName: number;
    export const RULE_xMLEncodingNameCharacter: number;
    export const RULE_xMLStandalone: number;
    export const RULE_xMLYesNoValue: number;
    export const RULE_xMLYesNo: number;
    export const RULE_xMLMisc: number;
    export const RULE_xMLDocumentBody: number;
    export const RULE_xMLElement: number;
    export const RULE_xMLEmptyElement: number;
    export const RULE_xMLElementStart: number;
    export const RULE_xMLElementEnd: number;
    export const RULE_xMLContent: number;
    export const RULE_xMLNestedContent: number;
    export const RULE_xMLAttribute: number;
    export const RULE_xMLAttributeName: number;
    export const RULE_xMLAttributeValue: number;
    export const RULE_xMLAttributeDoubleQuoteValueCharacter: number;
    export const RULE_xMLAttributeSingleQuoteValueCharacter: number;
    export const RULE_xMLReference: number;
    export const RULE_xMLEntityReference: number;
    export const RULE_xMLCharacterReference: number;
    export const RULE_xMLNamespaceAttributeName: number;
    export const RULE_xMLPrefixedNamespaceAttributeName: number;
    export const RULE_xMLDefaultNamespaceAttributeName: number;
    export const RULE_xMLNamespaceName: number;
    export const RULE_xMLNamespaceNameCharacter: number;
    export const RULE_xMLQualifiedNameOrExpression: number;
    export const RULE_xMLQualifiedName: number;
    export const RULE_xMLPrefixedName: number;
    export const RULE_xMLUnprefixedName: number;
    export const RULE_xMLProcessingInstruction: number;
    export const RULE_xMLComment: number;
    export const RULE_xMLCDATASection: number;
    export const RULE_awaitOperatorExpression: number;
    export { StartContext };
    export { HexDigitContext };
    export { DecimalDigitContext };
    export { OctalDigitContext };
    export { AlphaCharacterContext };
    export { BooleanLiteralContext };
    export { IntLiteralContext };
    export { HexLiteralContext };
    export { OctalLiteralContext };
    export { IntegerLiteralContext };
    export { IntegerLiteralValueContext };
    export { FloatingPointLiteralContext };
    export { FloatingPointLiteralValueContext };
    export { ExponentContext };
    export { SignContext };
    export { SingleTypeCharacterContext };
    export { DoubleTypeCharacterContext };
    export { LongTypeCharacterContext };
    export { StringTypeCharacterContext };
    export { IntegerTypeCharacterContext };
    export { DecimalTypeCharacterContext };
    export { IntegralTypeCharacterContext };
    export { FloatingPointTypeCharacterContext };
    export { MonthValueContext };
    export { DayValueContext };
    export { YearValueContext };
    export { HourValueContext };
    export { MinuteValueContext };
    export { SecondValueContext };
    export { AmpmContext };
    export { DateValueContext };
    export { TimeValueContext };
    export { DateOrTimeContext };
    export { DateLiteralContext };
    export { StringCharacterContext };
    export { StringLiteralContext };
    export { CharacterLiteralContext };
    export { IdentifierStartContext };
    export { IdentifierNameContext };
    export { IdentifierCharacterContext };
    export { IdentifierContext };
    export { IdentifierOrKeywordContext };
    export { TypeCharacterContext };
    export { LiteralContext };
    export { ElseIfContext };
    export { CCStartContext };
    export { CCStatementContext };
    export { CCExpressionContext };
    export { CCParenthesizedExpressionContext };
    export { CCSimpleNameExpressionContext };
    export { CCCastExpressionContext };
    export { CCPlusMinusContext };
    export { CCUnaryOperatorContext };
    export { CCBinaryOperatorContext };
    export { CCConditionalExpressionContext };
    export { CCConstantDeclarationContext };
    export { CCIfGroupContext };
    export { CCElseIfGroupContext };
    export { CCElseGroupContext };
    export { RegionStartContext };
    export { RegionStatementContext };
    export { RegionGroupContext };
    export { AccessModifierContext };
    export { TypeParameterListContext };
    export { TypeParameterContext };
    export { VarianceModifierContext };
    export { TypeParameterConstraintsContext };
    export { ConstraintListContext };
    export { ConstraintContext };
    export { AttributesContext };
    export { AttributeBlockContext };
    export { AttributeListContext };
    export { AttributeContext };
    export { AttributeModifierContext };
    export { AttributeArgumentsContext };
    export { AttributePositionalArgumentListContext };
    export { VariablePropertyInitializerListContext };
    export { VariablePropertyInitializerContext };
    export { AttributeArgumentExpressionContext };
    export { StatementTerminatorContext };
    export { AttributesStatementContext };
    export { OptionStatementContext };
    export { OptionExplicitStatementContext };
    export { OnOffContext };
    export { OptionStrictStatementContext };
    export { OptionCompareStatementContext };
    export { CompareOptionContext };
    export { OptionInferStatementContext };
    export { ImportsStatementContext };
    export { ImportsClausesContext };
    export { ImportsClauseContext };
    export { AliasImportsClauseContext };
    export { MembersImportsClauseContext };
    export { XMLNamespaceImportsClauseContext };
    export { XMLNamespaceValueContext };
    export { NamespaceDeclarationContext };
    export { NamespaceNameContext };
    export { RelativeNamespaceNameContext };
    export { NamespaceMemberDeclarationContext };
    export { TypeDeclarationContext };
    export { NonModuleDeclarationContext };
    export { TypeNameContext };
    export { NonArrayTypeNameContext };
    export { SimpleTypeNameContext };
    export { QualifiedTypeNameContext };
    export { TypeArgumentsContext };
    export { TypeArgumentListContext };
    export { BuiltInTypeNameContext };
    export { TypeModifierContext };
    export { IdentifierModifiersContext };
    export { NullableNameModifierContext };
    export { TypeImplementsClauseContext };
    export { TypeImplementsContext };
    export { PrimitiveTypeNameContext };
    export { NumericTypeNameContext };
    export { IntegralTypeNameContext };
    export { FloatingPointTypeNameContext };
    export { EnumDeclarationContext };
    export { EnumMemberDeclarationContext };
    export { ClassDeclarationContext };
    export { ClassModifierContext };
    export { ClassBaseContext };
    export { ClassMemberDeclarationContext };
    export { StructureDeclarationContext };
    export { StructureModifierContext };
    export { StructMemberDeclarationContext };
    export { ModuleDeclarationContext };
    export { ModuleMemberDeclarationContext };
    export { InterfaceDeclarationContext };
    export { InterfaceBaseContext };
    export { InterfaceBasesContext };
    export { InterfaceMemberDeclarationContext };
    export { ArrayTypeNameContext };
    export { ArrayTypeModifiersContext };
    export { ArrayTypeModifierContext };
    export { RankListContext };
    export { ArrayNameModifierContext };
    export { DelegateDeclarationContext };
    export { MethodSignatureContext };
    export { ImplementsClauseContext };
    export { ImplementsListContext };
    export { InterfaceMemberSpecifierContext };
    export { MethodMemberDeclarationContext };
    export { InterfaceMethodMemberDeclarationContext };
    export { MethodDeclarationContext };
    export { InterfaceMethodDeclarationContext };
    export { SubSignatureContext };
    export { FunctionSignatureContext };
    export { SubDeclarationContext };
    export { MustOverrideSubDeclarationContext };
    export { InterfaceSubDeclarationContext };
    export { FunctionDeclarationContext };
    export { MustOverrideFunctionDeclarationContext };
    export { InterfaceFunctionDeclarationContext };
    export { ProcedureModifierContext };
    export { MustOverrideProcedureModifierContext };
    export { InterfaceProcedureModifierContext };
    export { HandlesOrImplementsContext };
    export { ExternalMethodDeclarationContext };
    export { ExternalSubDeclarationContext };
    export { ExternalFunctionDeclarationContext };
    export { ExternalMethodModifierContext };
    export { CharsetModifierContext };
    export { LibraryClauseContext };
    export { AliasClauseContext };
    export { ParameterListContext };
    export { ParameterContext };
    export { ParameterModifierContext };
    export { ParameterIdentifierContext };
    export { HandlesClauseContext };
    export { EventHandlesListContext };
    export { EventMemberSpecifierContext };
    export { ConstructorMemberDeclarationContext };
    export { ConstructorModifierContext };
    export { EventMemberDeclarationContext };
    export { RegularEventMemberDeclarationContext };
    export { InterfaceEventMemberDeclarationContext };
    export { ParametersOrTypeContext };
    export { EventModifiersContext };
    export { InterfaceEventModifiersContext };
    export { CustomEventMemberDeclarationContext };
    export { EventAccessorDeclarationContext };
    export { AddHandlerDeclarationContext };
    export { RemoveHandlerDeclarationContext };
    export { RaiseEventDeclarationContext };
    export { ConstantMemberDeclarationContext };
    export { ConstantModifierContext };
    export { ConstantDeclaratorsContext };
    export { ConstantDeclaratorContext };
    export { VariableMemberDeclarationContext };
    export { VariableModifierContext };
    export { VariableDeclaratorsContext };
    export { VariableDeclaratorContext };
    export { VariableIdentifiersContext };
    export { VariableIdentifierContext };
    export { ArraySizeInitializationModifierContext };
    export { BoundListContext };
    export { BoundContext };
    export { PropertyMemberDeclarationContext };
    export { PropertySignatureContext };
    export { RegularPropertyMemberDeclarationContext };
    export { MustOverridePropertyMemberDeclarationContext };
    export { AutoPropertyMemberDeclarationContext };
    export { InterfacePropertyMemberDeclarationContext };
    export { AutoPropertyModifierContext };
    export { PropertyModifierContext };
    export { MustOverridePropertyModifierContext };
    export { InterfacePropertyModifierContext };
    export { PropertyAccessorDeclarationContext };
    export { PropertyGetDeclarationContext };
    export { PropertySetDeclarationContext };
    export { OperatorDeclarationContext };
    export { OperatorModifierContext };
    export { OverloadableOperatorContext };
    export { StatementContext };
    export { BlockContext };
    export { LabelDeclarationStatementContext };
    export { LabelNameContext };
    export { StatementsContext };
    export { LocalDeclarationStatementContext };
    export { LocalModifierContext };
    export { WithStatementContext };
    export { SyncLockStatementContext };
    export { EventStatementContext };
    export { RaiseEventStatementContext };
    export { AddHandlerStatementContext };
    export { RemoveHandlerStatementContext };
    export { AssignmentStatementContext };
    export { RegularAssignmentStatementContext };
    export { CompoundAssignmentStatementContext };
    export { CompoundBinaryOperatorContext };
    export { MidAssignmentStatementContext };
    export { InvocationStatementContext };
    export { ConditionalStatementContext };
    export { IfStatementContext };
    export { BlockIfStatementContext };
    export { ElseIfStatementContext };
    export { ElseStatementContext };
    export { LineIfThenStatementContext };
    export { SelectStatementContext };
    export { CaseStatementContext };
    export { CaseClausesContext };
    export { CaseClauseContext };
    export { ComparisonOperatorContext };
    export { CaseElseStatementContext };
    export { LoopStatementContext };
    export { WhileStatementContext };
    export { DoLoopStatementContext };
    export { DoTopLoopStatementContext };
    export { DoBottomLoopStatementContext };
    export { WhileOrUntilContext };
    export { ForStatementContext };
    export { LoopControlVariableContext };
    export { NextExpressionListContext };
    export { ForEachStatementContext };
    export { ErrorHandlingStatementContext };
    export { StructuredErrorStatementContext };
    export { TryStatementContext };
    export { FinallyStatementContext };
    export { CatchStatementContext };
    export { ThrowStatementContext };
    export { UnstructuredErrorStatementContext };
    export { ErrorStatementContext };
    export { OnErrorStatementContext };
    export { ErrorClauseContext };
    export { ResumeStatementContext };
    export { ResumeClauseContext };
    export { BranchStatementContext };
    export { GoToStatementContext };
    export { ExitStatementContext };
    export { ExitKindContext };
    export { ContinueStatementContext };
    export { ContinueKindContext };
    export { StopStatementContext };
    export { EndStatementContext };
    export { ReturnStatementContext };
    export { ArrayHandlingStatementContext };
    export { RedimStatementContext };
    export { RedimClausesContext };
    export { RedimClauseContext };
    export { EraseStatementContext };
    export { EraseExpressionsContext };
    export { UsingStatementContext };
    export { UsingResourcesContext };
    export { AwaitStatementContext };
    export { YieldStatementContext };
    export { ExpressionContext };
    export { MemberAccessBaseContext };
    export { ConstantExpressionContext };
    export { SimpleExpressionContext };
    export { LiteralExpressionContext };
    export { ParenthesizedExpressionContext };
    export { InstanceExpressionContext };
    export { SimpleNameExpressionContext };
    export { AddressOfExpressionContext };
    export { GetTypeExpressionContext };
    export { GetTypeTypeNameContext };
    export { QualifiedOpenTypeNameContext };
    export { TypeArityListContext };
    export { CommaListContext };
    export { TypeOfIsExpressionContext };
    export { GetXmlNamespaceExpressionContext };
    export { ArgumentListContext };
    export { PositionalArgumentListContext };
    export { NamedArgumentListContext };
    export { NewExpressionContext };
    export { ObjectCreationExpressionContext };
    export { ObjectCreationExpressionInitializerContext };
    export { ObjectMemberInitializerContext };
    export { FieldInitializerListContext };
    export { FieldInitializerContext };
    export { ObjectCollectionInitializerContext };
    export { CollectionInitializerContext };
    export { CollectionElementListContext };
    export { CollectionElementContext };
    export { ArrayExpressionContext };
    export { ArrayCreationExpressionContext };
    export { ArrayLiteralExpressionContext };
    export { AnonymousObjectCreationExpressionContext };
    export { CastExpressionContext };
    export { CastTargetContext };
    export { UnaryPlusExpressionContext };
    export { UnaryMinusExpressionContext };
    export { BooleanExpressionContext };
    export { LambdaExpressionContext };
    export { SingleLineLambdaContext };
    export { MultiLineLambdaContext };
    export { MultiLineFunctionLambdaContext };
    export { MultiLineSubLambdaContext };
    export { LambdaModifierContext };
    export { QueryExpressionContext };
    export { FromOrAggregateQueryOperatorContext };
    export { QueryOperatorContext };
    export { JoinOrGroupJoinQueryOperatorContext };
    export { CollectionRangeVariableDeclarationListContext };
    export { CollectionRangeVariableDeclarationContext };
    export { ExpressionRangeVariableDeclarationListContext };
    export { ExpressionRangeVariableDeclarationContext };
    export { FromQueryOperatorContext };
    export { JoinQueryOperatorContext };
    export { JoinConditionListContext };
    export { JoinConditionContext };
    export { LetQueryOperatorContext };
    export { SelectQueryOperatorContext };
    export { DistinctQueryOperatorContext };
    export { WhereQueryOperatorContext };
    export { PartitionQueryOperatorContext };
    export { OrderByQueryOperatorContext };
    export { OrderExpressionListContext };
    export { OrderExpressionContext };
    export { OrderingContext };
    export { GroupByQueryOperatorContext };
    export { AggregateQueryOperatorContext };
    export { GroupJoinQueryOperatorContext };
    export { ConditionalExpressionContext };
    export { XMLLiteralExpressionContext };
    export { XMLEmbeddedExpressionContext };
    export { XMLDocumentContext };
    export { XMLDocumentPrologueContext };
    export { XMLVersionContext };
    export { XMLVersionNumberValueContext };
    export { XMLEncodingContext };
    export { XMLEncodingNameValueContext };
    export { XMLEncodingNameContext };
    export { XMLEncodingNameCharacterContext };
    export { XMLStandaloneContext };
    export { XMLYesNoValueContext };
    export { XMLYesNoContext };
    export { XMLMiscContext };
    export { XMLDocumentBodyContext };
    export { XMLElementContext };
    export { XMLEmptyElementContext };
    export { XMLElementStartContext };
    export { XMLElementEndContext };
    export { XMLContentContext };
    export { XMLNestedContentContext };
    export { XMLAttributeContext };
    export { XMLAttributeNameContext };
    export { XMLAttributeValueContext };
    export { XMLAttributeDoubleQuoteValueCharacterContext };
    export { XMLAttributeSingleQuoteValueCharacterContext };
    export { XMLReferenceContext };
    export { XMLEntityReferenceContext };
    export { XMLCharacterReferenceContext };
    export { XMLNamespaceAttributeNameContext };
    export { XMLPrefixedNamespaceAttributeNameContext };
    export { XMLDefaultNamespaceAttributeNameContext };
    export { XMLNamespaceNameContext };
    export { XMLNamespaceNameCharacterContext };
    export { XMLQualifiedNameOrExpressionContext };
    export { XMLQualifiedNameContext };
    export { XMLPrefixedNameContext };
    export { XMLUnprefixedNameContext };
    export { XMLProcessingInstructionContext };
    export { XMLCommentContext };
    export { XMLCDATASectionContext };
    export { AwaitOperatorExpressionContext };
}
export default vbParser;
declare class StartContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    classMemberDeclaration(): any;
    EOF(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class HexDigitContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    decimalDigit(): any;
    A(): any;
    B(): any;
    C(): any;
    D(): any;
    E(): any;
    F(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DecimalDigitContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    octalDigit(): any;
    EIGHT(): any;
    NINE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OctalDigitContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ZERO(): any;
    ONE(): any;
    TWO(): any;
    THREE(): any;
    FOUR(): any;
    FIVE(): any;
    SIX(): any;
    SEVEN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AlphaCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    A(): any;
    B(): any;
    C(): any;
    D(): any;
    E(): any;
    F(): any;
    G(): any;
    H(): any;
    I(): any;
    J(): any;
    K(): any;
    L(): any;
    M(): any;
    N(): any;
    O(): any;
    P(): any;
    Q(): any;
    R(): any;
    S(): any;
    T(): any;
    U(): any;
    V(): any;
    W(): any;
    X(): any;
    Y(): any;
    Z(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BooleanLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    T(): any;
    R(): any;
    U(): any;
    E(): any;
    F(): any;
    A(): any;
    L(): any;
    S(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IntLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    decimalDigit: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class HexLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AMPERSAND(): any;
    H(): any;
    hexDigit: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OctalLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AMPERSAND(): any;
    O(): any;
    octalDigit: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IntegerLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    integerLiteralValue(): any;
    integralTypeCharacter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IntegerLiteralValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral(): any;
    hexLiteral(): any;
    octalLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FloatingPointLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    floatingPointLiteralValue(): any;
    floatingPointTypeCharacter(): any;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FloatingPointLiteralValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral: (i: any) => any;
    PERIOD(): any;
    exponent(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExponentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    E(): any;
    intLiteral(): any;
    sign(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SignContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PLUS(): any;
    MINUS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SingleTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EXCLAMATION(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DoubleTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    POUND(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LongTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AMPERSAND(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StringTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOLLAR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IntegerTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PERCENT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DecimalTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IntegralTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SHORT_CHARACTER(): any;
    UNSIGNED_SHORT_CHARACTER(): any;
    INTEGER_CHARACTER(): any;
    UNSIGNED_INTEGER_CHARACTER(): any;
    LONG_CHARACTER(): any;
    UNSIGNED_LONG_CHARACTER(): any;
    integerTypeCharacter(): any;
    longTypeCharacter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FloatingPointTypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SINGLE_CHARACTER(): any;
    DOUBLE_CHARACTER(): any;
    DECIMAL_CHARACTER(): any;
    singleTypeCharacter(): any;
    doubleTypeCharacter(): any;
    decimalTypeCharacter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MonthValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DayValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class YearValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class HourValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MinuteValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SecondValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AmpmContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    A(): any;
    M(): any;
    P(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DateValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    monthValue(): any;
    SLASH: (i: any) => any;
    dayValue(): any;
    yearValue(): any;
    MINUS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TimeValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    hourValue(): any;
    COLON: (i: any) => any;
    minuteValue(): any;
    secondValue(): any;
    WS: (i: any) => any;
    ampm(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DateOrTimeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    dateValue(): any;
    timeValue(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DateLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    POUND: (i: any) => any;
    dateOrTime(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StringCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StringLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    stringCharacter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CharacterLiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    stringCharacter(): any;
    C(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierStartContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    alphaCharacter(): any;
    UNDERSCORE(): any;
    identifierCharacter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifierStart(): any;
    identifierCharacter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    UNDERSCORE(): any;
    alphaCharacter(): any;
    decimalDigit(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifierName(): any;
    typeCharacter(): any;
    LEFT_SQUARE_BRACKET(): any;
    RIGHT_SQUARE_BRACKET(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierOrKeywordContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    integerTypeCharacter(): any;
    longTypeCharacter(): any;
    decimalTypeCharacter(): any;
    singleTypeCharacter(): any;
    doubleTypeCharacter(): any;
    stringTypeCharacter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    booleanLiteral(): any;
    integerLiteral(): any;
    floatingPointLiteral(): any;
    stringLiteral(): any;
    characterLiteral(): any;
    dateLiteral(): any;
    NOTHING(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ElseIfContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ELSEIF(): any;
    ELSE(): any;
    IF(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCStartContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cCStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cCConstantDeclaration(): any;
    cCIfGroup(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    literalExpression(): any;
    cCParenthesizedExpression(): any;
    cCSimpleNameExpression(): any;
    cCCastExpression(): any;
    cCUnaryOperator(): any;
    cCExpression: (i: any) => any;
    cCConditionalExpression(): any;
    cCBinaryOperator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCParenthesizedExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    cCExpression(): any;
    RIGHT_PAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCSimpleNameExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCCastExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DIRECTCAST(): any;
    LEFT_PAREN(): any;
    cCExpression(): any;
    COMMA(): any;
    typeName(): any;
    RIGHT_PAREN(): any;
    TRYCAST(): any;
    CTYPE(): any;
    castTarget(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCPlusMinusContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PLUS(): any;
    MINUS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCUnaryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cCPlusMinus(): any;
    NOT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCBinaryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cCPlusMinus(): any;
    ASTERISK(): any;
    SLASH(): any;
    DOUBLE_BACK_SLASH(): any;
    MOD(): any;
    CARET(): any;
    EQUALS(): any;
    LEFT_ARROW: (i: any) => any;
    RIGHT_ARROW: (i: any) => any;
    AMPERSAND(): any;
    AND(): any;
    OR(): any;
    XOR(): any;
    ANDALSO(): any;
    ORELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCConditionalExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IF(): any;
    LEFT_PAREN(): any;
    cCExpression: (i: any) => any;
    COMMA: (i: any) => any;
    RIGHT_PAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCConstantDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    POUND(): any;
    CONST(): any;
    identifier(): any;
    EQUALS(): any;
    cCExpression(): any;
    LINE_TERMINATOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCIfGroupContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    POUND: (i: any) => any;
    IF: (i: any) => any;
    cCExpression(): any;
    LINE_TERMINATOR: (i: any) => any;
    END(): any;
    THEN(): any;
    cCStatement: (i: any) => any;
    cCElseIfGroup: (i: any) => any;
    cCElseGroup(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCElseIfGroupContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    POUND(): any;
    elseIf(): any;
    cCExpression(): any;
    LINE_TERMINATOR(): any;
    THEN(): any;
    cCStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CCElseGroupContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    POUND(): any;
    ELSE(): any;
    LINE_TERMINATOR(): any;
    cCStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RegionStartContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    regionStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RegionStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    regionGroup(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RegionGroupContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    POUND: (i: any) => any;
    REGION: (i: any) => any;
    stringLiteral(): any;
    LINE_TERMINATOR: (i: any) => any;
    END(): any;
    regionStatement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AccessModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PUBLIC(): any;
    PROTECTED(): any;
    FRIEND(): any;
    PRIVATE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    OF(): any;
    typeParameter: (i: any) => any;
    RIGHT_PAREN(): any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    varianceModifier(): any;
    typeParameterConstraints(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VarianceModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IN(): any;
    OUT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeParameterConstraintsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AS(): any;
    constraint(): any;
    LEFT_BRACE(): any;
    constraintList(): any;
    RIGHT_BRACE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstraintListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constraint: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstraintContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeName(): any;
    NEW(): any;
    STRUCTURE(): any;
    CLASS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    attributeBlock: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeBlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    attributeList(): any;
    RIGHT_ARROW(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    attribute: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    simpleTypeName(): any;
    attributeModifier(): any;
    COLON(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    attributeArguments(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ASSEMBLY(): any;
    MODULE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeArgumentsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    attributePositionalArgumentList(): any;
    COMMA(): any;
    variablePropertyInitializerList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributePositionalArgumentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    attributeArgumentExpression: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariablePropertyInitializerListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variablePropertyInitializer: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariablePropertyInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifierOrKeyword(): any;
    COLON(): any;
    EQUALS(): any;
    attributeArgumentExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeArgumentExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constantExpression(): any;
    getTypeExpression(): any;
    arrayExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StatementTerminatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LINE_TERMINATOR(): any;
    COLON(): any;
    EOF(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributesStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    attributes(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    optionExplicitStatement(): any;
    optionStrictStatement(): any;
    optionCompareStatement(): any;
    optionInferStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionExplicitStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OPTION(): any;
    EXPLICIT(): any;
    statementTerminator(): any;
    onOff(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OnOffContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ON(): any;
    OFF(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionStrictStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OPTION(): any;
    STRICT(): any;
    statementTerminator(): any;
    onOff(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionCompareStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OPTION(): any;
    COMPARE(): any;
    compareOption(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CompareOptionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BINARY(): any;
    TEXT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionInferStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OPTION(): any;
    INFER(): any;
    statementTerminator(): any;
    onOff(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImportsStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IMPORTS(): any;
    importsClauses(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImportsClausesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    importsClause: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImportsClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    aliasImportsClause(): any;
    membersImportsClause(): any;
    xMLNamespaceImportsClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AliasImportsClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    EQUALS(): any;
    typeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MembersImportsClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLNamespaceImportsClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    xMLNamespaceAttributeName(): any;
    EQUALS(): any;
    xMLNamespaceValue(): any;
    RIGHT_ARROW(): any;
    XMLWhitespace: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLNamespaceValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    xMLAttributeDoubleQuoteValueCharacter: (i: any) => any;
    SINGLE_QUOTE_CHAR: (i: any) => any;
    xMLAttributeSingleQuoteValueCharacter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamespaceDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NAMESPACE: (i: any) => any;
    namespaceName(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    namespaceMemberDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamespaceNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    relativeNamespaceName(): any;
    GLOBAL(): any;
    PERIOD(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RelativeNamespaceNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    PERIOD: (i: any) => any;
    identifierOrKeyword: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamespaceMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    namespaceDeclaration(): any;
    typeDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    moduleDeclaration(): any;
    nonModuleDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NonModuleDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    enumDeclaration(): any;
    structureDeclaration(): any;
    interfaceDeclaration(): any;
    classDeclaration(): any;
    delegateDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    arrayTypeName(): any;
    nonArrayTypeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NonArrayTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    simpleTypeName(): any;
    nonArrayTypeName(): any;
    QUESTION_MARK(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SimpleTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    qualifiedTypeName(): any;
    builtInTypeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QualifiedTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    typeArguments: (i: any) => any;
    PERIOD: (i: any) => any;
    identifierOrKeyword: (i: any) => any;
    GLOBAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeArgumentsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    OF(): any;
    typeArgumentList(): any;
    RIGHT_PAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeArgumentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeName: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BuiltInTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OBJECT(): any;
    primitiveTypeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHADOWS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IdentifierModifiersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nullableNameModifier(): any;
    arrayNameModifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NullableNameModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    QUESTION_MARK(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeImplementsClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IMPLEMENTS(): any;
    typeImplements(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeImplementsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonArrayTypeName: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PrimitiveTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    numericTypeName(): any;
    BOOLEAN(): any;
    DATE(): any;
    CHAR(): any;
    STRING(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NumericTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    integralTypeName(): any;
    floatingPointTypeName(): any;
    DECIMAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IntegralTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BYTE(): any;
    SBYTE(): any;
    USHORT(): any;
    SHORT(): any;
    UINTEGER(): any;
    INTEGER(): any;
    ULONG(): any;
    LONG(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FloatingPointTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SINGLE(): any;
    DOUBLE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EnumDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ENUM: (i: any) => any;
    identifier(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    attributes(): any;
    typeModifier: (i: any) => any;
    AS(): any;
    nonArrayTypeName(): any;
    enumMemberDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EnumMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    statementTerminator(): any;
    attributes(): any;
    EQUALS(): any;
    constantExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CLASS: (i: any) => any;
    identifier(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    attributes(): any;
    classModifier: (i: any) => any;
    typeParameterList(): any;
    classBase(): any;
    typeImplementsClause: (i: any) => any;
    classMemberDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeModifier(): any;
    MUST_INHERIT(): any;
    NOT_INHERITABLE(): any;
    PARTIAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassBaseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    INHERITS(): any;
    nonArrayTypeName(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ClassMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonModuleDeclaration(): any;
    eventMemberDeclaration(): any;
    variableMemberDeclaration(): any;
    constantMemberDeclaration(): any;
    methodMemberDeclaration(): any;
    propertyMemberDeclaration(): any;
    constructorMemberDeclaration(): any;
    operatorDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StructureDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STRUCTURE: (i: any) => any;
    identifier(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    attributes(): any;
    structureModifier: (i: any) => any;
    typeParameterList(): any;
    typeImplementsClause: (i: any) => any;
    structMemberDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StructureModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeModifier(): any;
    PARTIAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StructMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonModuleDeclaration(): any;
    variableMemberDeclaration(): any;
    constantMemberDeclaration(): any;
    eventMemberDeclaration(): any;
    methodMemberDeclaration(): any;
    propertyMemberDeclaration(): any;
    constructorMemberDeclaration(): any;
    operatorDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MODULE: (i: any) => any;
    identifier(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    attributes(): any;
    typeModifier: (i: any) => any;
    moduleMemberDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonModuleDeclaration(): any;
    variableMemberDeclaration(): any;
    constantMemberDeclaration(): any;
    eventMemberDeclaration(): any;
    methodMemberDeclaration(): any;
    propertyMemberDeclaration(): any;
    constructorMemberDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    INTERFACE: (i: any) => any;
    identifier(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    attributes(): any;
    typeModifier: (i: any) => any;
    typeParameterList(): any;
    interfaceBase: (i: any) => any;
    interfaceMemberDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceBaseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    INHERITS(): any;
    interfaceBases(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceBasesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonArrayTypeName: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonModuleDeclaration(): any;
    interfaceEventMemberDeclaration(): any;
    interfaceMethodMemberDeclaration(): any;
    interfacePropertyMemberDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonArrayTypeName(): any;
    arrayTypeModifiers(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayTypeModifiersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    arrayTypeModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayTypeModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    rankList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RankListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayNameModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    arrayTypeModifiers(): any;
    arraySizeInitializationModifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DelegateDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DELEGATE(): any;
    methodSignature(): any;
    statementTerminator(): any;
    attributes(): any;
    typeModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MethodSignatureContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    subSignature(): any;
    functionSignature(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImplementsClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IMPLEMENTS(): any;
    implementsList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImplementsListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    interfaceMemberSpecifier: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceMemberSpecifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonArrayTypeName(): any;
    PERIOD(): any;
    identifierOrKeyword(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MethodMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    methodDeclaration(): any;
    externalMethodDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceMethodMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    interfaceMethodDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MethodDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    subDeclaration(): any;
    mustOverrideSubDeclaration(): any;
    functionDeclaration(): any;
    mustOverrideFunctionDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceMethodDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    interfaceSubDeclaration(): any;
    interfaceFunctionDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SubSignatureContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SUB(): any;
    identifier(): any;
    typeParameterList(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    parameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FunctionSignatureContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FUNCTION(): any;
    identifier(): any;
    typeParameterList(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    AS(): any;
    typeName(): any;
    parameterList(): any;
    attributes(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SubDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    subSignature(): any;
    LINE_TERMINATOR(): any;
    block(): any;
    END(): any;
    SUB(): any;
    statementTerminator(): any;
    attributes(): any;
    procedureModifier: (i: any) => any;
    handlesOrImplements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MustOverrideSubDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    subSignature(): any;
    statementTerminator(): any;
    attributes(): any;
    mustOverrideProcedureModifier: (i: any) => any;
    handlesOrImplements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceSubDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    subSignature(): any;
    statementTerminator(): any;
    attributes(): any;
    interfaceProcedureModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FunctionDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    functionSignature(): any;
    LINE_TERMINATOR(): any;
    block(): any;
    END(): any;
    FUNCTION(): any;
    statementTerminator(): any;
    attributes(): any;
    procedureModifier: (i: any) => any;
    handlesOrImplements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MustOverrideFunctionDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    functionSignature(): any;
    statementTerminator(): any;
    attributes(): any;
    mustOverrideProcedureModifier: (i: any) => any;
    handlesOrImplements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceFunctionDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    functionSignature(): any;
    statementTerminator(): any;
    attributes(): any;
    interfaceProcedureModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ProcedureModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHADOWS(): any;
    SHARED(): any;
    OVERRIDABLE(): any;
    NOTOVERRIDABLE(): any;
    OVERRIDES(): any;
    OVERLOADS(): any;
    PARTIAL(): any;
    ITERATOR(): any;
    ASYNC(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MustOverrideProcedureModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    procedureModifier(): any;
    MUSTOVERRIDE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceProcedureModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SHADOWS(): any;
    OVERLOADS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class HandlesOrImplementsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    handlesClause(): any;
    implementsClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExternalMethodDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    externalSubDeclaration(): any;
    externalFunctionDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExternalSubDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DECLARE(): any;
    SUB(): any;
    identifier(): any;
    libraryClause(): any;
    statementTerminator(): any;
    attributes(): any;
    externalMethodModifier: (i: any) => any;
    charsetModifier(): any;
    aliasClause(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    parameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExternalFunctionDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DECLARE(): any;
    FUNCTION(): any;
    identifier(): any;
    libraryClause(): any;
    statementTerminator(): any;
    attributes: (i: any) => any;
    externalMethodModifier: (i: any) => any;
    charsetModifier(): any;
    aliasClause(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    AS(): any;
    typeName(): any;
    parameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExternalMethodModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHADOWS(): any;
    OVERLOADS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CharsetModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ANSI(): any;
    UNICODE(): any;
    AUTO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LibraryClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LIB(): any;
    stringLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AliasClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ALIAS(): any;
    stringLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParameterListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    parameter: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParameterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    parameterIdentifier(): any;
    attributes(): any;
    parameterModifier: (i: any) => any;
    AS(): any;
    typeName(): any;
    EQUALS(): any;
    constantExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParameterModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BYVAL(): any;
    BYREF(): any;
    OPTIONAL(): any;
    PARAM_ARRAY(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParameterIdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    identifierModifiers(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class HandlesClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    HANDLES(): any;
    eventHandlesList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EventHandlesListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    eventMemberSpecifier: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EventMemberSpecifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    PERIOD(): any;
    identifierOrKeyword(): any;
    MYBASE(): any;
    MYCLASS(): any;
    ME(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstructorMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SUB: (i: any) => any;
    NEW(): any;
    LINE_TERMINATOR(): any;
    END(): any;
    statementTerminator(): any;
    attributes(): any;
    constructorModifier: (i: any) => any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    block(): any;
    parameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstructorModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHARED(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EventMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    regularEventMemberDeclaration(): any;
    customEventMemberDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RegularEventMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EVENT(): any;
    identifier(): any;
    parametersOrType(): any;
    statementTerminator(): any;
    attributes(): any;
    eventModifiers: (i: any) => any;
    implementsClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceEventMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EVENT(): any;
    identifier(): any;
    parametersOrType(): any;
    statementTerminator(): any;
    attributes(): any;
    interfaceEventModifiers: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParametersOrTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    parameterList(): any;
    AS(): any;
    nonArrayTypeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EventModifiersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHADOWS(): any;
    SHARED(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfaceEventModifiersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SHADOWS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CustomEventMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CUSTOM(): any;
    EVENT: (i: any) => any;
    identifier(): any;
    AS(): any;
    typeName(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    attributes(): any;
    eventModifiers: (i: any) => any;
    implementsClause(): any;
    eventAccessorDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EventAccessorDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    addHandlerDeclaration(): any;
    removeHandlerDeclaration(): any;
    raiseEventDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AddHandlerDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ADDHANDLER: (i: any) => any;
    LEFT_PAREN(): any;
    parameterList(): any;
    RIGHT_PAREN(): any;
    LINE_TERMINATOR(): any;
    END(): any;
    statementTerminator(): any;
    attributes(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RemoveHandlerDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REMOVEHANDLER: (i: any) => any;
    LEFT_PAREN(): any;
    parameterList(): any;
    RIGHT_PAREN(): any;
    LINE_TERMINATOR(): any;
    END(): any;
    statementTerminator(): any;
    attributes(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RaiseEventDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RAISEEVENT: (i: any) => any;
    LEFT_PAREN(): any;
    parameterList(): any;
    RIGHT_PAREN(): any;
    LINE_TERMINATOR(): any;
    END(): any;
    statementTerminator(): any;
    attributes(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstantMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CONST(): any;
    constantDeclarators(): any;
    statementTerminator(): any;
    attributes(): any;
    constantModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstantModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHADOWS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstantDeclaratorsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constantDeclarator: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstantDeclaratorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    EQUALS(): any;
    constantExpression(): any;
    statementTerminator(): any;
    AS(): any;
    typeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variableDeclarators(): any;
    statementTerminator(): any;
    attributes(): any;
    variableModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHADOWS(): any;
    SHARED(): any;
    READONLY(): any;
    WITH_EVENTS(): any;
    DIM(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableDeclaratorsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variableDeclarator: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableDeclaratorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variableIdentifiers(): any;
    AS(): any;
    objectCreationExpression(): any;
    typeName(): any;
    EQUALS(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableIdentifiersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variableIdentifier: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableIdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    identifierModifiers(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArraySizeInitializationModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    boundList(): any;
    RIGHT_PAREN(): any;
    arrayTypeModifiers(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BoundListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    bound: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BoundContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    ZERO(): any;
    TO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertyMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    regularPropertyMemberDeclaration(): any;
    mustOverridePropertyMemberDeclaration(): any;
    autoPropertyMemberDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertySignatureContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PROPERTY(): any;
    identifier(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    AS(): any;
    typeName(): any;
    parameterList(): any;
    attributes(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RegularPropertyMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    propertySignature(): any;
    LINE_TERMINATOR(): any;
    END(): any;
    PROPERTY(): any;
    statementTerminator(): any;
    attributes(): any;
    propertyModifier: (i: any) => any;
    implementsClause(): any;
    propertyAccessorDeclaration: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MustOverridePropertyMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    propertySignature(): any;
    statementTerminator(): any;
    attributes(): any;
    mustOverridePropertyModifier: (i: any) => any;
    implementsClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AutoPropertyMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PROPERTY(): any;
    identifier(): any;
    LINE_TERMINATOR(): any;
    attributes: (i: any) => any;
    autoPropertyModifier: (i: any) => any;
    LEFT_PAREN: (i: any) => any;
    RIGHT_PAREN: (i: any) => any;
    AS(): any;
    typeName(): any;
    EQUALS(): any;
    expression(): any;
    implementsClause(): any;
    parameterList(): any;
    NEW(): any;
    nonArrayTypeName(): any;
    objectCreationExpressionInitializer(): any;
    argumentList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfacePropertyMemberDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    propertySignature(): any;
    statementTerminator(): any;
    attributes(): any;
    interfacePropertyModifier: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AutoPropertyModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    accessModifier(): any;
    SHADOWS(): any;
    SHARED(): any;
    OVERRIDABLE(): any;
    NOTOVERRIDABLE(): any;
    OVERRIDES(): any;
    OVERLOADS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertyModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    autoPropertyModifier(): any;
    DEFAULT(): any;
    READONLY(): any;
    WRITEONLY(): any;
    ITERATOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MustOverridePropertyModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    propertyModifier(): any;
    MUSTOVERRIDE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InterfacePropertyModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SHADOWS(): any;
    OVERLOADS(): any;
    DEFAULT(): any;
    READONLY(): any;
    WRITEONLY(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertyAccessorDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    propertyGetDeclaration(): any;
    propertySetDeclaration(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertyGetDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GET: (i: any) => any;
    LINE_TERMINATOR(): any;
    END(): any;
    statementTerminator(): any;
    attributes(): any;
    accessModifier(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertySetDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SET: (i: any) => any;
    LINE_TERMINATOR(): any;
    END(): any;
    statementTerminator(): any;
    attributes(): any;
    accessModifier(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    block(): any;
    parameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OperatorDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OPERATORKEYWORD: (i: any) => any;
    overloadableOperator(): any;
    LEFT_PAREN(): any;
    parameterList(): any;
    RIGHT_PAREN(): any;
    LINE_TERMINATOR(): any;
    END(): any;
    statementTerminator(): any;
    attributes: (i: any) => any;
    operatorModifier: (i: any) => any;
    AS(): any;
    typeName(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OperatorModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PUBLIC(): any;
    SHARED(): any;
    OVERLOADS(): any;
    SHADOWS(): any;
    WIDENING(): any;
    NARROWING(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OverloadableOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cCPlusMinus(): any;
    ASTERISK(): any;
    SLASH(): any;
    DOUBLE_BACK_SLASH(): any;
    AMPERSAND(): any;
    LIKE(): any;
    MOD(): any;
    AND(): any;
    OR(): any;
    XOR(): any;
    CARET(): any;
    LEFT_ARROW: (i: any) => any;
    RIGHT_ARROW: (i: any) => any;
    EQUALS(): any;
    NOT(): any;
    IS_TRUE(): any;
    IS_FALSE(): any;
    CTYPE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    labelDeclarationStatement(): any;
    localDeclarationStatement(): any;
    withStatement(): any;
    syncLockStatement(): any;
    eventStatement(): any;
    assignmentStatement(): any;
    invocationStatement(): any;
    conditionalStatement(): any;
    loopStatement(): any;
    errorHandlingStatement(): any;
    branchStatement(): any;
    arrayHandlingStatement(): any;
    usingStatement(): any;
    awaitStatement(): any;
    yieldStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    statements(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LabelDeclarationStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    labelName(): any;
    COLON(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LabelNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    intLiteral(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StatementsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    statement: (i: any) => any;
    COLON: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LocalDeclarationStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    localModifier(): any;
    variableDeclarators(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LocalModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STATIC(): any;
    DIM(): any;
    CONST(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WithStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WITH: (i: any) => any;
    expression(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SyncLockStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SYNCLOCK: (i: any) => any;
    expression(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EventStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    raiseEventStatement(): any;
    addHandlerStatement(): any;
    removeHandlerStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RaiseEventStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RAISEEVENT(): any;
    identifierOrKeyword(): any;
    statementTerminator(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    argumentList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AddHandlerStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ADDHANDLER(): any;
    expression: (i: any) => any;
    COMMA(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RemoveHandlerStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REMOVEHANDLER(): any;
    expression: (i: any) => any;
    COMMA(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AssignmentStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    regularAssignmentStatement(): any;
    compoundAssignmentStatement(): any;
    midAssignmentStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RegularAssignmentStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    EQUALS(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CompoundAssignmentStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    compoundBinaryOperator(): any;
    statementTerminator(): any;
    LINE_TERMINATOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CompoundBinaryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CARET(): any;
    EQUALS(): any;
    ASTERISK(): any;
    SLASH(): any;
    DOUBLE_BACK_SLASH(): any;
    PLUS(): any;
    MINUS(): any;
    AMPERSAND(): any;
    LEFT_ARROW: (i: any) => any;
    RIGHT_ARROW: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MidAssignmentStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MID(): any;
    LEFT_PAREN(): any;
    expression: (i: any) => any;
    COMMA: (i: any) => any;
    RIGHT_PAREN(): any;
    EQUALS(): any;
    statementTerminator(): any;
    DOLLAR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InvocationStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    statementTerminator(): any;
    CALL(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    argumentList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConditionalStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ifStatement(): any;
    selectStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IfStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    blockIfStatement(): any;
    lineIfThenStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BlockIfStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IF: (i: any) => any;
    booleanExpression(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    THEN(): any;
    block(): any;
    elseIfStatement: (i: any) => any;
    elseStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ElseIfStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    elseIf(): any;
    booleanExpression(): any;
    statementTerminator(): any;
    THEN(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ElseStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ELSE(): any;
    statementTerminator(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LineIfThenStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IF(): any;
    booleanExpression(): any;
    THEN(): any;
    statements: (i: any) => any;
    statementTerminator(): any;
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SelectStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SELECT: (i: any) => any;
    expression(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    CASE(): any;
    caseStatement: (i: any) => any;
    caseElseStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CASE(): any;
    caseClauses(): any;
    statementTerminator(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseClausesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    caseClause: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    comparisonOperator(): any;
    expression: (i: any) => any;
    IS(): any;
    LINE_TERMINATOR: (i: any) => any;
    TO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ComparisonOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EQUALS(): any;
    LEFT_ARROW(): any;
    RIGHT_ARROW(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseElseStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CASE(): any;
    ELSE(): any;
    statementTerminator(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LoopStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    whileStatement(): any;
    doLoopStatement(): any;
    forStatement(): any;
    forEachStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WhileStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WHILE: (i: any) => any;
    booleanExpression(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DoLoopStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    doTopLoopStatement(): any;
    doBottomLoopStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DoTopLoopStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DO(): any;
    statementTerminator: (i: any) => any;
    LOOP(): any;
    whileOrUntil(): any;
    booleanExpression(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DoBottomLoopStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DO(): any;
    statementTerminator: (i: any) => any;
    LOOP(): any;
    whileOrUntil(): any;
    booleanExpression(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WhileOrUntilContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WHILE(): any;
    UNTIL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FOR(): any;
    loopControlVariable(): any;
    EQUALS(): any;
    expression: (i: any) => any;
    TO(): any;
    statementTerminator: (i: any) => any;
    STEP(): any;
    block(): any;
    NEXT(): any;
    nextExpressionList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LoopControlVariableContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    identifierModifiers(): any;
    AS(): any;
    typeName(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NextExpressionListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForEachStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FOR(): any;
    EACH(): any;
    loopControlVariable(): any;
    IN(): any;
    expression(): any;
    statementTerminator: (i: any) => any;
    LINE_TERMINATOR(): any;
    block(): any;
    NEXT(): any;
    nextExpressionList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ErrorHandlingStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    structuredErrorStatement(): any;
    unstructuredErrorStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StructuredErrorStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    throwStatement(): any;
    tryStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TryStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    TRY: (i: any) => any;
    statementTerminator: (i: any) => any;
    END(): any;
    block(): any;
    catchStatement: (i: any) => any;
    finallyStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FinallyStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FINALLY(): any;
    statementTerminator(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CatchStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CATCH(): any;
    statementTerminator(): any;
    identifier(): any;
    WHEN(): any;
    booleanExpression(): any;
    block(): any;
    AS(): any;
    nonArrayTypeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ThrowStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    THROW(): any;
    statementTerminator(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UnstructuredErrorStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    errorStatement(): any;
    onErrorStatement(): any;
    resumeStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ErrorStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ERROR(): any;
    expression(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OnErrorStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ON(): any;
    ERROR(): any;
    errorClause(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ErrorClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GOTO(): any;
    MINUS(): any;
    ONE(): any;
    ZERO(): any;
    goToStatement(): any;
    RESUME(): any;
    NEXT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ResumeStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RESUME(): any;
    statementTerminator(): any;
    resumeClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ResumeClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NEXT(): any;
    labelName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BranchStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    goToStatement(): any;
    exitStatement(): any;
    continueStatement(): any;
    stopStatement(): any;
    endStatement(): any;
    returnStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GoToStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GOTO(): any;
    labelName(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExitStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EXIT(): any;
    exitKind(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExitKindContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DO(): any;
    FOR(): any;
    WHILE(): any;
    SELECT(): any;
    SUB(): any;
    FUNCTION(): any;
    PROPERTY(): any;
    TRY(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ContinueStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CONTINUE(): any;
    continueKind(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ContinueKindContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DO(): any;
    FOR(): any;
    WHILE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StopStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STOP(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EndStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    END(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ReturnStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RETURN(): any;
    statementTerminator(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayHandlingStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    redimStatement(): any;
    eraseStatement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RedimStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REDIM(): any;
    redimClauses(): any;
    statementTerminator(): any;
    PRESERVE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RedimClausesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    redimClause: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RedimClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    arraySizeInitializationModifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EraseStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ERASE(): any;
    eraseExpressions(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EraseExpressionsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UsingStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    USING: (i: any) => any;
    usingResources(): any;
    statementTerminator: (i: any) => any;
    END(): any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UsingResourcesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variableDeclarators(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AwaitStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    awaitOperatorExpression(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class YieldStatementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    YIELD(): any;
    expression(): any;
    statementTerminator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    simpleExpression(): any;
    getTypeExpression(): any;
    typeOfIsExpression(): any;
    getXmlNamespaceExpression(): any;
    newExpression(): any;
    castExpression(): any;
    unaryPlusExpression(): any;
    unaryMinusExpression(): any;
    NOT(): any;
    expression: (i: any) => any;
    awaitOperatorExpression(): any;
    conditionalExpression(): any;
    lambdaExpression(): any;
    queryExpression(): any;
    xMLLiteralExpression(): any;
    PERIOD: (i: any) => any;
    identifierOrKeyword(): any;
    memberAccessBase(): any;
    LEFT_PAREN: (i: any) => any;
    OF(): any;
    typeArgumentList(): any;
    RIGHT_PAREN: (i: any) => any;
    IS(): any;
    LINE_TERMINATOR: (i: any) => any;
    ISNOT(): any;
    PLUS(): any;
    MINUS(): any;
    ASTERISK(): any;
    SLASH(): any;
    DOUBLE_BACK_SLASH(): any;
    MOD(): any;
    CARET(): any;
    EQUALS(): any;
    LEFT_ARROW: (i: any) => any;
    RIGHT_ARROW: (i: any) => any;
    LIKE(): any;
    AMPERSAND(): any;
    ANDALSO(): any;
    ORELSE(): any;
    AND(): any;
    OR(): any;
    XOR(): any;
    xMLQualifiedName(): any;
    AT(): any;
    argumentList: (i: any) => any;
    EXCLAMATION(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MemberAccessBaseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    nonArrayTypeName(): any;
    GLOBAL(): any;
    MYCLASS(): any;
    MYBASE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstantExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SimpleExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    literalExpression(): any;
    parenthesizedExpression(): any;
    instanceExpression(): any;
    simpleNameExpression(): any;
    addressOfExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LiteralExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    literal(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ParenthesizedExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    expression(): any;
    RIGHT_PAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InstanceExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ME(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SimpleNameExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    LEFT_PAREN(): any;
    OF(): any;
    typeArgumentList(): any;
    RIGHT_PAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AddressOfExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ADDRESSOF(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GetTypeExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GETTYPE(): any;
    LEFT_PAREN(): any;
    getTypeTypeName(): any;
    RIGHT_PAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GetTypeTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    typeName(): any;
    qualifiedOpenTypeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QualifiedOpenTypeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    typeArityList: (i: any) => any;
    PERIOD: (i: any) => any;
    identifierOrKeyword: (i: any) => any;
    GLOBAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeArityListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_PAREN(): any;
    OF(): any;
    RIGHT_PAREN(): any;
    commaList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CommaListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeOfIsExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    TYPEOF(): any;
    expression(): any;
    IS(): any;
    typeName(): any;
    LINE_TERMINATOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GetXmlNamespaceExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GET_XML_NAMESPACE(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    xMLNamespaceName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgumentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    positionalArgumentList(): any;
    COMMA(): any;
    namedArgumentList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PositionalArgumentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NamedArgumentListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifierOrKeyword: (i: any) => any;
    COLON: (i: any) => any;
    EQUALS: (i: any) => any;
    expression: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NewExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    objectCreationExpression(): any;
    arrayExpression(): any;
    anonymousObjectCreationExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ObjectCreationExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NEW(): any;
    nonArrayTypeName(): any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    objectCreationExpressionInitializer(): any;
    argumentList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ObjectCreationExpressionInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    objectMemberInitializer(): any;
    objectCollectionInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ObjectMemberInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WITH(): any;
    LEFT_BRACE(): any;
    fieldInitializerList(): any;
    RIGHT_BRACE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FieldInitializerListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fieldInitializer: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FieldInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    KEY(): any;
    PERIOD(): any;
    identifierOrKeyword(): any;
    EQUALS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ObjectCollectionInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FROM(): any;
    collectionInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CollectionInitializerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_BRACE(): any;
    RIGHT_BRACE(): any;
    collectionElementList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CollectionElementListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    collectionElement: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CollectionElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    collectionInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    arrayCreationExpression(): any;
    arrayLiteralExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayCreationExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NEW(): any;
    nonArrayTypeName(): any;
    arrayNameModifier(): any;
    collectionInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArrayLiteralExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    collectionInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AnonymousObjectCreationExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NEW(): any;
    objectMemberInitializer(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CastExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DIRECTCAST(): any;
    LEFT_PAREN(): any;
    expression(): any;
    COMMA(): any;
    typeName(): any;
    RIGHT_PAREN(): any;
    TRYCAST(): any;
    CTYPE(): any;
    castTarget(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CastTargetContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CBOOL(): any;
    CBYTE(): any;
    CCHAR(): any;
    CDATE(): any;
    CDEC(): any;
    CDBL(): any;
    CINT(): any;
    CLNG(): any;
    COBJ(): any;
    CSBYTE(): any;
    CSHORT(): any;
    CSNG(): any;
    CSTR(): any;
    CUINT(): any;
    CULNG(): any;
    CUSHORT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UnaryPlusExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PLUS(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UnaryMinusExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MINUS(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BooleanExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LambdaExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    singleLineLambda(): any;
    multiLineLambda(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SingleLineLambdaContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FUNCTION(): any;
    expression(): any;
    lambdaModifier: (i: any) => any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    parameterList(): any;
    SUB(): any;
    statement(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MultiLineLambdaContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    multiLineFunctionLambda(): any;
    multiLineSubLambda(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MultiLineFunctionLambdaContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FUNCTION: (i: any) => any;
    LINE_TERMINATOR(): any;
    block(): any;
    END(): any;
    lambdaModifier: (i: any) => any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    AS(): any;
    typeName(): any;
    parameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MultiLineSubLambdaContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SUB: (i: any) => any;
    LINE_TERMINATOR(): any;
    block(): any;
    END(): any;
    lambdaModifier: (i: any) => any;
    LEFT_PAREN(): any;
    RIGHT_PAREN(): any;
    parameterList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LambdaModifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ASYNC(): any;
    ITERATOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QueryExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fromOrAggregateQueryOperator(): any;
    queryOperator: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FromOrAggregateQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fromQueryOperator(): any;
    aggregateQueryOperator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class QueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    fromQueryOperator(): any;
    aggregateQueryOperator(): any;
    selectQueryOperator(): any;
    distinctQueryOperator(): any;
    whereQueryOperator(): any;
    orderByQueryOperator(): any;
    partitionQueryOperator(): any;
    letQueryOperator(): any;
    groupByQueryOperator(): any;
    joinOrGroupJoinQueryOperator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class JoinOrGroupJoinQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    joinQueryOperator(): any;
    groupJoinQueryOperator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CollectionRangeVariableDeclarationListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    collectionRangeVariableDeclaration: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CollectionRangeVariableDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    IN(): any;
    expression(): any;
    AS(): any;
    typeName(): any;
    LINE_TERMINATOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionRangeVariableDeclarationListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expressionRangeVariableDeclaration: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExpressionRangeVariableDeclarationContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    identifier(): any;
    EQUALS(): any;
    expression(): any;
    AS(): any;
    typeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FromQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FROM(): any;
    collectionRangeVariableDeclarationList(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class JoinQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    JOIN(): any;
    collectionRangeVariableDeclaration(): any;
    ON(): any;
    joinConditionList(): any;
    LINE_TERMINATOR: (i: any) => any;
    joinOrGroupJoinQueryOperator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class JoinConditionListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    joinCondition: (i: any) => any;
    AND: (i: any) => any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class JoinConditionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression: (i: any) => any;
    EQUALSKEYWORD(): any;
    LINE_TERMINATOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LetQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LET(): any;
    expressionRangeVariableDeclarationList(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SelectQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SELECT(): any;
    expressionRangeVariableDeclarationList(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DistinctQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DISTINCT(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WhereQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WHERE(): any;
    booleanExpression(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PartitionQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    TAKE(): any;
    expression(): any;
    LINE_TERMINATOR: (i: any) => any;
    WHILE(): any;
    booleanExpression(): any;
    SKIP_KEYWORD(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OrderByQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ORDER(): any;
    BY(): any;
    orderExpressionList(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OrderExpressionListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    orderExpression: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OrderExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    expression(): any;
    ordering(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OrderingContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ASCENDING(): any;
    DESCENDING(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GroupByQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GROUP(): any;
    BY(): any;
    expressionRangeVariableDeclarationList: (i: any) => any;
    INTO(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AggregateQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AGGREGATE(): any;
    collectionRangeVariableDeclaration(): any;
    INTO(): any;
    expressionRangeVariableDeclarationList(): any;
    LINE_TERMINATOR: (i: any) => any;
    queryOperator: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GroupJoinQueryOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GROUP(): any;
    JOIN(): any;
    collectionRangeVariableDeclaration(): any;
    ON(): any;
    joinConditionList(): any;
    INTO(): any;
    expressionRangeVariableDeclarationList(): any;
    LINE_TERMINATOR: (i: any) => any;
    joinOrGroupJoinQueryOperator(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConditionalExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IF(): any;
    LEFT_PAREN(): any;
    booleanExpression(): any;
    COMMA: (i: any) => any;
    expression: (i: any) => any;
    RIGHT_PAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLLiteralExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLDocument(): any;
    xMLElement(): any;
    xMLProcessingInstruction(): any;
    xMLComment(): any;
    xMLCDATASection(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLEmbeddedExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    PERCENT: (i: any) => any;
    EQUALS(): any;
    expression(): any;
    RIGHT_ARROW(): any;
    LINE_TERMINATOR: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLDocumentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLDocumentPrologue(): any;
    xMLDocumentBody(): any;
    xMLMisc: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLDocumentPrologueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    QUESTION_MARK: (i: any) => any;
    XML(): any;
    xMLVersion(): any;
    RIGHT_ARROW(): any;
    xMLEncoding(): any;
    xMLStandalone(): any;
    XMLWhitespace(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLVersionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLWhitespace: (i: any) => any;
    VERSION(): any;
    EQUALS(): any;
    xMLVersionNumberValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLVersionNumberValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SINGLE_QUOTE_CHAR: (i: any) => any;
    ONE(): any;
    PERIOD(): any;
    ZERO(): any;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLEncodingContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLWhitespace: (i: any) => any;
    ENCODING(): any;
    EQUALS(): any;
    xMLEncodingNameValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLEncodingNameValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SINGLE_QUOTE_CHAR: (i: any) => any;
    xMLEncodingName(): any;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLEncodingNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLLatinAlphaCharacter(): any;
    xMLEncodingNameCharacter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLEncodingNameCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLUnderscoreCharacter(): any;
    XMLLatinAlphaCharacter(): any;
    XMLNumericCharacter(): any;
    XMLPeriodCharacter(): any;
    XMLDashCharacter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLStandaloneContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLWhitespace: (i: any) => any;
    STANDALONE(): any;
    EQUALS(): any;
    xMLYesNoValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLYesNoValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SINGLE_QUOTE_CHAR: (i: any) => any;
    xMLYesNo(): any;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLYesNoContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    YES(): any;
    NO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLMiscContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLComment(): any;
    xMLProcessingInstruction(): any;
    XMLWhitespace(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLDocumentBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLElement(): any;
    xMLEmbeddedExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLEmptyElement(): any;
    xMLElementStart(): any;
    xMLContent(): any;
    xMLElementEnd(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLEmptyElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    xMLQualifiedNameOrExpression(): any;
    SLASH(): any;
    RIGHT_ARROW(): any;
    xMLAttribute: (i: any) => any;
    XMLWhitespace(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLElementStartContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    xMLQualifiedNameOrExpression(): any;
    RIGHT_ARROW(): any;
    xMLAttribute: (i: any) => any;
    XMLWhitespace(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLElementEndContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    SLASH(): any;
    RIGHT_ARROW(): any;
    xMLQualifiedName(): any;
    XMLWhitespace(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLContentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLCharacterData: (i: any) => any;
    xMLNestedContent: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLNestedContentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLElement(): any;
    xMLReference(): any;
    xMLCDATASection(): any;
    xMLProcessingInstruction(): any;
    xMLComment(): any;
    xMLEmbeddedExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLAttributeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLWhitespace: (i: any) => any;
    xMLAttributeName(): any;
    EQUALS(): any;
    xMLAttributeValue(): any;
    xMLEmbeddedExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLAttributeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLQualifiedNameOrExpression(): any;
    xMLNamespaceAttributeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLAttributeValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOUBLE_QUOTE_CHARACTER: (i: any) => any;
    xMLAttributeDoubleQuoteValueCharacter: (i: any) => any;
    SINGLE_QUOTE_CHAR: (i: any) => any;
    xMLAttributeSingleQuoteValueCharacter: (i: any) => any;
    xMLEmbeddedExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLAttributeDoubleQuoteValueCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLNotDoubleQuote(): any;
    xMLReference(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLAttributeSingleQuoteValueCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLNotSingleQuote(): any;
    xMLReference(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLReferenceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLEntityReference(): any;
    xMLCharacterReference(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLEntityReferenceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AMPERSAND(): any;
    XMLEntityName(): any;
    SEMICOLON(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLCharacterReferenceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AMPERSAND(): any;
    POUND(): any;
    SEMICOLON(): any;
    XMLNumericCharacter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLNamespaceAttributeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLPrefixedNamespaceAttributeName(): any;
    xMLDefaultNamespaceAttributeName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLPrefixedNamespaceAttributeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLNS(): any;
    COLON(): any;
    xMLNamespaceName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLDefaultNamespaceAttributeNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLNS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLNamespaceNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLNamespaceNameStartCharacter(): any;
    xMLNamespaceNameCharacter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLNamespaceNameCharacterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    XMLLetter(): any;
    UNDERSCORE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLQualifiedNameOrExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLQualifiedName(): any;
    xMLEmbeddedExpression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLQualifiedNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLPrefixedName(): any;
    xMLUnprefixedName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLPrefixedNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLNamespaceName: (i: any) => any;
    COLON(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLUnprefixedNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    xMLNamespaceName(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLProcessingInstructionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    QUESTION_MARK: (i: any) => any;
    XMLProcessingTarget(): any;
    RIGHT_ARROW(): any;
    XMLWhitespace(): any;
    XMLProcessingValue(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLCommentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    EXCLAMATION(): any;
    MINUS: (i: any) => any;
    RIGHT_ARROW(): any;
    XMLCommentCharacter: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class XMLCDATASectionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LEFT_ARROW(): any;
    EXCLAMATION(): any;
    RIGHT_ARROW(): any;
    CDATA(): any;
    LEFT_SQUARE_BRACKET(): any;
    RIGHT_SQUARE_BRACKET(): any;
    XMLCDATASectionString(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AwaitOperatorExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AWAIT(): any;
    expression(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
//# sourceMappingURL=vbParser.d.ts.map
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HandlebarsGenerator = void 0;
const await_semaphore_1 = require("await-semaphore");
const fs_1 = __importDefault(require("fs"));
const handlebars_1 = __importDefault(require("handlebars"));
const path_1 = __importDefault(require("path"));
const AbstractSingularBuilder_1 = require("../../runtime/AbstractSingularBuilder");
const TemplateFactory_1 = require("../../runtime/TemplateFactory");
const FileArtifact_1 = require("../../system/FileArtifact");
const System_1 = require("../../system/System");
const SystemComponent_1 = require("../../system/SystemComponent");
const ValueType_1 = require("../../system/ValueType");
const LogAsyncMethod_1 = require("../../util/LogAsyncMethod");
const LanguageHelpers_1 = require("./LanguageHelpers");
const MiscHelpers_1 = require("./MiscHelpers");
const StringHelpers_1 = require("./StringHelpers");
const WordHelpers_1 = require("./WordHelpers");
class HandlebarsGenerator extends AbstractSingularBuilder_1.AbstractSingularBuilder {
    constructor(configurationValues) {
        super('HandlebarsGenerator', 'A generator that uses a handlebar template and the system definition to produce artifacts', {
            templatePath: HandlebarsGenerator.templatePathParameterDefinition,
            templateName: HandlebarsGenerator.templateNameParameterDefinition,
            targetPath: HandlebarsGenerator.targetPathParameterDefinition,
            fileNamePattern: HandlebarsGenerator.fileNamePatternParameterDefinition,
            fileNameFunction: HandlebarsGenerator.fileNameFunctionParameterDefinition,
            repeatFor: HandlebarsGenerator.repeatForParameterDefinition,
            overwrite: HandlebarsGenerator.overwriteParameterDefinition,
        }, configurationValues);
    }
    async getTemplateBody() {
        const templateName = this.getConfiguredValue('templateName');
        return templateName ? TemplateFactory_1.TemplateFactory.getTemplate(templateName) : fs_1.default.readFileSync(this.getConfiguredValue('templatePath'), 'utf-8');
    }
    async _doesConfigurationWork() {
        const templateBody = this.getTemplateBody();
        if (!templateBody) {
            const templateName = this.getConfiguredValue('templateName');
            if (templateName)
                this.logger.error(`_doesConfigurationWork() could not load registered template ${templateName}`);
            else {
                const templatePath = this.getConfiguredValue('templatePath');
                this.logger.error(`_doesConfigurationWork() could not load template from file ${templatePath}`);
            }
            return false;
        }
        const repeatForString = this.getConfiguredValue('repeatFor');
        const targetPath = this.getConfiguredValue('targetPath');
        if (repeatForString != null && repeatForString != 0) {
            if (!fs_1.default.existsSync(targetPath)) {
                this.logger.error(`_doesConfigurationWork(${targetPath}) does not exist`);
                return false;
            }
        }
        else {
            const directory = path_1.default.dirname(targetPath);
            if (!fs_1.default.existsSync(directory)) {
                this.logger.error(`_doesConfigurationWork(${targetPath}) does not exist`);
                return false;
            }
        }
        return true;
    }
    async registerHelpers() {
        const semaphore = new await_semaphore_1.Semaphore(10);
        const release = await semaphore.acquire();
        try {
            if (HandlebarsGenerator.helpersRegistered)
                return;
            LanguageHelpers_1.LanguageHelpers.registerAll();
            WordHelpers_1.WordHelpers.registerAll();
            StringHelpers_1.StringHelpers.registerAll();
            MiscHelpers_1.MiscHelpers.registerAll();
            const handlebars = require('handlebars-helpers')();
            for (const helperKey in handlebars) {
                const helper = handlebars[helperKey];
                handlebars_1.default.registerHelper(helperKey, helper);
            }
            HandlebarsGenerator.helpersRegistered = true;
        }
        finally {
            release();
        }
    }
    async performTemplate(template, source, fullTargetPath, options) {
        const newContent = template(source, options);
        if (fs_1.default.existsSync(fullTargetPath))
            await fs_1.default.promises.unlink(fullTargetPath);
        await fs_1.default.promises.writeFile(fullTargetPath, newContent, {
            encoding: 'utf8',
            flag: 'wx',
            mode: 0o666,
        });
    }
    getFileName(targetPath, fileNamePattern, fileNameFunctionAsString, systemObject) {
        let fileName;
        if (fileNameFunctionAsString != null) {
            try {
                const fileNameFunction = eval(fileNameFunctionAsString);
                const nominalName = fileNameFunction(systemObject);
                if (systemObject instanceof System_1.System)
                    fileName = `${targetPath}`;
                else
                    fileName = `${targetPath}/${nominalName}`;
            }
            catch (problem) {
                this.logger.error(`buildInternal(${this.name}) could not generate file name ${problem}`);
                throw problem;
            }
        }
        else {
            if (systemObject instanceof System_1.System)
                fileName = `${targetPath.replace('%n', systemObject.name)}`;
            else
                fileName = `${targetPath}/${fileNamePattern.replace('%n', systemObject.name)}`;
        }
        return fileName;
    }
    async buildInternal(__system, component) {
        const templateBody = await this.getTemplateBody();
        const targetPath = this.getConfiguredValue('targetPath');
        const overwrite = this.getConfiguredValue('overwrite');
        const fileNamePattern = this.getConfiguredValue('fileNamePattern');
        const fileNameFunction = this.getConfiguredValue('fileNameFunction');
        this.registerHelpers();
        const template = await handlebars_1.default.compile(templateBody, {
            noEscape: true,
        });
        const options = { allowProtoPropertiesByDefault: true };
        const fileName = this.getFileName(targetPath, fileNamePattern, fileNameFunction, component);
        if (overwrite || !fs_1.default.existsSync(fileName))
            await this.performTemplate(template, component, fileName, options);
        return [new FileArtifact_1.FileArtifact(fileName, targetPath)];
    }
}
HandlebarsGenerator.helpersRegistered = false;
HandlebarsGenerator.templatePathParameterDefinition = {
    name: 'Template Path',
    required: true,
    description: 'The url to the template that is to generate',
    valueType: ValueType_1.ValueType.STRING,
    defaultValue: ``,
};
HandlebarsGenerator.templateNameParameterDefinition = {
    name: 'The name of a template registered with a plugin',
    required: true,
    description: 'The name of the template to use. This is specified in plugins and the full name is the plugin name, forward slash, template name. For example builtIn/handlebars/SystemAsJson',
    valueType: ValueType_1.ValueType.STRING,
    defaultValue: ``,
};
HandlebarsGenerator.targetPathParameterDefinition = {
    name: 'Target Path',
    required: true,
    description: 'The path to where the output is placed',
    valueType: ValueType_1.ValueType.STRING,
};
HandlebarsGenerator.fileNamePatternParameterDefinition = {
    name: 'File Name Pattern',
    required: true,
    description: 'A pattern used to determine the name of the file to write to. The generator will replace an occurrence of %n with the name of the current object',
    valueType: ValueType_1.ValueType.STRING,
    defaultValue: '%n.ts',
};
HandlebarsGenerator.fileNameFunctionParameterDefinition = {
    name: 'File Name Function',
    required: false,
    description: 'A Javascript function that is given the evaluation object and returns a string representing the name of the file that should be created. If this is present, it takes precedence of FileNamePattern',
    valueType: ValueType_1.ValueType.STRING,
};
HandlebarsGenerator.repeatForParameterDefinition = {
    name: 'Repeat for',
    required: true,
    description: 'A parsable string of JSON that represents the properties values of the component that should be iterated on, review the documentation for SystemDescendantComponent and derivations for most available for use',
    valueType: ValueType_1.ValueType.STRING,
    defaultValue: ``,
};
HandlebarsGenerator.overwriteParameterDefinition = {
    name: 'Over write',
    required: true,
    description: 'Write over any existing file',
    valueType: ValueType_1.ValueType.BOOLEAN,
    defaultValue: true,
};
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], HandlebarsGenerator.prototype, "getTemplateBody", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object, String, Object]),
    __metadata("design:returntype", Promise)
], HandlebarsGenerator.prototype, "performTemplate", null);
__decorate([
    (0, LogAsyncMethod_1.LogAsyncMethod)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [System_1.System, SystemComponent_1.SystemComponent]),
    __metadata("design:returntype", Promise)
], HandlebarsGenerator.prototype, "buildInternal", null);
exports.HandlebarsGenerator = HandlebarsGenerator;

export function Python3Parser(input: any): this;
export class Python3Parser {
    constructor(input: any);
    _interp: any;
    ruleNames: string[];
    literalNames: (string | null)[];
    symbolicNames: (string | null)[];
    constructor: typeof Python3Parser;
    get atn(): any;
    single_input(): Single_inputContext;
    state: number | undefined;
    file_input(): File_inputContext;
    eval_input(): Eval_inputContext;
    decorator(): DecoratorContext;
    decorators(): DecoratorsContext;
    decorated(): DecoratedContext;
    async_funcdef(): Async_funcdefContext;
    funcdef(): FuncdefContext;
    parameters(): ParametersContext;
    typedargslist(): TypedargslistContext;
    tfpdef(): TfpdefContext;
    varargslist(): VarargslistContext;
    vfpdef(): VfpdefContext;
    stmt(): StmtContext;
    simple_stmt(): Simple_stmtContext;
    small_stmt(): Small_stmtContext;
    expr_stmt(): Expr_stmtContext;
    annassign(): AnnassignContext;
    testlist_star_expr(): Testlist_star_exprContext;
    augassign(): AugassignContext;
    del_stmt(): Del_stmtContext;
    pass_stmt(): Pass_stmtContext;
    flow_stmt(): Flow_stmtContext;
    break_stmt(): Break_stmtContext;
    continue_stmt(): Continue_stmtContext;
    return_stmt(): Return_stmtContext;
    yield_stmt(): Yield_stmtContext;
    raise_stmt(): Raise_stmtContext;
    import_stmt(): Import_stmtContext;
    import_name(): Import_nameContext;
    import_from(): Import_fromContext;
    import_as_name(): Import_as_nameContext;
    dotted_as_name(): Dotted_as_nameContext;
    import_as_names(): Import_as_namesContext;
    dotted_as_names(): Dotted_as_namesContext;
    dotted_name(): Dotted_nameContext;
    global_stmt(): Global_stmtContext;
    nonlocal_stmt(): Nonlocal_stmtContext;
    assert_stmt(): Assert_stmtContext;
    compound_stmt(): Compound_stmtContext;
    async_stmt(): Async_stmtContext;
    if_stmt(): If_stmtContext;
    while_stmt(): While_stmtContext;
    for_stmt(): For_stmtContext;
    try_stmt(): Try_stmtContext;
    with_stmt(): With_stmtContext;
    with_item(): With_itemContext;
    except_clause(): Except_clauseContext;
    suite(): SuiteContext;
    test(): TestContext;
    test_nocond(): Test_nocondContext;
    lambdef(): LambdefContext;
    lambdef_nocond(): Lambdef_nocondContext;
    or_test(): Or_testContext;
    and_test(): And_testContext;
    not_test(): Not_testContext;
    comparison(): ComparisonContext;
    comp_op(): Comp_opContext;
    star_expr(): Star_exprContext;
    expr(): ExprContext;
    xor_expr(): Xor_exprContext;
    and_expr(): And_exprContext;
    shift_expr(): Shift_exprContext;
    arith_expr(): Arith_exprContext;
    term(): TermContext;
    factor(): FactorContext;
    power(): PowerContext;
    atom_expr(): Atom_exprContext;
    atom(): AtomContext;
    testlist_comp(): Testlist_compContext;
    trailer(): TrailerContext;
    subscriptlist(): SubscriptlistContext;
    subscript(): SubscriptContext;
    sliceop(): SliceopContext;
    exprlist(): ExprlistContext;
    testlist(): TestlistContext;
    dictorsetmaker(): DictorsetmakerContext;
    classdef(): ClassdefContext;
    arglist(): ArglistContext;
    argument(): ArgumentContext;
    comp_iter(): Comp_iterContext;
    comp_for(): Comp_forContext;
    comp_if(): Comp_ifContext;
    encoding_decl(): Encoding_declContext;
    yield_expr(): Yield_exprContext;
    yield_arg(): Yield_argContext;
}
export namespace Python3Parser {
    export const EOF: any;
    export const INDENT: number;
    export const DEDENT: number;
    export const STRING: number;
    export const NUMBER: number;
    export const INTEGER: number;
    export const DEF: number;
    export const RETURN: number;
    export const RAISE: number;
    export const FROM: number;
    export const IMPORT: number;
    export const AS: number;
    export const GLOBAL: number;
    export const NONLOCAL: number;
    export const ASSERT: number;
    export const IF: number;
    export const ELIF: number;
    export const ELSE: number;
    export const WHILE: number;
    export const FOR: number;
    export const IN: number;
    export const TRY: number;
    export const FINALLY: number;
    export const WITH: number;
    export const EXCEPT: number;
    export const LAMBDA: number;
    export const OR: number;
    export const AND: number;
    export const NOT: number;
    export const IS: number;
    export const NONE: number;
    export const TRUE: number;
    export const FALSE: number;
    export const CLASS: number;
    export const YIELD: number;
    export const DEL: number;
    export const PASS: number;
    export const CONTINUE: number;
    export const BREAK: number;
    export const ASYNC: number;
    export const AWAIT: number;
    export const NEWLINE: number;
    export const NAME: number;
    export const STRING_LITERAL: number;
    export const BYTES_LITERAL: number;
    export const DECIMAL_INTEGER: number;
    export const OCT_INTEGER: number;
    export const HEX_INTEGER: number;
    export const BIN_INTEGER: number;
    export const FLOAT_NUMBER: number;
    export const IMAG_NUMBER: number;
    export const DOT: number;
    export const ELLIPSIS: number;
    export const STAR: number;
    export const OPEN_PAREN: number;
    export const CLOSE_PAREN: number;
    export const COMMA: number;
    export const COLON: number;
    export const SEMI_COLON: number;
    export const POWER: number;
    export const ASSIGN: number;
    export const OPEN_BRACK: number;
    export const CLOSE_BRACK: number;
    export const OR_OP: number;
    export const XOR: number;
    export const AND_OP: number;
    export const LEFT_SHIFT: number;
    export const RIGHT_SHIFT: number;
    export const ADD: number;
    export const MINUS: number;
    export const DIV: number;
    export const MOD: number;
    export const IDIV: number;
    export const NOT_OP: number;
    export const OPEN_BRACE: number;
    export const CLOSE_BRACE: number;
    export const LESS_THAN: number;
    export const GREATER_THAN: number;
    export const EQUALS: number;
    export const GT_EQ: number;
    export const LT_EQ: number;
    export const NOT_EQ_1: number;
    export const NOT_EQ_2: number;
    export const AT: number;
    export const ARROW: number;
    export const ADD_ASSIGN: number;
    export const SUB_ASSIGN: number;
    export const MULT_ASSIGN: number;
    export const AT_ASSIGN: number;
    export const DIV_ASSIGN: number;
    export const MOD_ASSIGN: number;
    export const AND_ASSIGN: number;
    export const OR_ASSIGN: number;
    export const XOR_ASSIGN: number;
    export const LEFT_SHIFT_ASSIGN: number;
    export const RIGHT_SHIFT_ASSIGN: number;
    export const POWER_ASSIGN: number;
    export const IDIV_ASSIGN: number;
    export const SKIP_: number;
    export const UNKNOWN_CHAR: number;
    export const RULE_single_input: number;
    export const RULE_file_input: number;
    export const RULE_eval_input: number;
    export const RULE_decorator: number;
    export const RULE_decorators: number;
    export const RULE_decorated: number;
    export const RULE_async_funcdef: number;
    export const RULE_funcdef: number;
    export const RULE_parameters: number;
    export const RULE_typedargslist: number;
    export const RULE_tfpdef: number;
    export const RULE_varargslist: number;
    export const RULE_vfpdef: number;
    export const RULE_stmt: number;
    export const RULE_simple_stmt: number;
    export const RULE_small_stmt: number;
    export const RULE_expr_stmt: number;
    export const RULE_annassign: number;
    export const RULE_testlist_star_expr: number;
    export const RULE_augassign: number;
    export const RULE_del_stmt: number;
    export const RULE_pass_stmt: number;
    export const RULE_flow_stmt: number;
    export const RULE_break_stmt: number;
    export const RULE_continue_stmt: number;
    export const RULE_return_stmt: number;
    export const RULE_yield_stmt: number;
    export const RULE_raise_stmt: number;
    export const RULE_import_stmt: number;
    export const RULE_import_name: number;
    export const RULE_import_from: number;
    export const RULE_import_as_name: number;
    export const RULE_dotted_as_name: number;
    export const RULE_import_as_names: number;
    export const RULE_dotted_as_names: number;
    export const RULE_dotted_name: number;
    export const RULE_global_stmt: number;
    export const RULE_nonlocal_stmt: number;
    export const RULE_assert_stmt: number;
    export const RULE_compound_stmt: number;
    export const RULE_async_stmt: number;
    export const RULE_if_stmt: number;
    export const RULE_while_stmt: number;
    export const RULE_for_stmt: number;
    export const RULE_try_stmt: number;
    export const RULE_with_stmt: number;
    export const RULE_with_item: number;
    export const RULE_except_clause: number;
    export const RULE_suite: number;
    export const RULE_test: number;
    export const RULE_test_nocond: number;
    export const RULE_lambdef: number;
    export const RULE_lambdef_nocond: number;
    export const RULE_or_test: number;
    export const RULE_and_test: number;
    export const RULE_not_test: number;
    export const RULE_comparison: number;
    export const RULE_comp_op: number;
    export const RULE_star_expr: number;
    export const RULE_expr: number;
    export const RULE_xor_expr: number;
    export const RULE_and_expr: number;
    export const RULE_shift_expr: number;
    export const RULE_arith_expr: number;
    export const RULE_term: number;
    export const RULE_factor: number;
    export const RULE_power: number;
    export const RULE_atom_expr: number;
    export const RULE_atom: number;
    export const RULE_testlist_comp: number;
    export const RULE_trailer: number;
    export const RULE_subscriptlist: number;
    export const RULE_subscript: number;
    export const RULE_sliceop: number;
    export const RULE_exprlist: number;
    export const RULE_testlist: number;
    export const RULE_dictorsetmaker: number;
    export const RULE_classdef: number;
    export const RULE_arglist: number;
    export const RULE_argument: number;
    export const RULE_comp_iter: number;
    export const RULE_comp_for: number;
    export const RULE_comp_if: number;
    export const RULE_encoding_decl: number;
    export const RULE_yield_expr: number;
    export const RULE_yield_arg: number;
    export { Single_inputContext };
    export { File_inputContext };
    export { Eval_inputContext };
    export { DecoratorContext };
    export { DecoratorsContext };
    export { DecoratedContext };
    export { Async_funcdefContext };
    export { FuncdefContext };
    export { ParametersContext };
    export { TypedargslistContext };
    export { TfpdefContext };
    export { VarargslistContext };
    export { VfpdefContext };
    export { StmtContext };
    export { Simple_stmtContext };
    export { Small_stmtContext };
    export { Expr_stmtContext };
    export { AnnassignContext };
    export { Testlist_star_exprContext };
    export { AugassignContext };
    export { Del_stmtContext };
    export { Pass_stmtContext };
    export { Flow_stmtContext };
    export { Break_stmtContext };
    export { Continue_stmtContext };
    export { Return_stmtContext };
    export { Yield_stmtContext };
    export { Raise_stmtContext };
    export { Import_stmtContext };
    export { Import_nameContext };
    export { Import_fromContext };
    export { Import_as_nameContext };
    export { Dotted_as_nameContext };
    export { Import_as_namesContext };
    export { Dotted_as_namesContext };
    export { Dotted_nameContext };
    export { Global_stmtContext };
    export { Nonlocal_stmtContext };
    export { Assert_stmtContext };
    export { Compound_stmtContext };
    export { Async_stmtContext };
    export { If_stmtContext };
    export { While_stmtContext };
    export { For_stmtContext };
    export { Try_stmtContext };
    export { With_stmtContext };
    export { With_itemContext };
    export { Except_clauseContext };
    export { SuiteContext };
    export { TestContext };
    export { Test_nocondContext };
    export { LambdefContext };
    export { Lambdef_nocondContext };
    export { Or_testContext };
    export { And_testContext };
    export { Not_testContext };
    export { ComparisonContext };
    export { Comp_opContext };
    export { Star_exprContext };
    export { ExprContext };
    export { Xor_exprContext };
    export { And_exprContext };
    export { Shift_exprContext };
    export { Arith_exprContext };
    export { TermContext };
    export { FactorContext };
    export { PowerContext };
    export { Atom_exprContext };
    export { AtomContext };
    export { Testlist_compContext };
    export { TrailerContext };
    export { SubscriptlistContext };
    export { SubscriptContext };
    export { SliceopContext };
    export { ExprlistContext };
    export { TestlistContext };
    export { DictorsetmakerContext };
    export { ClassdefContext };
    export { ArglistContext };
    export { ArgumentContext };
    export { Comp_iterContext };
    export { Comp_forContext };
    export { Comp_ifContext };
    export { Encoding_declContext };
    export { Yield_exprContext };
    export { Yield_argContext };
}
declare function Single_inputContext(parser: any, parent: any, invokingState: any): this;
declare class Single_inputContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Single_inputContext;
    NEWLINE(): any;
    simple_stmt(): any;
    compound_stmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function File_inputContext(parser: any, parent: any, invokingState: any): this;
declare class File_inputContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof File_inputContext;
    EOF(): any;
    NEWLINE(i: any): any;
    stmt(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Eval_inputContext(parser: any, parent: any, invokingState: any): this;
declare class Eval_inputContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Eval_inputContext;
    testlist(): any;
    EOF(): any;
    NEWLINE(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DecoratorContext(parser: any, parent: any, invokingState: any): this;
declare class DecoratorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DecoratorContext;
    AT(): any;
    dotted_name(): any;
    NEWLINE(): any;
    OPEN_PAREN(): any;
    CLOSE_PAREN(): any;
    arglist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DecoratorsContext(parser: any, parent: any, invokingState: any): this;
declare class DecoratorsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DecoratorsContext;
    decorator(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DecoratedContext(parser: any, parent: any, invokingState: any): this;
declare class DecoratedContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DecoratedContext;
    decorators(): any;
    classdef(): any;
    funcdef(): any;
    async_funcdef(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Async_funcdefContext(parser: any, parent: any, invokingState: any): this;
declare class Async_funcdefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Async_funcdefContext;
    ASYNC(): any;
    funcdef(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FuncdefContext(parser: any, parent: any, invokingState: any): this;
declare class FuncdefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FuncdefContext;
    DEF(): any;
    NAME(): any;
    parameters(): any;
    COLON(): any;
    suite(): any;
    ARROW(): any;
    test(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ParametersContext(parser: any, parent: any, invokingState: any): this;
declare class ParametersContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ParametersContext;
    OPEN_PAREN(): any;
    CLOSE_PAREN(): any;
    typedargslist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TypedargslistContext(parser: any, parent: any, invokingState: any): this;
declare class TypedargslistContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TypedargslistContext;
    tfpdef(i: any): any;
    STAR(): any;
    POWER(): any;
    ASSIGN(i: any): any;
    test(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TfpdefContext(parser: any, parent: any, invokingState: any): this;
declare class TfpdefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TfpdefContext;
    NAME(): any;
    COLON(): any;
    test(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VarargslistContext(parser: any, parent: any, invokingState: any): this;
declare class VarargslistContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VarargslistContext;
    vfpdef(i: any): any;
    STAR(): any;
    POWER(): any;
    ASSIGN(i: any): any;
    test(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function VfpdefContext(parser: any, parent: any, invokingState: any): this;
declare class VfpdefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof VfpdefContext;
    NAME(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function StmtContext(parser: any, parent: any, invokingState: any): this;
declare class StmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof StmtContext;
    simple_stmt(): any;
    compound_stmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Simple_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Simple_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Simple_stmtContext;
    small_stmt(i: any): any;
    NEWLINE(): any;
    SEMI_COLON(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Small_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Small_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Small_stmtContext;
    expr_stmt(): any;
    del_stmt(): any;
    pass_stmt(): any;
    flow_stmt(): any;
    import_stmt(): any;
    global_stmt(): any;
    nonlocal_stmt(): any;
    assert_stmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Expr_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Expr_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Expr_stmtContext;
    testlist_star_expr(i: any): any;
    annassign(): any;
    augassign(): any;
    yield_expr(i: any): any;
    testlist(): any;
    ASSIGN(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AnnassignContext(parser: any, parent: any, invokingState: any): this;
declare class AnnassignContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AnnassignContext;
    COLON(): any;
    test(i: any): any;
    ASSIGN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Testlist_star_exprContext(parser: any, parent: any, invokingState: any): this;
declare class Testlist_star_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Testlist_star_exprContext;
    test(i: any): any;
    star_expr(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AugassignContext(parser: any, parent: any, invokingState: any): this;
declare class AugassignContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AugassignContext;
    ADD_ASSIGN(): any;
    SUB_ASSIGN(): any;
    MULT_ASSIGN(): any;
    AT_ASSIGN(): any;
    DIV_ASSIGN(): any;
    MOD_ASSIGN(): any;
    AND_ASSIGN(): any;
    OR_ASSIGN(): any;
    XOR_ASSIGN(): any;
    LEFT_SHIFT_ASSIGN(): any;
    RIGHT_SHIFT_ASSIGN(): any;
    POWER_ASSIGN(): any;
    IDIV_ASSIGN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Del_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Del_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Del_stmtContext;
    DEL(): any;
    exprlist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Pass_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Pass_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Pass_stmtContext;
    PASS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Flow_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Flow_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Flow_stmtContext;
    break_stmt(): any;
    continue_stmt(): any;
    return_stmt(): any;
    raise_stmt(): any;
    yield_stmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Break_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Break_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Break_stmtContext;
    BREAK(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Continue_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Continue_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Continue_stmtContext;
    CONTINUE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Return_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Return_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Return_stmtContext;
    RETURN(): any;
    testlist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Yield_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Yield_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Yield_stmtContext;
    yield_expr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Raise_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Raise_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Raise_stmtContext;
    RAISE(): any;
    test(i: any): any;
    FROM(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Import_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Import_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Import_stmtContext;
    import_name(): any;
    import_from(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Import_nameContext(parser: any, parent: any, invokingState: any): this;
declare class Import_nameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Import_nameContext;
    IMPORT(): any;
    dotted_as_names(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Import_fromContext(parser: any, parent: any, invokingState: any): this;
declare class Import_fromContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Import_fromContext;
    FROM(): any;
    IMPORT(): any;
    dotted_name(): any;
    STAR(): any;
    OPEN_PAREN(): any;
    import_as_names(): any;
    CLOSE_PAREN(): any;
    DOT(i: any): any;
    ELLIPSIS(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Import_as_nameContext(parser: any, parent: any, invokingState: any): this;
declare class Import_as_nameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Import_as_nameContext;
    NAME(i: any): any;
    AS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Dotted_as_nameContext(parser: any, parent: any, invokingState: any): this;
declare class Dotted_as_nameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Dotted_as_nameContext;
    dotted_name(): any;
    AS(): any;
    NAME(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Import_as_namesContext(parser: any, parent: any, invokingState: any): this;
declare class Import_as_namesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Import_as_namesContext;
    import_as_name(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Dotted_as_namesContext(parser: any, parent: any, invokingState: any): this;
declare class Dotted_as_namesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Dotted_as_namesContext;
    dotted_as_name(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Dotted_nameContext(parser: any, parent: any, invokingState: any): this;
declare class Dotted_nameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Dotted_nameContext;
    NAME(i: any): any;
    DOT(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Global_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Global_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Global_stmtContext;
    GLOBAL(): any;
    NAME(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Nonlocal_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Nonlocal_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Nonlocal_stmtContext;
    NONLOCAL(): any;
    NAME(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Assert_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Assert_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Assert_stmtContext;
    ASSERT(): any;
    test(i: any): any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Compound_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Compound_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Compound_stmtContext;
    if_stmt(): any;
    while_stmt(): any;
    for_stmt(): any;
    try_stmt(): any;
    with_stmt(): any;
    funcdef(): any;
    classdef(): any;
    decorated(): any;
    async_stmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Async_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Async_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Async_stmtContext;
    ASYNC(): any;
    funcdef(): any;
    with_stmt(): any;
    for_stmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function If_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class If_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof If_stmtContext;
    IF(): any;
    test(i: any): any;
    COLON(i: any): any;
    suite(i: any): any;
    ELIF(i: any): any;
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function While_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class While_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof While_stmtContext;
    WHILE(): any;
    test(): any;
    COLON(i: any): any;
    suite(i: any): any;
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function For_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class For_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof For_stmtContext;
    FOR(): any;
    exprlist(): any;
    IN(): any;
    testlist(): any;
    COLON(i: any): any;
    suite(i: any): any;
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Try_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class Try_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Try_stmtContext;
    TRY(): any;
    COLON(i: any): any;
    suite(i: any): any;
    FINALLY(): any;
    except_clause(i: any): any;
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function With_stmtContext(parser: any, parent: any, invokingState: any): this;
declare class With_stmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof With_stmtContext;
    WITH(): any;
    with_item(i: any): any;
    COLON(): any;
    suite(): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function With_itemContext(parser: any, parent: any, invokingState: any): this;
declare class With_itemContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof With_itemContext;
    test(): any;
    AS(): any;
    expr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Except_clauseContext(parser: any, parent: any, invokingState: any): this;
declare class Except_clauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Except_clauseContext;
    EXCEPT(): any;
    test(): any;
    AS(): any;
    NAME(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SuiteContext(parser: any, parent: any, invokingState: any): this;
declare class SuiteContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SuiteContext;
    simple_stmt(): any;
    NEWLINE(): any;
    INDENT(): any;
    DEDENT(): any;
    stmt(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TestContext(parser: any, parent: any, invokingState: any): this;
declare class TestContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TestContext;
    or_test(i: any): any;
    IF(): any;
    ELSE(): any;
    test(): any;
    lambdef(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Test_nocondContext(parser: any, parent: any, invokingState: any): this;
declare class Test_nocondContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Test_nocondContext;
    or_test(): any;
    lambdef_nocond(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function LambdefContext(parser: any, parent: any, invokingState: any): this;
declare class LambdefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof LambdefContext;
    LAMBDA(): any;
    COLON(): any;
    test(): any;
    varargslist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Lambdef_nocondContext(parser: any, parent: any, invokingState: any): this;
declare class Lambdef_nocondContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Lambdef_nocondContext;
    LAMBDA(): any;
    COLON(): any;
    test_nocond(): any;
    varargslist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Or_testContext(parser: any, parent: any, invokingState: any): this;
declare class Or_testContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Or_testContext;
    and_test(i: any): any;
    OR(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function And_testContext(parser: any, parent: any, invokingState: any): this;
declare class And_testContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof And_testContext;
    not_test(i: any): any;
    AND(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Not_testContext(parser: any, parent: any, invokingState: any): this;
declare class Not_testContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Not_testContext;
    NOT(): any;
    not_test(): any;
    comparison(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ComparisonContext(parser: any, parent: any, invokingState: any): this;
declare class ComparisonContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ComparisonContext;
    expr(i: any): any;
    comp_op(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Comp_opContext(parser: any, parent: any, invokingState: any): this;
declare class Comp_opContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Comp_opContext;
    LESS_THAN(): any;
    GREATER_THAN(): any;
    EQUALS(): any;
    GT_EQ(): any;
    LT_EQ(): any;
    NOT_EQ_1(): any;
    NOT_EQ_2(): any;
    IN(): any;
    NOT(): any;
    IS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Star_exprContext(parser: any, parent: any, invokingState: any): this;
declare class Star_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Star_exprContext;
    STAR(): any;
    expr(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExprContext(parser: any, parent: any, invokingState: any): this;
declare class ExprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExprContext;
    xor_expr(i: any): any;
    OR_OP(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Xor_exprContext(parser: any, parent: any, invokingState: any): this;
declare class Xor_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Xor_exprContext;
    and_expr(i: any): any;
    XOR(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function And_exprContext(parser: any, parent: any, invokingState: any): this;
declare class And_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof And_exprContext;
    shift_expr(i: any): any;
    AND_OP(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Shift_exprContext(parser: any, parent: any, invokingState: any): this;
declare class Shift_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Shift_exprContext;
    arith_expr(i: any): any;
    LEFT_SHIFT(i: any): any;
    RIGHT_SHIFT(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Arith_exprContext(parser: any, parent: any, invokingState: any): this;
declare class Arith_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Arith_exprContext;
    term(i: any): any;
    ADD(i: any): any;
    MINUS(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TermContext(parser: any, parent: any, invokingState: any): this;
declare class TermContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TermContext;
    factor(i: any): any;
    STAR(i: any): any;
    AT(i: any): any;
    DIV(i: any): any;
    MOD(i: any): any;
    IDIV(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function FactorContext(parser: any, parent: any, invokingState: any): this;
declare class FactorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof FactorContext;
    factor(): any;
    ADD(): any;
    MINUS(): any;
    NOT_OP(): any;
    power(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function PowerContext(parser: any, parent: any, invokingState: any): this;
declare class PowerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof PowerContext;
    atom_expr(): any;
    POWER(): any;
    factor(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Atom_exprContext(parser: any, parent: any, invokingState: any): this;
declare class Atom_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Atom_exprContext;
    atom(): any;
    AWAIT(): any;
    trailer(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function AtomContext(parser: any, parent: any, invokingState: any): this;
declare class AtomContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof AtomContext;
    OPEN_PAREN(): any;
    CLOSE_PAREN(): any;
    OPEN_BRACK(): any;
    CLOSE_BRACK(): any;
    OPEN_BRACE(): any;
    CLOSE_BRACE(): any;
    NAME(): any;
    NUMBER(): any;
    ELLIPSIS(): any;
    NONE(): any;
    TRUE(): any;
    FALSE(): any;
    yield_expr(): any;
    testlist_comp(): any;
    dictorsetmaker(): any;
    STRING(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Testlist_compContext(parser: any, parent: any, invokingState: any): this;
declare class Testlist_compContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Testlist_compContext;
    test(i: any): any;
    star_expr(i: any): any;
    comp_for(): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TrailerContext(parser: any, parent: any, invokingState: any): this;
declare class TrailerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TrailerContext;
    OPEN_PAREN(): any;
    CLOSE_PAREN(): any;
    arglist(): any;
    OPEN_BRACK(): any;
    subscriptlist(): any;
    CLOSE_BRACK(): any;
    DOT(): any;
    NAME(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SubscriptlistContext(parser: any, parent: any, invokingState: any): this;
declare class SubscriptlistContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SubscriptlistContext;
    subscript(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SubscriptContext(parser: any, parent: any, invokingState: any): this;
declare class SubscriptContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SubscriptContext;
    test(i: any): any;
    COLON(): any;
    sliceop(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function SliceopContext(parser: any, parent: any, invokingState: any): this;
declare class SliceopContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof SliceopContext;
    COLON(): any;
    test(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ExprlistContext(parser: any, parent: any, invokingState: any): this;
declare class ExprlistContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ExprlistContext;
    expr(i: any): any;
    star_expr(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function TestlistContext(parser: any, parent: any, invokingState: any): this;
declare class TestlistContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof TestlistContext;
    test(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function DictorsetmakerContext(parser: any, parent: any, invokingState: any): this;
declare class DictorsetmakerContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof DictorsetmakerContext;
    test(i: any): any;
    COLON(i: any): any;
    POWER(i: any): any;
    expr(i: any): any;
    comp_for(): any;
    star_expr(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ClassdefContext(parser: any, parent: any, invokingState: any): this;
declare class ClassdefContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ClassdefContext;
    CLASS(): any;
    NAME(): any;
    COLON(): any;
    suite(): any;
    OPEN_PAREN(): any;
    CLOSE_PAREN(): any;
    arglist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArglistContext(parser: any, parent: any, invokingState: any): this;
declare class ArglistContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArglistContext;
    argument(i: any): any;
    COMMA(i: any): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function ArgumentContext(parser: any, parent: any, invokingState: any): this;
declare class ArgumentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof ArgumentContext;
    test(i: any): any;
    ASSIGN(): any;
    POWER(): any;
    STAR(): any;
    comp_for(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Comp_iterContext(parser: any, parent: any, invokingState: any): this;
declare class Comp_iterContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Comp_iterContext;
    comp_for(): any;
    comp_if(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Comp_forContext(parser: any, parent: any, invokingState: any): this;
declare class Comp_forContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Comp_forContext;
    FOR(): any;
    exprlist(): any;
    IN(): any;
    or_test(): any;
    ASYNC(): any;
    comp_iter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Comp_ifContext(parser: any, parent: any, invokingState: any): this;
declare class Comp_ifContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Comp_ifContext;
    IF(): any;
    test_nocond(): any;
    comp_iter(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Encoding_declContext(parser: any, parent: any, invokingState: any): this;
declare class Encoding_declContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Encoding_declContext;
    NAME(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Yield_exprContext(parser: any, parent: any, invokingState: any): this;
declare class Yield_exprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Yield_exprContext;
    YIELD(): any;
    yield_arg(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare function Yield_argContext(parser: any, parent: any, invokingState: any): this;
declare class Yield_argContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    constructor: typeof Yield_argContext;
    FROM(): any;
    test(): any;
    testlist(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
export {};
//# sourceMappingURL=Python3Parser.d.ts.map

export abstract class AbstractModel {

    getSetProperty<T>(internalPropertyName: string): EnhancedSet<T> {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            thisAny[internalPropertyName] = new EnhancedSet<T>();
        return thisAny[internalPropertyName];
    }

    addOneSetProperty<T>(internalPropertyName: string, newValue: T) {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            thisAny[internalPropertyName] = new EnhancedSet<T>();
        if (thisAny[internalPropertyName] != null && !thisAny[internalPropertyName].has(newValue)) {
            (thisAny[internalPropertyName] as EnhancedSet<T>).add(newValue);
        }
    }

    removeOneSetProperty<T>(internalPropertyName: string, oldValue: T) {
        const thisAny = this as any;
        const propertyAsSet = thisAny[internalPropertyName] as EnhancedSet<T>;
        if (propertyAsSet != null && propertyAsSet.has(oldValue)) {
            propertyAsSet.delete(oldValue);
            if (propertyAsSet.size == 0)
                thisAny[internalPropertyName] = undefined;
        }
    }

    addManySetProperty<T>(internalPropertyName: string, newValues: EnhancedSet<T>) {
        if (newValues.size > 0) {
            const thisAny = this as any;
            if (thisAny[internalPropertyName] == null)
                thisAny[internalPropertyName] = new EnhancedSet<T>();
            const propertyAsSet = thisAny[internalPropertyName] as EnhancedSet<T>;
            for (const newValue of newValues.values()) {
                propertyAsSet.add(newValue);
            }
        }
    }

    removeManySetProperty<T>(internalPropertyName: string, oldValues: EnhancedSet<T>) {
        const thisAny = this as any;
        const propertyAsSet = thisAny[internalPropertyName] as EnhancedSet<T>;
        if (oldValues.size > 0 && propertyAsSet != null) {
            for (const oldValue of oldValues.values()) {
                propertyAsSet.delete(oldValue);
            }
            if (propertyAsSet.size === 0)
                thisAny[internalPropertyName] = undefined;
        }
    }

    clearSetProperty(internalPropertyName: string) {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] != null) {
            thisAny[internalPropertyName] = undefined;
        }
    }

    getArrayProperty<T>(internalPropertyName: string): Array<T> {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            thisAny[internalPropertyName] = new Array<T>();
        return thisAny[internalPropertyName];
    }

    addOneArrayProperty<T>(internalPropertyName: string, newValue: T) {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            thisAny[internalPropertyName] = new Array<T>();
        const propertyAsArray = thisAny[internalPropertyName] as Array<T>;
        if (propertyAsArray != null && !propertyAsArray.includes(newValue)) {
            propertyAsArray.push(newValue);
        }
    }

    removeOneArrayProperty<T>(internalPropertyName: string, oldValue: T) {
        const thisAny = this as any;
        const propertyAsArray = thisAny[internalPropertyName] as Array<T>;
        if (propertyAsArray != null && propertyAsArray.includes(oldValue)) {
            let index = propertyAsArray.indexOf(oldValue, 0);
            if (index > -1) {
                propertyAsArray.splice(index, 1);
            }
            if (propertyAsArray.length == 0)
                thisAny[internalPropertyName] = undefined;
        }
    }

    addManyArrayProperty<T>(internalPropertyName: string, newValues: Array<T>) {
        if (newValues.length > 0) {
            const thisAny = this as any;
            if (thisAny[internalPropertyName] == null)
                thisAny[internalPropertyName] = new Array<T>();
            const propertyAsArray = thisAny[internalPropertyName] as Array<T>;
            for (const newValue of newValues.values()) {
                propertyAsArray.push(newValue);
            }
        }
    }

    removeManyArrayProperty<T>(internalPropertyName: string, oldValues: Array<T>) {
        const thisAny = this as any;
        if (oldValues.length > 0 && thisAny[internalPropertyName] != null) {
            const propertyAsArray = thisAny[internalPropertyName] as Array<T>;
            for (const oldValue of oldValues.values()) {
                let index = propertyAsArray.indexOf(oldValue, 0);
                if (index > -1) {
                    propertyAsArray.splice(index, 1);
                }
            }
            if (propertyAsArray.length === 0)
                thisAny[internalPropertyName] = undefined;
        }
    }

    clearArrayProperty(internalPropertyName: string) {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] != null) {
            thisAny[internalPropertyName] = undefined;
        }
    }

    getMapProperty<K, V>(internalPropertyName: string): EnhancedMap<K, V> {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            thisAny[internalPropertyName] = new Map<K, V>();
        return thisAny[internalPropertyName];
    }

    getOneMapProperty<K, V>(internalPropertyName: string, key: K): V | undefined {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            return undefined;
        const propertyAsMap = thisAny[internalPropertyName] as Map<K, V>;
        return propertyAsMap.get(key);
    }

    setOneMapProperty<K, V>(internalPropertyName: string, newKey: K, value: V): void {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            thisAny[internalPropertyName] = new Map<K, V>();
        const propertyAsMap = thisAny[internalPropertyName] as Map<K, V>;
        propertyAsMap.set(newKey, value);
    }

    removeOneMapProperty<K, V>(internalPropertyName: string, key: K): void {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] != null) {
            const propertyAsMap = thisAny[internalPropertyName] as Map<K, V>;
            if (key)
                propertyAsMap.delete(key);
        }
    }

    setManyMapProperty<K, V>(internalPropertyName: string, values: { key: K, value: V }[]): void {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] == null)
            thisAny[internalPropertyName] = new Map<K, V>();
        const propertyAsMap = thisAny[internalPropertyName] as Map<K, V>;
        if (values) {
            values.forEach(element => {
                propertyAsMap.set(element.key, element.value);
            });
        }
    }

    removeManyMapProperty<K, V>(internalPropertyName: string, keys: K[]): void {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] != null) {
            const propertyAsMap = thisAny[internalPropertyName] as Map<K, V>;
            if (keys) {
                keys.forEach(element => {
                    propertyAsMap.delete(element);
                });
            }
        }
    }

    clearMapProperty(internalPropertyName: string): void {
        const thisAny = this as any;
        if (thisAny[internalPropertyName] != null) {
            thisAny[internalPropertyName] = undefined;
        }
    }
}
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RdbmsDiscriminatorHarvester = void 0;
const AbstractSingularBuilder_1 = require("../../../runtime/AbstractSingularBuilder");
const ValueType_1 = require("../../../system/ValueType");
class RdbmsDiscriminatorHarvester extends AbstractSingularBuilder_1.AbstractSingularBuilder {
    constructor(configurationValues) {
        const nonNullConfigurationValues = configurationValues ? configurationValues : [];
        nonNullConfigurationValues['repeatFor'] = JSON.stringify({
            objectTypeName: 'View',
        });
        super('RdbmsDiscriminatorHarvester', 'A harvester that infers discriminators for derivations in the data model from the schema', {
            repeatFor: {
                name: 'Repeat for',
                required: true,
                description: 'A parsable string of JSON that represents the properties values of the component that should be iterated on, review the documentation for SystemDescendantComponent and derivations for most available for use',
                valueType: ValueType_1.ValueType.STRING,
                defaultValue: ``,
            },
            discriminatorPattern: {
                name: 'Discriminator Pattern',
                required: true,
                description: 'A regex used against columns to determine if it is a discriminator for inheritance purposes. The presence of such a column indicates that the table is effectively a base class',
                valueType: ValueType_1.ValueType.STRING,
                defaultValue: 'object_type',
            },
        }, nonNullConfigurationValues);
        this.discriminatorRegex = new RegExp('.*');
    }
    regexFromConfigurationString(configurationString) {
        let pattern = configurationString;
        let options = '';
        if (pattern.match(/^[/].*[/][dgimsuy]*$/)) {
            const lastSlash = pattern.lastIndexOf('/');
            options = pattern.substr(lastSlash + 1);
            pattern = pattern.substr(1, lastSlash - 1);
        }
        return new RegExp(pattern, options);
    }
    getViewDiscriminatorColumn(view) {
        const columnNames = Object.keys(view.columns);
        for (let index = 0; index < columnNames.length; index++) {
            const columnName = columnNames[index];
            if (this.discriminatorRegex.test(columnName))
                return view.columns[columnName];
        }
        return null;
    }
    async buildInternal(system, component) {
        const result = [];
        this.logger.isLevelEnabled('debug') ? this.logger.debug(`buildInternal(${system.name}) enter`) : '';
        this.discriminatorRegex = this.regexFromConfigurationString(this.getConfiguredValue('discriminatorPattern'));
        const view = component;
        const discriminatorColumn = this.getViewDiscriminatorColumn(view);
        if (discriminatorColumn != null) {
            view.discriminatorColumn = discriminatorColumn;
        }
        this.harvestInheritanceValues(view);
        this.logger.isLevelEnabled('debug') ? this.logger.debug(`buildInternal(${system.name}) exit`) : '';
        return result;
    }
}
exports.RdbmsDiscriminatorHarvester = RdbmsDiscriminatorHarvester;

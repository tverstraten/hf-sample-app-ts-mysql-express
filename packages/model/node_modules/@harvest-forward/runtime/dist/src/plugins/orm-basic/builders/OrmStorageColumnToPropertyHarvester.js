"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrmStorageColumnToPropertyHarvester = void 0;
const changeCase = __importStar(require("change-case"));
const AbstractSingularBuilder_1 = require("../../../runtime/AbstractSingularBuilder");
const ComponentOrigin_1 = require("../../../system/ComponentOrigin");
const Permanence_1 = require("../../../system/Permanence");
const SystemComponent_1 = require("../../../system/SystemComponent");
const SystemComponentArtifact_1 = require("../../../system/SystemComponentArtifact");
const SystemComponentType_1 = require("../../../system/SystemComponentType");
const ValueType_1 = require("../../../system/ValueType");
const information_architecture_1 = require("../../information-architecture");
const rdbms_basic_1 = require("../../rdbms-basic");
const DataMemberColumnMapping_1 = require("../DataMemberColumnMapping");
class OrmStorageColumnToPropertyHarvester extends AbstractSingularBuilder_1.AbstractSingularBuilder {
    constructor(configurationValues) {
        const nonNullConfigurationValues = configurationValues ? configurationValues : [];
        nonNullConfigurationValues['repeatFor'] = JSON.stringify({
            objectTypeName: 'Column',
        });
        super('OrmStorageColumnToPropertyHarvester', 'A harvester that takes columns from tables in sql schema and creates properties in classes in an information model', {
            repeatFor: {
                name: 'Repeat for',
                required: true,
                description: 'A parsable string of JSON that represents the properties values of the component that should be iterated on, review the documentation for SystemDescendantComponent and derivations for most available for use',
                valueType: ValueType_1.ValueType.STRING,
                defaultValue: ``,
            },
        }, nonNullConfigurationValues);
    }
    getValueTypeFromColumnType(model, column) {
        if (column.dataType.startsWith('ENUM') || column.dataType.startsWith('SET')) {
            const adjustedTableName = changeCase.pascalCase(column.tableName);
            const adjustedColumnName = changeCase.pascalCase(column.name);
            const newTypeName = `${adjustedTableName}${adjustedColumnName}`;
            const result = new ValueType_1.ValueType('ValueType', newTypeName, model.fullConstantCaseName, `Enumeration created from column ${column.tableName}.${column.name}`, false);
            return result;
        }
        return column.valueType;
    }
    translateColumnToProperty(system, storage, informationalClass, column) {
        const results = [];
        this.logger.isLevelEnabled('debug') ? this.logger.debug(`translateColumnToProperty(${storage.constantCaseFullName}.${column.name}) enter`) : '';
        const tableMapping = informationalClass.orMapping;
        const mappable = column;
        let columnMapping = mappable.orMapping;
        let propertyName;
        let propertyType;
        if (columnMapping != null) {
            propertyName = columnMapping.propertyName;
            propertyType = columnMapping.dataType;
        }
        if (propertyName == null)
            propertyName = changeCase.snakeCase(column.name);
        const model = information_architecture_1.InformationModel.fromSystem(system);
        if (propertyType == null)
            propertyType = this.getValueTypeFromColumnType(model, column);
        if (columnMapping == null) {
            if (column.name == 'id' && storage instanceof rdbms_basic_1.View)
                column.name = 'id';
            columnMapping = new DataMemberColumnMapping_1.DataMemberColumnMapping(propertyName, column.name, propertyType.name, propertyType);
            columnMapping.permanence = Permanence_1.Permanence.constant;
            columnMapping.informational = true;
            columnMapping.functional = false;
            columnMapping.origin = ComponentOrigin_1.ComponentOrigin.manufactured;
            mappable.orMapping = columnMapping;
            results.push(new SystemComponentArtifact_1.SystemComponentArtifact(columnMapping));
        }
        else {
            if (columnMapping.dataType == null) {
                if (columnMapping.dataTypeName != null) {
                    let typeOverride;
                    if (ValueType_1.ValueType.hasName(columnMapping.dataTypeName))
                        typeOverride = ValueType_1.ValueType.fromName(columnMapping.dataTypeName);
                    if (typeOverride == null) {
                        const fullName = SystemComponent_1.SystemComponent.fullConstantCase(model.fullConstantCaseName, columnMapping.dataTypeName);
                        typeOverride = system.descendants[fullName];
                    }
                    if (typeOverride == null) {
                        typeOverride = new information_architecture_1.Class(model.fullConstantCaseName, columnMapping.dataTypeName, 'unknown, referenced class', SystemComponentType_1.SystemComponentType.informationModel);
                        typeOverride.isExternal = true;
                        model.addChild(typeOverride);
                        results.push(new SystemComponentArtifact_1.SystemComponentArtifact(typeOverride));
                    }
                    if (typeOverride != null) {
                        columnMapping.dataType = typeOverride;
                        propertyType = typeOverride;
                    }
                }
                else
                    columnMapping.dataType = propertyType;
            }
        }
        columnMapping.column = column;
        if (tableMapping != null)
            tableMapping.addChild(columnMapping);
        let property;
        if (informationalClass.dataMembersMap[propertyName] == null) {
            property = new information_architecture_1.Property(informationalClass.constantCaseFullName, propertyName, column.description, propertyType, column.characterMaximumLength);
            results.push(new SystemComponentArtifact_1.SystemComponentArtifact(property));
            property.permanence = Permanence_1.Permanence.persistent;
            property.informational = true;
            property.functional = false;
            property.origin = ComponentOrigin_1.ComponentOrigin.manufactured;
            informationalClass.addChild(property);
            const dataMember = property;
            dataMember.orMapping = columnMapping;
            columnMapping.property = property;
        }
        else {
            property = informationalClass.dataMembersMap[propertyName];
            property.description = column.description;
            property.type = propertyType;
            property.length = column.characterMaximumLength;
            const dataMember = property;
            if (dataMember.orMapping != null) {
                dataMember.orMapping.dataType = propertyType;
                dataMember.orMapping.column = column;
                dataMember.orMapping.property = property;
            }
        }
        if (storage instanceof rdbms_basic_1.Table) {
            const table = storage;
            if (table.primaryKey == column) {
                if (informationalClass instanceof information_architecture_1.Class)
                    informationalClass.identifyingProperty = property;
            }
        }
        this.logger.isLevelEnabled('debug') ? this.logger.debug(`translateColumnToProperty(${storage.constantCaseFullName}.${column.name}) exit`) : '';
        return results;
    }
    async buildInternal(system, component) {
        let result = [];
        const column = component;
        const storage = column.storage;
        if (storage != null) {
            const storageMapping = storage.orMapping;
            if (storageMapping != null && storageMapping.typeName != null) {
                const informationalClass = storageMapping.type;
                if (informationalClass != null)
                    result = this.translateColumnToProperty(system, storage, informationalClass, column);
            }
        }
        return result;
    }
}
exports.OrmStorageColumnToPropertyHarvester = OrmStorageColumnToPropertyHarvester;

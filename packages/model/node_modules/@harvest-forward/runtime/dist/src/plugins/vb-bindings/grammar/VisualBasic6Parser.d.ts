declare class VisualBasic6Parser {
    static grammarFileName: string;
    static literalNames: (string | null)[];
    static symbolicNames: (string | null)[];
    static ruleNames: string[];
    constructor(input: any);
    _interp: any;
    ruleNames: string[];
    literalNames: (string | null)[];
    symbolicNames: (string | null)[];
    get atn(): any;
    sempred(localctx: any, ruleIndex: any, predIndex: any): any;
    valueStmt_sempred(localctx: any, predIndex: any): any;
    startRule(): StartRuleContext;
    state: number | undefined;
    module(): ModuleContext;
    moduleReferences(): ModuleReferencesContext;
    moduleReference(): ModuleReferenceContext;
    moduleReferenceValue(): ModuleReferenceValueContext;
    moduleReferenceComponent(): ModuleReferenceComponentContext;
    moduleHeader(): ModuleHeaderContext;
    moduleConfig(): ModuleConfigContext;
    moduleConfigElement(): ModuleConfigElementContext;
    moduleAttributes(): ModuleAttributesContext;
    moduleOptions(): ModuleOptionsContext;
    moduleOption(): ModuleOptionContext;
    moduleBody(): ModuleBodyContext;
    moduleBodyElement(): ModuleBodyElementContext;
    controlProperties(): ControlPropertiesContext;
    cp_Properties(): Cp_PropertiesContext;
    cp_SingleProperty(): Cp_SinglePropertyContext;
    cp_PropertyName(): Cp_PropertyNameContext;
    cp_PropertyValue(): Cp_PropertyValueContext;
    cp_NestedProperty(): Cp_NestedPropertyContext;
    cp_ControlType(): Cp_ControlTypeContext;
    cp_ControlIdentifier(): Cp_ControlIdentifierContext;
    moduleBlock(): ModuleBlockContext;
    attributeStmt(): AttributeStmtContext;
    block(): BlockContext;
    blockStmt(): BlockStmtContext;
    appActivateStmt(): AppActivateStmtContext;
    beepStmt(): BeepStmtContext;
    chDirStmt(): ChDirStmtContext;
    chDriveStmt(): ChDriveStmtContext;
    closeStmt(): CloseStmtContext;
    constStmt(): ConstStmtContext;
    constSubStmt(): ConstSubStmtContext;
    dateStmt(): DateStmtContext;
    declareStmt(): DeclareStmtContext;
    deftypeStmt(): DeftypeStmtContext;
    deleteSettingStmt(): DeleteSettingStmtContext;
    doLoopStmt(): DoLoopStmtContext;
    endStmt(): EndStmtContext;
    enumerationStmt(): EnumerationStmtContext;
    enumerationStmt_Constant(): EnumerationStmt_ConstantContext;
    eraseStmt(): EraseStmtContext;
    errorStmt(): ErrorStmtContext;
    eventStmt(): EventStmtContext;
    exitStmt(): ExitStmtContext;
    filecopyStmt(): FilecopyStmtContext;
    forEachStmt(): ForEachStmtContext;
    forNextStmt(): ForNextStmtContext;
    functionStmt(): FunctionStmtContext;
    getStmt(): GetStmtContext;
    goSubStmt(): GoSubStmtContext;
    goToStmt(): GoToStmtContext;
    ifThenElseStmt(): IfThenElseStmtContext;
    ifBlockStmt(): IfBlockStmtContext;
    ifConditionStmt(): IfConditionStmtContext;
    ifElseIfBlockStmt(): IfElseIfBlockStmtContext;
    ifElseBlockStmt(): IfElseBlockStmtContext;
    implementsStmt(): ImplementsStmtContext;
    inputStmt(): InputStmtContext;
    killStmt(): KillStmtContext;
    letStmt(): LetStmtContext;
    lineInputStmt(): LineInputStmtContext;
    loadStmt(): LoadStmtContext;
    lockStmt(): LockStmtContext;
    lsetStmt(): LsetStmtContext;
    macroIfThenElseStmt(): MacroIfThenElseStmtContext;
    macroIfBlockStmt(): MacroIfBlockStmtContext;
    macroElseIfBlockStmt(): MacroElseIfBlockStmtContext;
    macroElseBlockStmt(): MacroElseBlockStmtContext;
    midStmt(): MidStmtContext;
    mkdirStmt(): MkdirStmtContext;
    nameStmt(): NameStmtContext;
    onErrorStmt(): OnErrorStmtContext;
    onGoToStmt(): OnGoToStmtContext;
    onGoSubStmt(): OnGoSubStmtContext;
    openStmt(): OpenStmtContext;
    outputList(): OutputListContext;
    outputList_Expression(): OutputList_ExpressionContext;
    printStmt(): PrintStmtContext;
    propertyGetStmt(): PropertyGetStmtContext;
    propertySetStmt(): PropertySetStmtContext;
    propertyLetStmt(): PropertyLetStmtContext;
    putStmt(): PutStmtContext;
    raiseEventStmt(): RaiseEventStmtContext;
    randomizeStmt(): RandomizeStmtContext;
    redimStmt(): RedimStmtContext;
    redimSubStmt(): RedimSubStmtContext;
    resetStmt(): ResetStmtContext;
    resumeStmt(): ResumeStmtContext;
    returnStmt(): ReturnStmtContext;
    rmdirStmt(): RmdirStmtContext;
    rsetStmt(): RsetStmtContext;
    savepictureStmt(): SavepictureStmtContext;
    saveSettingStmt(): SaveSettingStmtContext;
    seekStmt(): SeekStmtContext;
    selectCaseStmt(): SelectCaseStmtContext;
    sC_Case(): SC_CaseContext;
    sC_Cond(): SC_CondContext;
    sC_CondExpr(): SC_CondExprContext;
    sendkeysStmt(): SendkeysStmtContext;
    setattrStmt(): SetattrStmtContext;
    setStmt(): SetStmtContext;
    stopStmt(): StopStmtContext;
    subStmt(): SubStmtContext;
    timeStmt(): TimeStmtContext;
    typeStmt(): TypeStmtContext;
    typeStmt_Element(): TypeStmt_ElementContext;
    typeOfStmt(): TypeOfStmtContext;
    unloadStmt(): UnloadStmtContext;
    unlockStmt(): UnlockStmtContext;
    valueStmt(_p: any): any;
    _ctx: any;
    variableStmt(): VariableStmtContext;
    variableListStmt(): VariableListStmtContext;
    variableSubStmt(): VariableSubStmtContext;
    whileWendStmt(): WhileWendStmtContext;
    widthStmt(): WidthStmtContext;
    withStmt(): WithStmtContext;
    writeStmt(): WriteStmtContext;
    explicitCallStmt(): ExplicitCallStmtContext;
    eCS_ProcedureCall(): ECS_ProcedureCallContext;
    eCS_MemberProcedureCall(): ECS_MemberProcedureCallContext;
    implicitCallStmt_InBlock(): ImplicitCallStmt_InBlockContext;
    iCS_B_ProcedureCall(): ICS_B_ProcedureCallContext;
    iCS_B_MemberProcedureCall(): ICS_B_MemberProcedureCallContext;
    implicitCallStmt_InStmt(): ImplicitCallStmt_InStmtContext;
    iCS_S_VariableOrProcedureCall(): ICS_S_VariableOrProcedureCallContext;
    iCS_S_ProcedureOrArrayCall(): ICS_S_ProcedureOrArrayCallContext;
    iCS_S_NestedProcedureCall(): ICS_S_NestedProcedureCallContext;
    iCS_S_MembersCall(): ICS_S_MembersCallContext;
    iCS_S_MemberCall(): ICS_S_MemberCallContext;
    iCS_S_DictionaryCall(): ICS_S_DictionaryCallContext;
    argsCall(): ArgsCallContext;
    argCall(): ArgCallContext;
    dictionaryCallStmt(): DictionaryCallStmtContext;
    argList(): ArgListContext;
    arg(): ArgContext;
    argDefaultValue(): ArgDefaultValueContext;
    subscripts(): SubscriptsContext;
    subscript_(): Subscript_Context;
    ambiguousIdentifier(): AmbiguousIdentifierContext;
    asTypeClause(): AsTypeClauseContext;
    baseType(): BaseTypeContext;
    certainIdentifier(): CertainIdentifierContext;
    comparisonOperator(): ComparisonOperatorContext;
    complexType(): ComplexTypeContext;
    fieldLength(): FieldLengthContext;
    letterrange(): LetterrangeContext;
    lineLabel(): LineLabelContext;
    literal(): LiteralContext;
    publicPrivateVisibility(): PublicPrivateVisibilityContext;
    publicPrivateGlobalVisibility(): PublicPrivateGlobalVisibilityContext;
    type_(): Type_Context;
    typeHint(): TypeHintContext;
    visibility(): VisibilityContext;
    ambiguousKeyword(): AmbiguousKeywordContext;
}
declare namespace VisualBasic6Parser {
    export const EOF: any;
    export const ACCESS: number;
    export const ADDRESSOF: number;
    export const ALIAS: number;
    export const AND: number;
    export const ATTRIBUTE: number;
    export const APPACTIVATE: number;
    export const APPEND: number;
    export const AS: number;
    export const BEEP: number;
    export const BEGIN: number;
    export const BEGINPROPERTY: number;
    export const BINARY: number;
    export const BOOLEAN: number;
    export const BYVAL: number;
    export const BYREF: number;
    export const BYTE: number;
    export const CALL: number;
    export const CASE: number;
    export const CHDIR: number;
    export const CHDRIVE: number;
    export const CLASS: number;
    export const CLOSE: number;
    export const COLLECTION: number;
    export const CONST: number;
    export const DATE: number;
    export const DECLARE: number;
    export const DEFBOOL: number;
    export const DEFBYTE: number;
    export const DEFDATE: number;
    export const DEFDBL: number;
    export const DEFDEC: number;
    export const DEFCUR: number;
    export const DEFINT: number;
    export const DEFLNG: number;
    export const DEFOBJ: number;
    export const DEFSNG: number;
    export const DEFSTR: number;
    export const DEFVAR: number;
    export const DELETESETTING: number;
    export const DIM: number;
    export const DO: number;
    export const DOUBLE: number;
    export const EACH: number;
    export const ELSE: number;
    export const ELSEIF: number;
    export const END_ENUM: number;
    export const END_FUNCTION: number;
    export const END_IF: number;
    export const END_PROPERTY: number;
    export const END_SELECT: number;
    export const END_SUB: number;
    export const END_TYPE: number;
    export const END_WITH: number;
    export const END: number;
    export const ENDPROPERTY: number;
    export const ENUM: number;
    export const EQV: number;
    export const ERASE: number;
    export const ERROR: number;
    export const EVENT: number;
    export const EXIT_DO: number;
    export const EXIT_FOR: number;
    export const EXIT_FUNCTION: number;
    export const EXIT_PROPERTY: number;
    export const EXIT_SUB: number;
    export const FALSE: number;
    export const FILECOPY: number;
    export const FRIEND: number;
    export const FOR: number;
    export const FUNCTION: number;
    export const GET: number;
    export const GLOBAL: number;
    export const GOSUB: number;
    export const GOTO: number;
    export const IF: number;
    export const IMP: number;
    export const IMPLEMENTS: number;
    export const IN: number;
    export const INPUT: number;
    export const IS: number;
    export const INTEGER: number;
    export const KILL: number;
    export const LOAD: number;
    export const LOCK: number;
    export const LONG: number;
    export const LOOP: number;
    export const LEN: number;
    export const LET: number;
    export const LIB: number;
    export const LIKE: number;
    export const LINE_INPUT: number;
    export const LOCK_READ: number;
    export const LOCK_WRITE: number;
    export const LOCK_READ_WRITE: number;
    export const LSET: number;
    export const MACRO_IF: number;
    export const MACRO_ELSEIF: number;
    export const MACRO_ELSE: number;
    export const MACRO_END_IF: number;
    export const ME: number;
    export const MID: number;
    export const MKDIR: number;
    export const MOD: number;
    export const NAME: number;
    export const NEXT: number;
    export const NEW: number;
    export const NOT: number;
    export const NOTHING: number;
    export const NULL_: number;
    export const OBJECT: number;
    export const ON: number;
    export const ON_ERROR: number;
    export const ON_LOCAL_ERROR: number;
    export const OPEN: number;
    export const OPTIONAL: number;
    export const OPTION_BASE: number;
    export const OPTION_EXPLICIT: number;
    export const OPTION_COMPARE: number;
    export const OPTION_PRIVATE_MODULE: number;
    export const OR: number;
    export const OUTPUT: number;
    export const PARAMARRAY: number;
    export const PRESERVE: number;
    export const PRINT: number;
    export const PRIVATE: number;
    export const PROPERTY_GET: number;
    export const PROPERTY_LET: number;
    export const PROPERTY_SET: number;
    export const PUBLIC: number;
    export const PUT: number;
    export const RANDOM: number;
    export const RANDOMIZE: number;
    export const RAISEEVENT: number;
    export const READ: number;
    export const READ_WRITE: number;
    export const REDIM: number;
    export const REM: number;
    export const RESET: number;
    export const RESUME: number;
    export const RETURN: number;
    export const RMDIR: number;
    export const RSET: number;
    export const SAVEPICTURE: number;
    export const SAVESETTING: number;
    export const SEEK: number;
    export const SELECT: number;
    export const SENDKEYS: number;
    export const SET: number;
    export const SETATTR: number;
    export const SHARED: number;
    export const SINGLE: number;
    export const SPC: number;
    export const STATIC: number;
    export const STEP: number;
    export const STOP: number;
    export const STRING: number;
    export const SUB: number;
    export const TAB: number;
    export const TEXT: number;
    export const THEN: number;
    export const TIME: number;
    export const TO: number;
    export const TRUE: number;
    export const TYPE: number;
    export const TYPEOF: number;
    export const UNLOAD: number;
    export const UNLOCK: number;
    export const UNTIL: number;
    export const VARIANT: number;
    export const VERSION: number;
    export const WEND: number;
    export const WHILE: number;
    export const WIDTH: number;
    export const WITH: number;
    export const WITHEVENTS: number;
    export const WRITE: number;
    export const XOR: number;
    export const AMPERSAND: number;
    export const ASSIGN: number;
    export const AT: number;
    export const COLON: number;
    export const COMMA: number;
    export const IDIV: number;
    export const DIV: number;
    export const DOLLAR: number;
    export const DOT: number;
    export const EQ: number;
    export const EXCLAMATIONMARK: number;
    export const GEQ: number;
    export const GT: number;
    export const HASH: number;
    export const LEQ: number;
    export const LBRACE: number;
    export const LPAREN: number;
    export const LT: number;
    export const MINUS: number;
    export const MINUS_EQ: number;
    export const MULT: number;
    export const NEQ: number;
    export const PERCENT: number;
    export const PLUS: number;
    export const PLUS_EQ: number;
    export const POW: number;
    export const RBRACE: number;
    export const RPAREN: number;
    export const SEMICOLON: number;
    export const L_SQUARE_BRACKET: number;
    export const R_SQUARE_BRACKET: number;
    export const STRINGLITERAL: number;
    export const DATELITERAL: number;
    export const COLORLITERAL: number;
    export const INTEGERLITERAL: number;
    export const DOUBLELITERAL: number;
    export const FILENUMBER: number;
    export const OCTALLITERAL: number;
    export const FRX_OFFSET: number;
    export const GUID: number;
    export const IDENTIFIER: number;
    export const LINE_CONTINUATION: number;
    export const NEWLINE: number;
    export const COMMENT: number;
    export const WS: number;
    export const RULE_startRule: number;
    export const RULE_module: number;
    export const RULE_moduleReferences: number;
    export const RULE_moduleReference: number;
    export const RULE_moduleReferenceValue: number;
    export const RULE_moduleReferenceComponent: number;
    export const RULE_moduleHeader: number;
    export const RULE_moduleConfig: number;
    export const RULE_moduleConfigElement: number;
    export const RULE_moduleAttributes: number;
    export const RULE_moduleOptions: number;
    export const RULE_moduleOption: number;
    export const RULE_moduleBody: number;
    export const RULE_moduleBodyElement: number;
    export const RULE_controlProperties: number;
    export const RULE_cp_Properties: number;
    export const RULE_cp_SingleProperty: number;
    export const RULE_cp_PropertyName: number;
    export const RULE_cp_PropertyValue: number;
    export const RULE_cp_NestedProperty: number;
    export const RULE_cp_ControlType: number;
    export const RULE_cp_ControlIdentifier: number;
    export const RULE_moduleBlock: number;
    export const RULE_attributeStmt: number;
    export const RULE_block: number;
    export const RULE_blockStmt: number;
    export const RULE_appActivateStmt: number;
    export const RULE_beepStmt: number;
    export const RULE_chDirStmt: number;
    export const RULE_chDriveStmt: number;
    export const RULE_closeStmt: number;
    export const RULE_constStmt: number;
    export const RULE_constSubStmt: number;
    export const RULE_dateStmt: number;
    export const RULE_declareStmt: number;
    export const RULE_deftypeStmt: number;
    export const RULE_deleteSettingStmt: number;
    export const RULE_doLoopStmt: number;
    export const RULE_endStmt: number;
    export const RULE_enumerationStmt: number;
    export const RULE_enumerationStmt_Constant: number;
    export const RULE_eraseStmt: number;
    export const RULE_errorStmt: number;
    export const RULE_eventStmt: number;
    export const RULE_exitStmt: number;
    export const RULE_filecopyStmt: number;
    export const RULE_forEachStmt: number;
    export const RULE_forNextStmt: number;
    export const RULE_functionStmt: number;
    export const RULE_getStmt: number;
    export const RULE_goSubStmt: number;
    export const RULE_goToStmt: number;
    export const RULE_ifThenElseStmt: number;
    export const RULE_ifBlockStmt: number;
    export const RULE_ifConditionStmt: number;
    export const RULE_ifElseIfBlockStmt: number;
    export const RULE_ifElseBlockStmt: number;
    export const RULE_implementsStmt: number;
    export const RULE_inputStmt: number;
    export const RULE_killStmt: number;
    export const RULE_letStmt: number;
    export const RULE_lineInputStmt: number;
    export const RULE_loadStmt: number;
    export const RULE_lockStmt: number;
    export const RULE_lsetStmt: number;
    export const RULE_macroIfThenElseStmt: number;
    export const RULE_macroIfBlockStmt: number;
    export const RULE_macroElseIfBlockStmt: number;
    export const RULE_macroElseBlockStmt: number;
    export const RULE_midStmt: number;
    export const RULE_mkdirStmt: number;
    export const RULE_nameStmt: number;
    export const RULE_onErrorStmt: number;
    export const RULE_onGoToStmt: number;
    export const RULE_onGoSubStmt: number;
    export const RULE_openStmt: number;
    export const RULE_outputList: number;
    export const RULE_outputList_Expression: number;
    export const RULE_printStmt: number;
    export const RULE_propertyGetStmt: number;
    export const RULE_propertySetStmt: number;
    export const RULE_propertyLetStmt: number;
    export const RULE_putStmt: number;
    export const RULE_raiseEventStmt: number;
    export const RULE_randomizeStmt: number;
    export const RULE_redimStmt: number;
    export const RULE_redimSubStmt: number;
    export const RULE_resetStmt: number;
    export const RULE_resumeStmt: number;
    export const RULE_returnStmt: number;
    export const RULE_rmdirStmt: number;
    export const RULE_rsetStmt: number;
    export const RULE_savepictureStmt: number;
    export const RULE_saveSettingStmt: number;
    export const RULE_seekStmt: number;
    export const RULE_selectCaseStmt: number;
    export const RULE_sC_Case: number;
    export const RULE_sC_Cond: number;
    export const RULE_sC_CondExpr: number;
    export const RULE_sendkeysStmt: number;
    export const RULE_setattrStmt: number;
    export const RULE_setStmt: number;
    export const RULE_stopStmt: number;
    export const RULE_subStmt: number;
    export const RULE_timeStmt: number;
    export const RULE_typeStmt: number;
    export const RULE_typeStmt_Element: number;
    export const RULE_typeOfStmt: number;
    export const RULE_unloadStmt: number;
    export const RULE_unlockStmt: number;
    export const RULE_valueStmt: number;
    export const RULE_variableStmt: number;
    export const RULE_variableListStmt: number;
    export const RULE_variableSubStmt: number;
    export const RULE_whileWendStmt: number;
    export const RULE_widthStmt: number;
    export const RULE_withStmt: number;
    export const RULE_writeStmt: number;
    export const RULE_explicitCallStmt: number;
    export const RULE_eCS_ProcedureCall: number;
    export const RULE_eCS_MemberProcedureCall: number;
    export const RULE_implicitCallStmt_InBlock: number;
    export const RULE_iCS_B_ProcedureCall: number;
    export const RULE_iCS_B_MemberProcedureCall: number;
    export const RULE_implicitCallStmt_InStmt: number;
    export const RULE_iCS_S_VariableOrProcedureCall: number;
    export const RULE_iCS_S_ProcedureOrArrayCall: number;
    export const RULE_iCS_S_NestedProcedureCall: number;
    export const RULE_iCS_S_MembersCall: number;
    export const RULE_iCS_S_MemberCall: number;
    export const RULE_iCS_S_DictionaryCall: number;
    export const RULE_argsCall: number;
    export const RULE_argCall: number;
    export const RULE_dictionaryCallStmt: number;
    export const RULE_argList: number;
    export const RULE_arg: number;
    export const RULE_argDefaultValue: number;
    export const RULE_subscripts: number;
    export const RULE_subscript_: number;
    export const RULE_ambiguousIdentifier: number;
    export const RULE_asTypeClause: number;
    export const RULE_baseType: number;
    export const RULE_certainIdentifier: number;
    export const RULE_comparisonOperator: number;
    export const RULE_complexType: number;
    export const RULE_fieldLength: number;
    export const RULE_letterrange: number;
    export const RULE_lineLabel: number;
    export const RULE_literal: number;
    export const RULE_publicPrivateVisibility: number;
    export const RULE_publicPrivateGlobalVisibility: number;
    export const RULE_type_: number;
    export const RULE_typeHint: number;
    export const RULE_visibility: number;
    export const RULE_ambiguousKeyword: number;
    export { OptionExplicitStmtContext };
    export { OptionBaseStmtContext };
    export { OptionPrivateModuleStmtContext };
    export { OptionCompareStmtContext };
    export { BlockIfThenElseContext };
    export { InlineIfThenElseContext };
    export { CaseCondExprContext };
    export { CaseCondElseContext };
    export { CaseCondExprValueContext };
    export { CaseCondExprIsContext };
    export { CaseCondExprToContext };
    export { VsAssignContext };
    export { VsNotContext };
    export { VsStructContext };
    export { VsMultDivContext };
    export { VsTypeOfContext };
    export { VsICSContext };
    export { VsXorContext };
    export { VsAddSubContext };
    export { VsAndContext };
    export { VsPowContext };
    export { VsModContext };
    export { VsAmpContext };
    export { VsAddressOfContext };
    export { VsNewContext };
    export { VsPlusMinusContext };
    export { VsIDivContext };
    export { VsOrContext };
    export { VsLiteralContext };
    export { VsEqvContext };
    export { VsImpContext };
    export { VsCompContext };
    export { VsMidContext };
    export { StartRuleContext };
    export { ModuleContext };
    export { ModuleReferencesContext };
    export { ModuleReferenceContext };
    export { ModuleReferenceValueContext };
    export { ModuleReferenceComponentContext };
    export { ModuleHeaderContext };
    export { ModuleConfigContext };
    export { ModuleConfigElementContext };
    export { ModuleAttributesContext };
    export { ModuleOptionsContext };
    export { ModuleOptionContext };
    export { ModuleBodyContext };
    export { ModuleBodyElementContext };
    export { ControlPropertiesContext };
    export { Cp_PropertiesContext };
    export { Cp_SinglePropertyContext };
    export { Cp_PropertyNameContext };
    export { Cp_PropertyValueContext };
    export { Cp_NestedPropertyContext };
    export { Cp_ControlTypeContext };
    export { Cp_ControlIdentifierContext };
    export { ModuleBlockContext };
    export { AttributeStmtContext };
    export { BlockContext };
    export { BlockStmtContext };
    export { AppActivateStmtContext };
    export { BeepStmtContext };
    export { ChDirStmtContext };
    export { ChDriveStmtContext };
    export { CloseStmtContext };
    export { ConstStmtContext };
    export { ConstSubStmtContext };
    export { DateStmtContext };
    export { DeclareStmtContext };
    export { DeftypeStmtContext };
    export { DeleteSettingStmtContext };
    export { DoLoopStmtContext };
    export { EndStmtContext };
    export { EnumerationStmtContext };
    export { EnumerationStmt_ConstantContext };
    export { EraseStmtContext };
    export { ErrorStmtContext };
    export { EventStmtContext };
    export { ExitStmtContext };
    export { FilecopyStmtContext };
    export { ForEachStmtContext };
    export { ForNextStmtContext };
    export { FunctionStmtContext };
    export { GetStmtContext };
    export { GoSubStmtContext };
    export { GoToStmtContext };
    export { IfThenElseStmtContext };
    export { IfBlockStmtContext };
    export { IfConditionStmtContext };
    export { IfElseIfBlockStmtContext };
    export { IfElseBlockStmtContext };
    export { ImplementsStmtContext };
    export { InputStmtContext };
    export { KillStmtContext };
    export { LetStmtContext };
    export { LineInputStmtContext };
    export { LoadStmtContext };
    export { LockStmtContext };
    export { LsetStmtContext };
    export { MacroIfThenElseStmtContext };
    export { MacroIfBlockStmtContext };
    export { MacroElseIfBlockStmtContext };
    export { MacroElseBlockStmtContext };
    export { MidStmtContext };
    export { MkdirStmtContext };
    export { NameStmtContext };
    export { OnErrorStmtContext };
    export { OnGoToStmtContext };
    export { OnGoSubStmtContext };
    export { OpenStmtContext };
    export { OutputListContext };
    export { OutputList_ExpressionContext };
    export { PrintStmtContext };
    export { PropertyGetStmtContext };
    export { PropertySetStmtContext };
    export { PropertyLetStmtContext };
    export { PutStmtContext };
    export { RaiseEventStmtContext };
    export { RandomizeStmtContext };
    export { RedimStmtContext };
    export { RedimSubStmtContext };
    export { ResetStmtContext };
    export { ResumeStmtContext };
    export { ReturnStmtContext };
    export { RmdirStmtContext };
    export { RsetStmtContext };
    export { SavepictureStmtContext };
    export { SaveSettingStmtContext };
    export { SeekStmtContext };
    export { SelectCaseStmtContext };
    export { SC_CaseContext };
    export { SC_CondContext };
    export { SC_CondExprContext };
    export { SendkeysStmtContext };
    export { SetattrStmtContext };
    export { SetStmtContext };
    export { StopStmtContext };
    export { SubStmtContext };
    export { TimeStmtContext };
    export { TypeStmtContext };
    export { TypeStmt_ElementContext };
    export { TypeOfStmtContext };
    export { UnloadStmtContext };
    export { UnlockStmtContext };
    export { ValueStmtContext };
    export { VariableStmtContext };
    export { VariableListStmtContext };
    export { VariableSubStmtContext };
    export { WhileWendStmtContext };
    export { WidthStmtContext };
    export { WithStmtContext };
    export { WriteStmtContext };
    export { ExplicitCallStmtContext };
    export { ECS_ProcedureCallContext };
    export { ECS_MemberProcedureCallContext };
    export { ImplicitCallStmt_InBlockContext };
    export { ICS_B_ProcedureCallContext };
    export { ICS_B_MemberProcedureCallContext };
    export { ImplicitCallStmt_InStmtContext };
    export { ICS_S_VariableOrProcedureCallContext };
    export { ICS_S_ProcedureOrArrayCallContext };
    export { ICS_S_NestedProcedureCallContext };
    export { ICS_S_MembersCallContext };
    export { ICS_S_MemberCallContext };
    export { ICS_S_DictionaryCallContext };
    export { ArgsCallContext };
    export { ArgCallContext };
    export { DictionaryCallStmtContext };
    export { ArgListContext };
    export { ArgContext };
    export { ArgDefaultValueContext };
    export { SubscriptsContext };
    export { Subscript_Context };
    export { AmbiguousIdentifierContext };
    export { AsTypeClauseContext };
    export { BaseTypeContext };
    export { CertainIdentifierContext };
    export { ComparisonOperatorContext };
    export { ComplexTypeContext };
    export { FieldLengthContext };
    export { LetterrangeContext };
    export { LineLabelContext };
    export { LiteralContext };
    export { PublicPrivateVisibilityContext };
    export { PublicPrivateGlobalVisibilityContext };
    export { Type_Context };
    export { TypeHintContext };
    export { VisibilityContext };
    export { AmbiguousKeywordContext };
}
export default VisualBasic6Parser;
declare class StartRuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    module(): any;
    EOF(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WS: (i: any) => any;
    NEWLINE: (i: any) => any;
    moduleHeader(): any;
    moduleReferences(): any;
    controlProperties(): any;
    moduleConfig(): any;
    moduleAttributes(): any;
    moduleOptions(): any;
    moduleBody(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleReferencesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    moduleReference: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleReferenceContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OBJECT(): any;
    EQ(): any;
    moduleReferenceValue(): any;
    WS: (i: any) => any;
    SEMICOLON(): any;
    moduleReferenceComponent(): any;
    NEWLINE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleReferenceValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STRINGLITERAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleReferenceComponentContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STRINGLITERAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleHeaderContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    VERSION(): any;
    WS: (i: any) => any;
    DOUBLELITERAL(): any;
    CLASS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleConfigContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BEGIN(): any;
    END(): any;
    NEWLINE: (i: any) => any;
    moduleConfigElement: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleConfigElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    EQ(): any;
    literal(): any;
    NEWLINE(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleAttributesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    attributeStmt: (i: any) => any;
    NEWLINE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleOptionsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    moduleOption: (i: any) => any;
    NEWLINE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleOptionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    copyFrom(ctx: any): void;
}
declare class ModuleBodyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    moduleBodyElement: (i: any) => any;
    NEWLINE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleBodyElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    moduleBlock(): any;
    moduleOption(): any;
    declareStmt(): any;
    enumerationStmt(): any;
    eventStmt(): any;
    functionStmt(): any;
    macroIfThenElseStmt(): any;
    propertyGetStmt(): any;
    propertySetStmt(): any;
    propertyLetStmt(): any;
    subStmt(): any;
    typeStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ControlPropertiesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BEGIN(): any;
    WS: (i: any) => any;
    cp_ControlType(): any;
    cp_ControlIdentifier(): any;
    END(): any;
    NEWLINE: (i: any) => any;
    cp_Properties: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Cp_PropertiesContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    cp_SingleProperty(): any;
    cp_NestedProperty(): any;
    controlProperties(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Cp_SinglePropertyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    implicitCallStmt_InStmt(): any;
    EQ(): any;
    cp_PropertyValue(): any;
    WS: (i: any) => any;
    DOLLAR(): any;
    FRX_OFFSET(): any;
    NEWLINE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Cp_PropertyNameContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier: (i: any) => any;
    OBJECT(): any;
    DOT: (i: any) => any;
    LPAREN: (i: any) => any;
    literal: (i: any) => any;
    RPAREN: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Cp_PropertyValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    literal(): any;
    POW(): any;
    ambiguousIdentifier(): any;
    DOLLAR(): any;
    LBRACE(): any;
    RBRACE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Cp_NestedPropertyContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BEGINPROPERTY(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    ENDPROPERTY(): any;
    LPAREN(): any;
    INTEGERLITERAL(): any;
    RPAREN(): any;
    GUID(): any;
    NEWLINE: (i: any) => any;
    cp_Properties: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Cp_ControlTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    complexType(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Cp_ControlIdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ModuleBlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AttributeStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ATTRIBUTE(): any;
    WS: (i: any) => any;
    implicitCallStmt_InStmt(): any;
    EQ(): any;
    literal: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    blockStmt: (i: any) => any;
    NEWLINE: (i: any) => any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    appActivateStmt(): any;
    attributeStmt(): any;
    beepStmt(): any;
    chDirStmt(): any;
    chDriveStmt(): any;
    closeStmt(): any;
    constStmt(): any;
    dateStmt(): any;
    deleteSettingStmt(): any;
    deftypeStmt(): any;
    doLoopStmt(): any;
    endStmt(): any;
    eraseStmt(): any;
    errorStmt(): any;
    exitStmt(): any;
    explicitCallStmt(): any;
    filecopyStmt(): any;
    forEachStmt(): any;
    forNextStmt(): any;
    getStmt(): any;
    goSubStmt(): any;
    goToStmt(): any;
    ifThenElseStmt(): any;
    implementsStmt(): any;
    inputStmt(): any;
    killStmt(): any;
    letStmt(): any;
    lineInputStmt(): any;
    lineLabel(): any;
    loadStmt(): any;
    lockStmt(): any;
    lsetStmt(): any;
    macroIfThenElseStmt(): any;
    midStmt(): any;
    mkdirStmt(): any;
    nameStmt(): any;
    onErrorStmt(): any;
    onGoToStmt(): any;
    onGoSubStmt(): any;
    openStmt(): any;
    printStmt(): any;
    putStmt(): any;
    raiseEventStmt(): any;
    randomizeStmt(): any;
    redimStmt(): any;
    resetStmt(): any;
    resumeStmt(): any;
    returnStmt(): any;
    rmdirStmt(): any;
    rsetStmt(): any;
    savepictureStmt(): any;
    saveSettingStmt(): any;
    seekStmt(): any;
    selectCaseStmt(): any;
    sendkeysStmt(): any;
    setattrStmt(): any;
    setStmt(): any;
    stopStmt(): any;
    timeStmt(): any;
    unloadStmt(): any;
    unlockStmt(): any;
    variableStmt(): any;
    whileWendStmt(): any;
    widthStmt(): any;
    withStmt(): any;
    writeStmt(): any;
    implicitCallStmt_InBlock(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AppActivateStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    APPACTIVATE(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BeepStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BEEP(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ChDirStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CHDIR(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ChDriveStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CHDRIVE(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CloseStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CLOSE(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CONST(): any;
    WS: (i: any) => any;
    constSubStmt: (i: any) => any;
    publicPrivateGlobalVisibility(): any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ConstSubStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    EQ(): any;
    valueStmt(): any;
    typeHint(): any;
    WS: (i: any) => any;
    asTypeClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DateStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DATE(): any;
    EQ(): any;
    valueStmt(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DeclareStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DECLARE(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    LIB(): any;
    STRINGLITERAL: (i: any) => any;
    FUNCTION(): any;
    SUB(): any;
    visibility(): any;
    typeHint: (i: any) => any;
    ALIAS(): any;
    argList(): any;
    asTypeClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DeftypeStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WS: (i: any) => any;
    letterrange: (i: any) => any;
    DEFBOOL(): any;
    DEFBYTE(): any;
    DEFINT(): any;
    DEFLNG(): any;
    DEFCUR(): any;
    DEFSNG(): any;
    DEFDBL(): any;
    DEFDEC(): any;
    DEFDATE(): any;
    DEFSTR(): any;
    DEFOBJ(): any;
    DEFVAR(): any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DeleteSettingStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DELETESETTING(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DoLoopStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DO(): any;
    LOOP(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    WS: (i: any) => any;
    valueStmt(): any;
    WHILE(): any;
    UNTIL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EndStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    END(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EnumerationStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ENUM(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    END_ENUM(): any;
    publicPrivateVisibility(): any;
    NEWLINE: (i: any) => any;
    enumerationStmt_Constant: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EnumerationStmt_ConstantContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    EQ(): any;
    valueStmt(): any;
    NEWLINE: (i: any) => any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EraseStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ERASE(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ErrorStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ERROR(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class EventStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EVENT(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    argList(): any;
    visibility(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExitStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EXIT_DO(): any;
    EXIT_FOR(): any;
    EXIT_FUNCTION(): any;
    EXIT_PROPERTY(): any;
    EXIT_SUB(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FilecopyStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FILECOPY(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForEachStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FOR(): any;
    WS: (i: any) => any;
    EACH(): any;
    ambiguousIdentifier: (i: any) => any;
    IN(): any;
    valueStmt(): any;
    NEXT(): any;
    typeHint(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ForNextStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FOR(): any;
    WS: (i: any) => any;
    iCS_S_VariableOrProcedureCall(): any;
    EQ(): any;
    valueStmt: (i: any) => any;
    TO(): any;
    NEXT(): any;
    typeHint: (i: any) => any;
    asTypeClause(): any;
    STEP(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    ambiguousIdentifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FunctionStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    FUNCTION(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    END_FUNCTION(): any;
    visibility(): any;
    STATIC(): any;
    argList(): any;
    asTypeClause(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GET(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GoSubStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GOSUB(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class GoToStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    GOTO(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IfThenElseStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    copyFrom(ctx: any): void;
}
declare class IfBlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IF(): any;
    WS: (i: any) => any;
    ifConditionStmt(): any;
    THEN(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IfConditionStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IfElseIfBlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ELSEIF(): any;
    WS: (i: any) => any;
    ifConditionStmt(): any;
    THEN(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class IfElseBlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ELSE(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImplementsStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IMPLEMENTS(): any;
    WS(): any;
    ambiguousIdentifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InputStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    INPUT(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class KillStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    KILL(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    implicitCallStmt_InStmt(): any;
    valueStmt(): any;
    EQ(): any;
    PLUS_EQ(): any;
    MINUS_EQ(): any;
    LET(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LineInputStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LINE_INPUT(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LoadStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LOAD(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LOCK(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    TO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LsetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LSET(): any;
    WS: (i: any) => any;
    implicitCallStmt_InStmt(): any;
    EQ(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MacroIfThenElseStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    macroIfBlockStmt(): any;
    MACRO_END_IF(): any;
    macroElseIfBlockStmt: (i: any) => any;
    macroElseBlockStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MacroIfBlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MACRO_IF(): any;
    WS: (i: any) => any;
    ifConditionStmt(): any;
    THEN(): any;
    NEWLINE: (i: any) => any;
    moduleBody(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MacroElseIfBlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MACRO_ELSEIF(): any;
    WS: (i: any) => any;
    ifConditionStmt(): any;
    THEN(): any;
    NEWLINE: (i: any) => any;
    moduleBody(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MacroElseBlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MACRO_ELSE(): any;
    NEWLINE: (i: any) => any;
    moduleBody(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MidStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MID(): any;
    LPAREN(): any;
    argsCall(): any;
    RPAREN(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class MkdirStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MKDIR(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class NameStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    NAME(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    AS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OnErrorStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WS: (i: any) => any;
    ON_ERROR(): any;
    ON_LOCAL_ERROR(): any;
    GOTO(): any;
    valueStmt(): any;
    RESUME(): any;
    NEXT(): any;
    COLON(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OnGoToStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ON(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    GOTO(): any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OnGoSubStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ON(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    GOSUB(): any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OpenStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    OPEN(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    FOR(): any;
    AS(): any;
    APPEND(): any;
    BINARY(): any;
    INPUT(): any;
    OUTPUT(): any;
    RANDOM(): any;
    ACCESS(): any;
    LEN(): any;
    EQ(): any;
    READ(): any;
    WRITE(): any;
    READ_WRITE(): any;
    SHARED(): any;
    LOCK_READ(): any;
    LOCK_WRITE(): any;
    LOCK_READ_WRITE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OutputListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    outputList_Expression: (i: any) => any;
    SEMICOLON: (i: any) => any;
    COMMA: (i: any) => any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OutputList_ExpressionContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SPC(): any;
    TAB(): any;
    LPAREN(): any;
    argsCall(): any;
    RPAREN(): any;
    WS: (i: any) => any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PrintStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PRINT(): any;
    WS: (i: any) => any;
    valueStmt(): any;
    COMMA(): any;
    outputList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertyGetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PROPERTY_GET(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    END_PROPERTY(): any;
    visibility(): any;
    STATIC(): any;
    typeHint(): any;
    argList(): any;
    asTypeClause(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertySetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PROPERTY_SET(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    END_PROPERTY(): any;
    visibility(): any;
    STATIC(): any;
    argList(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PropertyLetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PROPERTY_LET(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    END_PROPERTY(): any;
    visibility(): any;
    STATIC(): any;
    argList(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PutStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PUT(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RaiseEventStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RAISEEVENT(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    argsCall(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RandomizeStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RANDOMIZE(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RedimStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    REDIM(): any;
    WS: (i: any) => any;
    redimSubStmt: (i: any) => any;
    PRESERVE(): any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RedimSubStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    implicitCallStmt_InStmt(): any;
    LPAREN(): any;
    subscripts(): any;
    RPAREN(): any;
    WS: (i: any) => any;
    asTypeClause(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ResetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RESET(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ResumeStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RESUME(): any;
    WS(): any;
    NEXT(): any;
    ambiguousIdentifier(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ReturnStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RETURN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RmdirStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RMDIR(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class RsetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    RSET(): any;
    WS: (i: any) => any;
    implicitCallStmt_InStmt(): any;
    EQ(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SavepictureStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SAVEPICTURE(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SaveSettingStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SAVESETTING(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SeekStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SEEK(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SelectCaseStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SELECT(): any;
    WS: (i: any) => any;
    CASE(): any;
    valueStmt(): any;
    END_SELECT(): any;
    NEWLINE: (i: any) => any;
    sC_Case: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SC_CaseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CASE(): any;
    WS: (i: any) => any;
    sC_Cond(): any;
    block(): any;
    COLON(): any;
    NEWLINE: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SC_CondContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    copyFrom(ctx: any): void;
}
declare class SC_CondExprContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    copyFrom(ctx: any): void;
}
declare class SendkeysStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SENDKEYS(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SetattrStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SETATTR(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SetStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SET(): any;
    WS: (i: any) => any;
    implicitCallStmt_InStmt(): any;
    EQ(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class StopStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    STOP(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SubStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    SUB(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    END_SUB(): any;
    visibility(): any;
    STATIC(): any;
    argList(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TimeStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    TIME(): any;
    EQ(): any;
    valueStmt(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    TYPE(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    END_TYPE(): any;
    visibility(): any;
    NEWLINE: (i: any) => any;
    typeStmt_Element: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeStmt_ElementContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    WS: (i: any) => any;
    asTypeClause(): any;
    NEWLINE: (i: any) => any;
    subscripts(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeOfStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    TYPEOF(): any;
    WS: (i: any) => any;
    valueStmt(): any;
    IS(): any;
    type_(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UnloadStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    UNLOAD(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class UnlockStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    UNLOCK(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    TO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WS: (i: any) => any;
    variableListStmt(): any;
    DIM(): any;
    STATIC(): any;
    visibility(): any;
    WITHEVENTS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableListStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    variableSubStmt: (i: any) => any;
    COMMA: (i: any) => any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VariableSubStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    typeHint(): any;
    LPAREN(): any;
    RPAREN(): any;
    WS: (i: any) => any;
    asTypeClause(): any;
    subscripts(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WhileWendStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WHILE(): any;
    WS(): any;
    valueStmt(): any;
    WEND(): any;
    NEWLINE: (i: any) => any;
    block: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WidthStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WIDTH(): any;
    WS: (i: any) => any;
    valueStmt: (i: any) => any;
    COMMA(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WithStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WITH(): any;
    WS: (i: any) => any;
    implicitCallStmt_InStmt(): any;
    END_WITH(): any;
    NEW(): any;
    NEWLINE: (i: any) => any;
    block(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class WriteStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    WRITE(): any;
    WS: (i: any) => any;
    valueStmt(): any;
    COMMA(): any;
    outputList(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ExplicitCallStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    eCS_ProcedureCall(): any;
    eCS_MemberProcedureCall(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ECS_ProcedureCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CALL(): any;
    WS: (i: any) => any;
    ambiguousIdentifier(): any;
    typeHint(): any;
    LPAREN(): any;
    argsCall(): any;
    RPAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ECS_MemberProcedureCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    CALL(): any;
    WS: (i: any) => any;
    DOT(): any;
    ambiguousIdentifier(): any;
    implicitCallStmt_InStmt(): any;
    typeHint(): any;
    LPAREN(): any;
    argsCall(): any;
    RPAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImplicitCallStmt_InBlockContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    iCS_B_ProcedureCall(): any;
    iCS_B_MemberProcedureCall(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_B_ProcedureCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    certainIdentifier(): any;
    WS(): any;
    argsCall(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_B_MemberProcedureCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOT(): any;
    ambiguousIdentifier(): any;
    implicitCallStmt_InStmt(): any;
    typeHint(): any;
    WS(): any;
    argsCall(): any;
    dictionaryCallStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ImplicitCallStmt_InStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    iCS_S_MembersCall(): any;
    iCS_S_VariableOrProcedureCall(): any;
    iCS_S_ProcedureOrArrayCall(): any;
    iCS_S_DictionaryCall(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_S_VariableOrProcedureCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    typeHint(): any;
    dictionaryCallStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_S_ProcedureOrArrayCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    baseType(): any;
    iCS_S_NestedProcedureCall(): any;
    typeHint(): any;
    WS: (i: any) => any;
    LPAREN: (i: any) => any;
    RPAREN: (i: any) => any;
    dictionaryCallStmt(): any;
    argsCall: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_S_NestedProcedureCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    LPAREN(): any;
    RPAREN(): any;
    typeHint(): any;
    WS: (i: any) => any;
    argsCall(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_S_MembersCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    iCS_S_VariableOrProcedureCall(): any;
    iCS_S_ProcedureOrArrayCall(): any;
    iCS_S_MemberCall: (i: any) => any;
    dictionaryCallStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_S_MemberCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    DOT(): any;
    iCS_S_VariableOrProcedureCall(): any;
    iCS_S_ProcedureOrArrayCall(): any;
    WS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ICS_S_DictionaryCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    dictionaryCallStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgsCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    argCall: (i: any) => any;
    COMMA: (i: any) => any;
    SEMICOLON: (i: any) => any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgCallContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    valueStmt(): any;
    WS(): any;
    BYVAL(): any;
    BYREF(): any;
    PARAMARRAY(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class DictionaryCallStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EXCLAMATIONMARK(): any;
    ambiguousIdentifier(): any;
    typeHint(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgListContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LPAREN(): any;
    RPAREN(): any;
    arg: (i: any) => any;
    WS: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    OPTIONAL(): any;
    WS: (i: any) => any;
    PARAMARRAY(): any;
    typeHint(): any;
    LPAREN(): any;
    RPAREN(): any;
    asTypeClause(): any;
    argDefaultValue(): any;
    BYVAL(): any;
    BYREF(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ArgDefaultValueContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    EQ(): any;
    valueStmt(): any;
    WS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class SubscriptsContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    subscript_: (i: any) => any;
    COMMA: (i: any) => any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Subscript_Context {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    valueStmt: (i: any) => any;
    WS: (i: any) => any;
    TO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AmbiguousIdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IDENTIFIER: (i: any) => any;
    ambiguousKeyword: (i: any) => any;
    L_SQUARE_BRACKET(): any;
    R_SQUARE_BRACKET(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AsTypeClauseContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AS(): any;
    WS: (i: any) => any;
    type_(): any;
    NEW(): any;
    fieldLength(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BaseTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    BOOLEAN(): any;
    BYTE(): any;
    COLLECTION(): any;
    DATE(): any;
    DOUBLE(): any;
    INTEGER(): any;
    LONG(): any;
    OBJECT(): any;
    SINGLE(): any;
    STRING(): any;
    VARIANT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CertainIdentifierContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    IDENTIFIER: (i: any) => any;
    ambiguousKeyword: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ComparisonOperatorContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    LT(): any;
    LEQ(): any;
    GT(): any;
    GEQ(): any;
    EQ(): any;
    NEQ(): any;
    IS(): any;
    LIKE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ComplexTypeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier: (i: any) => any;
    DOT: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class FieldLengthContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    MULT(): any;
    INTEGERLITERAL(): any;
    ambiguousIdentifier(): any;
    WS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LetterrangeContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    certainIdentifier: (i: any) => any;
    MINUS(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LineLabelContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ambiguousIdentifier(): any;
    COLON(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class LiteralContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    COLORLITERAL(): any;
    DATELITERAL(): any;
    DOUBLELITERAL(): any;
    FILENUMBER(): any;
    INTEGERLITERAL(): any;
    OCTALLITERAL(): any;
    STRINGLITERAL(): any;
    TRUE(): any;
    FALSE(): any;
    NOTHING(): any;
    NULL_(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PublicPrivateVisibilityContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PRIVATE(): any;
    PUBLIC(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class PublicPrivateGlobalVisibilityContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PRIVATE(): any;
    PUBLIC(): any;
    GLOBAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class Type_Context {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    baseType(): any;
    complexType(): any;
    LPAREN(): any;
    RPAREN(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class TypeHintContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    AMPERSAND(): any;
    AT(): any;
    DOLLAR(): any;
    EXCLAMATIONMARK(): any;
    HASH(): any;
    PERCENT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VisibilityContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    PRIVATE(): any;
    PUBLIC(): any;
    FRIEND(): any;
    GLOBAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class AmbiguousKeywordContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    ACCESS(): any;
    ADDRESSOF(): any;
    ALIAS(): any;
    AND(): any;
    ATTRIBUTE(): any;
    APPACTIVATE(): any;
    APPEND(): any;
    AS(): any;
    BEEP(): any;
    BEGIN(): any;
    BINARY(): any;
    BOOLEAN(): any;
    BYVAL(): any;
    BYREF(): any;
    BYTE(): any;
    CALL(): any;
    CASE(): any;
    CLASS(): any;
    CLOSE(): any;
    CHDIR(): any;
    CHDRIVE(): any;
    COLLECTION(): any;
    CONST(): any;
    DATE(): any;
    DECLARE(): any;
    DEFBOOL(): any;
    DEFBYTE(): any;
    DEFCUR(): any;
    DEFDBL(): any;
    DEFDATE(): any;
    DEFDEC(): any;
    DEFINT(): any;
    DEFLNG(): any;
    DEFOBJ(): any;
    DEFSNG(): any;
    DEFSTR(): any;
    DEFVAR(): any;
    DELETESETTING(): any;
    DIM(): any;
    DO(): any;
    DOUBLE(): any;
    EACH(): any;
    ELSE(): any;
    ELSEIF(): any;
    END(): any;
    ENUM(): any;
    EQV(): any;
    ERASE(): any;
    ERROR(): any;
    EVENT(): any;
    FALSE(): any;
    FILECOPY(): any;
    FRIEND(): any;
    FOR(): any;
    FUNCTION(): any;
    GET(): any;
    GLOBAL(): any;
    GOSUB(): any;
    GOTO(): any;
    IF(): any;
    IMP(): any;
    IMPLEMENTS(): any;
    IN(): any;
    INPUT(): any;
    IS(): any;
    INTEGER(): any;
    KILL(): any;
    LOAD(): any;
    LOCK(): any;
    LONG(): any;
    LOOP(): any;
    LEN(): any;
    LET(): any;
    LIB(): any;
    LIKE(): any;
    LSET(): any;
    ME(): any;
    MID(): any;
    MKDIR(): any;
    MOD(): any;
    NAME(): any;
    NEXT(): any;
    NEW(): any;
    NOT(): any;
    NOTHING(): any;
    NULL_(): any;
    OBJECT(): any;
    ON(): any;
    OPEN(): any;
    OPTIONAL(): any;
    OR(): any;
    OUTPUT(): any;
    PARAMARRAY(): any;
    PRESERVE(): any;
    PRINT(): any;
    PRIVATE(): any;
    PUBLIC(): any;
    PUT(): any;
    RANDOM(): any;
    RANDOMIZE(): any;
    RAISEEVENT(): any;
    READ(): any;
    REDIM(): any;
    REM(): any;
    RESET(): any;
    RESUME(): any;
    RETURN(): any;
    RMDIR(): any;
    RSET(): any;
    SAVEPICTURE(): any;
    SAVESETTING(): any;
    SEEK(): any;
    SELECT(): any;
    SENDKEYS(): any;
    SET(): any;
    SETATTR(): any;
    SHARED(): any;
    SINGLE(): any;
    SPC(): any;
    STATIC(): any;
    STEP(): any;
    STOP(): any;
    STRING(): any;
    SUB(): any;
    TAB(): any;
    TEXT(): any;
    THEN(): any;
    TIME(): any;
    TO(): any;
    TRUE(): any;
    TYPE(): any;
    TYPEOF(): any;
    UNLOAD(): any;
    UNLOCK(): any;
    UNTIL(): any;
    VARIANT(): any;
    VERSION(): any;
    WEND(): any;
    WHILE(): any;
    WIDTH(): any;
    WITH(): any;
    WITHEVENTS(): any;
    WRITE(): any;
    XOR(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionExplicitStmtContext extends ModuleOptionContext {
    constructor(parser: any, ctx: any);
    OPTION_EXPLICIT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionBaseStmtContext extends ModuleOptionContext {
    constructor(parser: any, ctx: any);
    OPTION_BASE(): any;
    WS(): any;
    INTEGERLITERAL(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionPrivateModuleStmtContext extends ModuleOptionContext {
    constructor(parser: any, ctx: any);
    OPTION_PRIVATE_MODULE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class OptionCompareStmtContext extends ModuleOptionContext {
    constructor(parser: any, ctx: any);
    OPTION_COMPARE(): any;
    WS(): any;
    BINARY(): any;
    TEXT(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class BlockIfThenElseContext extends IfThenElseStmtContext {
    constructor(parser: any, ctx: any);
    ifBlockStmt(): any;
    END_IF(): any;
    ifElseIfBlockStmt: (i: any) => any;
    ifElseBlockStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class InlineIfThenElseContext extends IfThenElseStmtContext {
    constructor(parser: any, ctx: any);
    IF(): any;
    WS: (i: any) => any;
    ifConditionStmt(): any;
    THEN(): any;
    blockStmt: (i: any) => any;
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseCondExprContext extends SC_CondContext {
    constructor(parser: any, ctx: any);
    sC_CondExpr: (i: any) => any;
    COMMA: (i: any) => any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseCondElseContext extends SC_CondContext {
    constructor(parser: any, ctx: any);
    ELSE(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseCondExprValueContext extends SC_CondExprContext {
    constructor(parser: any, ctx: any);
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseCondExprIsContext extends SC_CondExprContext {
    constructor(parser: any, ctx: any);
    IS(): any;
    comparisonOperator(): any;
    valueStmt(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class CaseCondExprToContext extends SC_CondExprContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    WS: (i: any) => any;
    TO(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsAssignContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    implicitCallStmt_InStmt(): any;
    ASSIGN(): any;
    valueStmt(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsNotContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    NOT(): any;
    WS: (i: any) => any;
    valueStmt(): any;
    LPAREN(): any;
    RPAREN(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsStructContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    LPAREN(): any;
    valueStmt: (i: any) => any;
    RPAREN(): any;
    WS: (i: any) => any;
    COMMA: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsMultDivContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    MULT(): any;
    DIV(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsTypeOfContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    typeOfStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsICSContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    implicitCallStmt_InStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsXorContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    XOR(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsAddSubContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    PLUS(): any;
    MINUS(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsAndContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    AND(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsPowContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    POW(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsModContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    MOD(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsAmpContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    AMPERSAND(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsAddressOfContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    ADDRESSOF(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsNewContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    NEW(): any;
    WS(): any;
    valueStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsPlusMinusContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt(): any;
    PLUS(): any;
    MINUS(): any;
    WS(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsIDivContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    IDIV(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsOrContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    OR(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsLiteralContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    literal(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsEqvContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    EQV(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsImpContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    IMP(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsCompContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    valueStmt: (i: any) => any;
    EQ(): any;
    NEQ(): any;
    LT(): any;
    GT(): any;
    LEQ(): any;
    GEQ(): any;
    LIKE(): any;
    IS(): any;
    WS: (i: any) => any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class VsMidContext extends ValueStmtContext {
    constructor(parser: any, ctx: any);
    midStmt(): any;
    enterRule(listener: any): void;
    exitRule(listener: any): void;
    accept(visitor: any): any;
}
declare class ValueStmtContext {
    constructor(parser: any, parent: any, invokingState: any);
    parser: any;
    ruleIndex: number;
    copyFrom(ctx: any): void;
}
//# sourceMappingURL=VisualBasic6Parser.d.ts.map